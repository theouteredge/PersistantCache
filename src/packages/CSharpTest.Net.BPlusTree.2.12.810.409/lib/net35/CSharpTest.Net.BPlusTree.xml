<?xml version="1.0" encoding="utf-8"?>
<doc>
    <assembly>
        <name>CSharpTest.Net.BPlusTree</name>
    </assembly>
    <members>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2">
            <summary>
            Implements an IDictionary interface for a simple file-based database
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs#32">BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs</see></para><code lang="C#">            mreStop.Reset();
            using(TempFile temp = new TempFile())
            {
                BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2 options = new BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2(
                    PrimitiveSerializer.Guid, new TestInfoSerializer());
                options.CalcBTreeOrder(16, 24);
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                using (BPlusTree&lt;Guid, TestInfo&gt; tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    var actions = new List&lt;IAsyncResult&gt;();
                    var tests = new Action&lt;BPlusTree&lt;Guid, TestInfo&gt;&gt;[] 
                    {
                        DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts,
                        FetchStuff, FetchStuff, FetchStuff, FetchStuff, FetchStuff
                    };

                    foreach (var t in tests)
                        actions.Add(t.BeginInvoke(tree, null, null));

                    do
                    {
                        Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                        Thread.Sleep(1000);
                    } while (Debugger.IsAttached);

                    mreStop.Set();
                    for (int i = 0; i &lt; actions.Count; i++)
                    {
                        tests[i].EndInvoke(actions[i]);
                    }

                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                }
            }</code><code lang="VB.NET">        mreStop.Reset()
        Using temp As New TempFile()
            Dim options As New BPlusTree(Of Guid, TestInfo).OptionsV2(PrimitiveSerializer.Guid, New TestInfoSerializer())
            options.CalcBTreeOrder(16, 24)
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            Using tree As New BPlusTree(Of Guid, TestInfo)(options)
                tree.EnableCount()
                Dim actions As var = New List(Of IAsyncResult)()
                Dim tests As var = New Action(Of BPlusTree(Of Guid, TestInfo))() {DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts, FetchStuff, _
                    FetchStuff, FetchStuff, FetchStuff, FetchStuff}

                For Each t As var In tests
                    actions.Add(t.BeginInvoke(tree, Nothing, Nothing))
                Next

                Do
                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
                    Thread.Sleep(1000)
                Loop While Debugger.IsAttached

                mreStop.[Set]()
                Dim i As Integer = 0
                While i &lt; actions.Count
                    tests(i).EndInvoke(actions(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.#ctor">
            <summary>
            Constructs an in-memory BPlusTree
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#43" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructs an in-memory BPlusTree
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#47" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.#ctor(CSharpTest.Net.Collections.BPlusTree{`0,`1}.OptionsV2)">
            <summary>
            Constructs a BPlusTree using a Version 2 file format
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#56" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs#32">BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs</see></para><code lang="C#">            mreStop.Reset();
            using(TempFile temp = new TempFile())
            {
                BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2 options = new BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2(
                    PrimitiveSerializer.Guid, new TestInfoSerializer());
                options.CalcBTreeOrder(16, 24);
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                using (BPlusTree&lt;Guid, TestInfo&gt; tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    var actions = new List&lt;IAsyncResult&gt;();
                    var tests = new Action&lt;BPlusTree&lt;Guid, TestInfo&gt;&gt;[] 
                    {
                        DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts,
                        FetchStuff, FetchStuff, FetchStuff, FetchStuff, FetchStuff
                    };

                    foreach (var t in tests)
                        actions.Add(t.BeginInvoke(tree, null, null));

                    do
                    {
                        Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                        Thread.Sleep(1000);
                    } while (Debugger.IsAttached);

                    mreStop.Set();
                    for (int i = 0; i &lt; actions.Count; i++)
                    {
                        tests[i].EndInvoke(actions[i]);
                    }

                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                }
            }</code><code lang="VB.NET">        mreStop.Reset()
        Using temp As New TempFile()
            Dim options As New BPlusTree(Of Guid, TestInfo).OptionsV2(PrimitiveSerializer.Guid, New TestInfoSerializer())
            options.CalcBTreeOrder(16, 24)
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            Using tree As New BPlusTree(Of Guid, TestInfo)(options)
                tree.EnableCount()
                Dim actions As var = New List(Of IAsyncResult)()
                Dim tests As var = New Action(Of BPlusTree(Of Guid, TestInfo))() {DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts, FetchStuff, _
                    FetchStuff, FetchStuff, FetchStuff, FetchStuff}

                For Each t As var In tests
                    actions.Add(t.BeginInvoke(tree, Nothing, Nothing))
                Next

                Do
                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
                    Thread.Sleep(1000)
                Loop While Debugger.IsAttached

                mreStop.[Set]()
                Dim i As Integer = 0
                While i &lt; actions.Count
                    tests(i).EndInvoke(actions(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.#ctor(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)">
            <summary>
            Constructs a BPlusTree using a Version 1 file format
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#63" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#131">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.Options options = new BPlusTree&lt;KeyInfo, DataValue&gt;.Options(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (TempFile copy = new TempFile())
            {
                copy.Delete();
                int minRecordCreated = StartAndAbortWriters(options, copy);

                using (TempFile.Attach(copy.TempPath + ".recovered")) //used to create the new copy
                using (TempFile.Attach(copy.TempPath + ".deleted"))  //renamed existing file
                {
                    options.CreateFile = CreatePolicy.Never;
                    int recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    if (recoveredRecords != RecordsCreated)
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated);

                    options.FileName = copy.TempPath;
                    recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated);

                    using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
                    {
                        dictionary.EnableCount();
                        Assert.AreEqual(recoveredRecords, dictionary.Count);

                        foreach (KeyValuePair&lt;KeyInfo, DataValue&gt; kv in dictionary)
                        {
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID);
                            dictionary.Remove(kv.Key);
                        }

                        Assert.AreEqual(0, dictionary.Count);
                    }
                }
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).Options(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using copy As New TempFile()
            copy.Delete()
            Dim minRecordCreated As Integer = StartAndAbortWriters(options, copy)

            Using TempFile.Attach(copy.TempPath + ".recovered")
                'used to create the new copy
                Using TempFile.Attach(copy.TempPath + ".deleted")
                    'renamed existing file
                    options.CreateFile = CreatePolicy.Never
                    Dim recoveredRecords As Integer = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    If recoveredRecords &lt;&gt; RecordsCreated Then
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated)
                    End If

                    options.FileName = copy.TempPath
                    recoveredRecords = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated)

                    Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
                        dictionary.EnableCount()
                        Assert.AreEqual(recoveredRecords, dictionary.Count)

                        For Each kv As KeyValuePair(Of KeyInfo, DataValue) In dictionary
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID)
                            dictionary.Remove(kv.Key)
                        Next

                        Assert.AreEqual(0, dictionary.Count)
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.#ctor(CSharpTest.Net.Collections.BPlusTreeOptions{`0,`1})">
            <summary>
            Constructs a BPlusTree
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#72" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBulkInsert.cs#155">BPlusTree/BPlusTree.Test/TestBulkInsert.cs</see></para><code lang="C#">            BPlusTreeOptions&lt;int, string&gt; options = Options;
            using (TempFile temp = new TempFile())
            {
                temp.Delete();
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                options.CalcBTreeOrder(4, 4);
                Stopwatch sw = Stopwatch.StartNew();
                
                Dictionary&lt;int, string&gt; expected = 
                    TestMergeRandom(options, 2, 300);

                Trace.TraceInformation("Creating {0} nodes in {1}.", expected.Count, sw.Elapsed);
                sw = Stopwatch.StartNew();

                options = Options;
                options.CreateFile = CreatePolicy.Never;
                options.FileName = temp.TempPath;
                options.CalcBTreeOrder(4, 4);
                using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
                {
                    VerifyDictionary(expected, tree);
                }

                Trace.TraceInformation("Verified {0} nodes in {1}.", expected.Count, sw.Elapsed);
            }</code><code lang="VB.NET">        Dim options As BPlusTreeOptions(Of Integer, String) = Options
        Using temp As New TempFile()
            temp.Delete()
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            options.CalcBTreeOrder(4, 4)
            Dim sw As Stopwatch = Stopwatch.StartNew()

            Dim expected As Dictionary(Of Integer, String) = TestMergeRandom(options, 2, 300)

            Trace.TraceInformation("Creating {0} nodes in {1}.", expected.Count, sw.Elapsed)
            sw = Stopwatch.StartNew()

            options = Options
            options.CreateFile = CreatePolicy.Never
            options.FileName = temp.TempPath
            options.CalcBTreeOrder(4, 4)
            Using tree As New BPlusTree(Of Integer, String)(options)
                VerifyDictionary(expected, tree)
            End Using

            Trace.TraceInformation("Verified {0} nodes in {1}.", expected.Count, sw.Elapsed)
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose">
            <summary>
            Closes the storage and clears memory used by the instance
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#152" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Commit">
            <summary>
            When using TransactionLog, this method commits the changes in the current
            instance to the output file and truncates the log.  For all other cases the method is a 
            no-op and no exception is raised.  This method is NOT thread safe UNLESS the CallLevelLock
            property has been set to valid reader/writer lock.  If you need to call this method while
            writers are currently accessing the tree, make sure the CallLevelLock options is specified.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#197" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback">
            <summary>
            With version 2 storage this will revert the contents of tree to it's initial state when
            the file was first opened, or to the state captured with the last call to commit.  Any
            transaction log data will be truncated.
            </summary>
            <exception cref="T:System.InvalidOperationException">Raised when called for a BPlusTree that is not using v2 files</exception>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#242" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs#93">BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; tree = Create(Options))
            {
                tree.EnableCount();
                Assert.AreEqual(0, tree.Count);
                tree.Rollback();
                Assert.AreEqual(0, tree.Count);
                tree.Commit();
                Assert.AreEqual(0, tree.Count);

                tree.Add(1, "A");
                tree.Rollback();
                Assert.AreEqual(0, tree.Count);
                tree.Commit();
                Assert.AreEqual(0, tree.Count);

                tree.Add(1, "A");
                tree.Commit();
                Assert.AreEqual(1, tree.Count);
                tree.Rollback();
                Assert.AreEqual(1, tree.Count);

                tree.Add(2, "B");
                tree.Rollback();
                Assert.AreEqual(1, tree.Count);
                tree[1] = "abc";
                tree.Commit();
                Assert.AreEqual(1, tree.Count);
                tree.Rollback();

                Assert.AreEqual("abc", tree[1]);
                Assert.IsFalse(tree.ContainsKey(2));
            }
</code><code lang="VB.NET">        Using tree As BPlusTree(Of Integer, String) = Create(Options)
            tree.EnableCount()
            Assert.AreEqual(0, tree.Count)
            tree.Rollback()
            Assert.AreEqual(0, tree.Count)
            tree.Commit()
            Assert.AreEqual(0, tree.Count)

            tree.Add(1, "A")
            tree.Rollback()
            Assert.AreEqual(0, tree.Count)
            tree.Commit()
            Assert.AreEqual(0, tree.Count)

            tree.Add(1, "A")
            tree.Commit()
            Assert.AreEqual(1, tree.Count)
            tree.Rollback()
            Assert.AreEqual(1, tree.Count)

            tree.Add(2, "B")
            tree.Rollback()
            Assert.AreEqual(1, tree.Count)
            tree(1) = "abc"
            tree.Commit()
            Assert.AreEqual(1, tree.Count)
            tree.Rollback()

            Assert.AreEqual("abc", tree(1))
            Assert.IsFalse(tree.ContainsKey(2))
        End Using
</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.EnableCount">
            <summary> 
            Due to the cost of upkeep, this must be enable each time the object is created via a call to
            EnableCount() which itself must be done before any writer threads are active for it to be
            accurate.  This requires that the entire tree be loaded (sequentially) in order to build
            the initial working count.  Once completed, members like Add() and Remove() will keep the
            initial count accurate.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#296" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs#32">BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs</see></para><code lang="C#">            mreStop.Reset();
            using(TempFile temp = new TempFile())
            {
                BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2 options = new BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2(
                    PrimitiveSerializer.Guid, new TestInfoSerializer());
                options.CalcBTreeOrder(16, 24);
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                using (BPlusTree&lt;Guid, TestInfo&gt; tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    var actions = new List&lt;IAsyncResult&gt;();
                    var tests = new Action&lt;BPlusTree&lt;Guid, TestInfo&gt;&gt;[] 
                    {
                        DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts,
                        FetchStuff, FetchStuff, FetchStuff, FetchStuff, FetchStuff
                    };

                    foreach (var t in tests)
                        actions.Add(t.BeginInvoke(tree, null, null));

                    do
                    {
                        Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                        Thread.Sleep(1000);
                    } while (Debugger.IsAttached);

                    mreStop.Set();
                    for (int i = 0; i &lt; actions.Count; i++)
                    {
                        tests[i].EndInvoke(actions[i]);
                    }

                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                }
            }</code><code lang="VB.NET">        mreStop.Reset()
        Using temp As New TempFile()
            Dim options As New BPlusTree(Of Guid, TestInfo).OptionsV2(PrimitiveSerializer.Guid, New TestInfoSerializer())
            options.CalcBTreeOrder(16, 24)
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            Using tree As New BPlusTree(Of Guid, TestInfo)(options)
                tree.EnableCount()
                Dim actions As var = New List(Of IAsyncResult)()
                Dim tests As var = New Action(Of BPlusTree(Of Guid, TestInfo))() {DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts, FetchStuff, _
                    FetchStuff, FetchStuff, FetchStuff, FetchStuff}

                For Each t As var In tests
                    actions.Add(t.BeginInvoke(tree, Nothing, Nothing))
                Next

                Do
                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
                    Thread.Sleep(1000)
                Loop While Debugger.IsAttached

                mreStop.[Set]()
                Dim i As Integer = 0
                While i &lt; actions.Count
                    tests(i).EndInvoke(actions(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.UnloadCache">
            <summary>
            Safely removes all items from the in-memory cache.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#309" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#442">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                data.EnableCount();

                int[][] TestArrays = new int[][]
                {
                    new int[] { 10, 18, 81, 121, 76, 31, 250, 174, 24, 38, 246, 79 },
                    new int[] { 110,191,84,218,170,217,199,232,184,254,32,90,241,136,181,28,226,69,52 },
                };

                foreach (int[] arry in TestArrays)
                {
                    data.Clear();
                    Assert.AreEqual(0, data.Count);

                    int count = 0;
                    foreach (int id in arry)
                    {
                        data.Add(id, id.ToString());
                        Assert.AreEqual(++count, data.Count);
                    }

                    Assert.AreEqual(arry.Length, data.Count);
                    data.UnloadCache();

                    foreach (int id in arry)
                    {
                        Assert.AreEqual(id.ToString(), data[id]);
                        data[id] = String.Empty;
                        Assert.AreEqual(String.Empty, data[id]);
                        
                        Assert.IsTrue(data.Remove(id));
                        Assert.AreEqual(--count, data.Count);
                    }

                    Assert.AreEqual(0, data.Count);
                }
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            data.EnableCount()

            Dim TestArrays As Integer()() = New Integer()() {New Integer() {10, 18, 81, 121, 76, 31, _
                250, 174, 24, 38, 246, 79}, New Integer() {110, 191, 84, 218, 170, 217, _
                199, 232, 184, 254, 32, 90, _
                241, 136, 181, 28, 226, 69, _
                52}}

            For Each arry As Integer() In TestArrays
                data.Clear()
                Assert.AreEqual(0, data.Count)

                Dim count As Integer = 0
                For Each id As Integer In arry
                    data.Add(id, id.ToString())
                    Assert.AreEqual(System.Threading.Interlocked.Increment(count), data.Count)
                Next

                Assert.AreEqual(arry.Length, data.Count)
                data.UnloadCache()

                For Each id As Integer In arry
                    Assert.AreEqual(id.ToString(), data(id))
                    data(id) = [String].Empty
                    Assert.AreEqual([String].Empty, data(id))

                    Assert.IsTrue(data.Remove(id))
                    Assert.AreEqual(System.Threading.Interlocked.Decrement(count), data.Count)
                Next

                Assert.AreEqual(0, data.Count)
            Next
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2" /> contains an element with the specified key.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#383" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs#93">BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; tree = Create(Options))
            {
                tree.EnableCount();
                Assert.AreEqual(0, tree.Count);
                tree.Rollback();
                Assert.AreEqual(0, tree.Count);
                tree.Commit();
                Assert.AreEqual(0, tree.Count);

                tree.Add(1, "A");
                tree.Rollback();
                Assert.AreEqual(0, tree.Count);
                tree.Commit();
                Assert.AreEqual(0, tree.Count);

                tree.Add(1, "A");
                tree.Commit();
                Assert.AreEqual(1, tree.Count);
                tree.Rollback();
                Assert.AreEqual(1, tree.Count);

                tree.Add(2, "B");
                tree.Rollback();
                Assert.AreEqual(1, tree.Count);
                tree[1] = "abc";
                tree.Commit();
                Assert.AreEqual(1, tree.Count);
                tree.Rollback();

                Assert.AreEqual("abc", tree[1]);
                Assert.IsFalse(tree.ContainsKey(2));
            }
</code><code lang="VB.NET">        Using tree As BPlusTree(Of Integer, String) = Create(Options)
            tree.EnableCount()
            Assert.AreEqual(0, tree.Count)
            tree.Rollback()
            Assert.AreEqual(0, tree.Count)
            tree.Commit()
            Assert.AreEqual(0, tree.Count)

            tree.Add(1, "A")
            tree.Rollback()
            Assert.AreEqual(0, tree.Count)
            tree.Commit()
            Assert.AreEqual(0, tree.Count)

            tree.Add(1, "A")
            tree.Commit()
            Assert.AreEqual(1, tree.Count)
            tree.Rollback()
            Assert.AreEqual(1, tree.Count)

            tree.Add(2, "B")
            tree.Rollback()
            Assert.AreEqual(1, tree.Count)
            tree(1) = "abc"
            tree.Commit()
            Assert.AreEqual(1, tree.Count)
            tree.Rollback()

            Assert.AreEqual("abc", tree(1))
            Assert.IsFalse(tree.ContainsKey(2))
        End Using
</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.ContainsKey(`0)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.ContainsKey(TKey)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#392" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#522">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            string test;
            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                data.Add(2, "v2");
                data.Add(1, "v1");

                int i = 0;
                for (; i &lt; 8; i++)
                    data.TryAdd(i, "v" + i);
                for (i = 16; i &gt;= 8; i--)
                    data.TryAdd(i, "v" + i);
                data.TryAdd(13, "v" + i);

                for (i = 0; i &lt;= 16; i++)
                {
                    if (!data.TryGetValue(i, out test))
                        throw new ApplicationException();
                    Assert.AreEqual("v" + i, test);
                }

                data.Remove(1);
                data.Remove(3);
                IEnumerator&lt;KeyValuePair&lt;int, string&gt;&gt; e = data.GetEnumerator();
                Assert.IsTrue(e.MoveNext());
                Assert.AreEqual(0, e.Current.Key);
                data.Add(1, "v1");
                Assert.IsTrue(e.MoveNext());
                data.Add(3, "v3");
                Assert.IsTrue(e.MoveNext());
                data.Remove(8);
                Assert.IsTrue(e.MoveNext());
                e.Dispose();
                data.Add(8, "v8");

                i = 0;
                foreach (KeyValuePair&lt;int, string&gt; pair in data)
                    Assert.AreEqual(pair.Key, i++);

                for (i = 0; i &lt;= 16; i++)
                    Assert.IsTrue(data.Remove(i) &amp;&amp; data.TryAdd(i, "v" + i));

                for (i = 6; i &lt;= 12; i++)
                    Assert.IsTrue(data.Remove(i));

                for (i = 6; i &lt;= 12; i++)
                {
                    Assert.IsFalse(data.TryGetValue(i, out test));
                    Assert.IsNull(test);
                }

                for (i = 0; i &lt;= 5; i++)
                {
                    Assert.IsTrue(data.TryGetValue(i, out test));
                    Assert.AreEqual("v" + i, test);
                }

                for (i = 13; i &lt;= 16; i++)
                {
                    Assert.IsTrue(data.TryGetValue(i, out test));
                    Assert.AreEqual("v" + i, test);
                }

                for (i = 0; i &lt;= 16; i++)
                    Assert.AreEqual(i &lt; 6 || i &gt; 12, data.Remove(i));
            }</code><code lang="VB.NET">        Dim test As String
        Using data As BPlusTree(Of Integer, String) = Create(Options)
            data.Add(2, "v2")
            data.Add(1, "v1")

            Dim i As Integer = 0
            While i &lt; 8
                data.TryAdd(i, "v" + i)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
            i = 16
            While i &gt;= 8
                data.TryAdd(i, "v" + i)
                System.Math.Max(System.Threading.Interlocked.Decrement(i),i + 1)
            End While
            data.TryAdd(13, "v" + i)

            i = 0
            While i &lt;= 16
                If Not data.TryGetValue(i, test) Then
                    Throw New ApplicationException()
                End If
                Assert.AreEqual("v" + i, test)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            data.Remove(1)
            data.Remove(3)
            Dim e As IEnumerator(Of KeyValuePair(Of Integer, String)) = data.GetEnumerator()
            Assert.IsTrue(e.MoveNext())
            Assert.AreEqual(0, e.Current.Key)
            data.Add(1, "v1")
            Assert.IsTrue(e.MoveNext())
            data.Add(3, "v3")
            Assert.IsTrue(e.MoveNext())
            data.Remove(8)
            Assert.IsTrue(e.MoveNext())
            e.Dispose()
            data.Add(8, "v8")

            i = 0
            For Each pair As KeyValuePair(Of Integer, String) In data
                Assert.AreEqual(pair.Key, System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1))
            Next

            i = 0
            While i &lt;= 16
                Assert.IsTrue(data.Remove(i) AndAlso data.TryAdd(i, "v" + i))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            i = 6
            While i &lt;= 12
                Assert.IsTrue(data.Remove(i))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            i = 6
            While i &lt;= 12
                Assert.IsFalse(data.TryGetValue(i, test))
                Assert.IsNull(test)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            i = 0
            While i &lt;= 5
                Assert.IsTrue(data.TryGetValue(i, test))
                Assert.AreEqual("v" + i, test)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            i = 13
            While i &lt;= 16
                Assert.IsTrue(data.TryGetValue(i, test))
                Assert.AreEqual("v" + i, test)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            i = 0
            While i &lt;= 16
                Assert.AreEqual(i &lt; 6 OrElse i &gt; 12, data.Remove(i))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1)">
            <summary>
            Updates an element with the provided key to the value if it exists.
            </summary>
            <returns>Returns true if the key provided was found and updated to the value.</returns>
            <param name="key">The object to use as the key of the element to update.</param>
            <param name="value">The new value for the key if found.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only.</exception>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#409" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#355">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                Assert.IsTrue(data.TryAdd(1, "a"));
                Assert.IsFalse(data.TryAdd(1, "a"));

                Assert.IsTrue(data.TryUpdate(1, "a"));
                Assert.IsTrue(data.TryUpdate(1, "c"));
                Assert.IsTrue(data.TryUpdate(1, "d", "c"));
                Assert.IsFalse(data.TryUpdate(1, "f", "c"));
                Assert.AreEqual("d", data[1]);
                Assert.IsTrue(data.TryUpdate(1, "a", data[1]));
                Assert.AreEqual("a", data[1]);
                Assert.IsFalse(data.TryUpdate(2, "b"));

                string val;
                Assert.IsTrue(data.TryRemove(1, out val) &amp;&amp; val == "a");
                Assert.IsFalse(data.TryRemove(2, out val));
                Assert.AreNotEqual(val, "a");
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            Assert.IsTrue(data.TryAdd(1, "a"))
            Assert.IsFalse(data.TryAdd(1, "a"))

            Assert.IsTrue(data.TryUpdate(1, "a"))
            Assert.IsTrue(data.TryUpdate(1, "c"))
            Assert.IsTrue(data.TryUpdate(1, "d", "c"))
            Assert.IsFalse(data.TryUpdate(1, "f", "c"))
            Assert.AreEqual("d", data(1))
            Assert.IsTrue(data.TryUpdate(1, "a", data(1)))
            Assert.AreEqual("a", data(1))
            Assert.IsFalse(data.TryUpdate(2, "b"))

            Dim val As String
            Assert.IsTrue(data.TryRemove(1, val) AndAlso val = "a")
            Assert.IsFalse(data.TryRemove(2, val))
            Assert.AreNotEqual(val, "a")
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1,`1)">
            <summary>
            Updates an element with the provided key to the value if it exists.
            </summary>
            <returns>Returns true if the key provided was found and updated to the value.</returns>
            <param name="key">The object to use as the key of the element to update.</param>
            <param name="value">The new value for the key if found.</param>
            <param name="comparisonValue">The value that is compared to the value of the element with key.</param>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#426" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#355">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                Assert.IsTrue(data.TryAdd(1, "a"));
                Assert.IsFalse(data.TryAdd(1, "a"));

                Assert.IsTrue(data.TryUpdate(1, "a"));
                Assert.IsTrue(data.TryUpdate(1, "c"));
                Assert.IsTrue(data.TryUpdate(1, "d", "c"));
                Assert.IsFalse(data.TryUpdate(1, "f", "c"));
                Assert.AreEqual("d", data[1]);
                Assert.IsTrue(data.TryUpdate(1, "a", data[1]));
                Assert.AreEqual("a", data[1]);
                Assert.IsFalse(data.TryUpdate(2, "b"));

                string val;
                Assert.IsTrue(data.TryRemove(1, out val) &amp;&amp; val == "a");
                Assert.IsFalse(data.TryRemove(2, out val));
                Assert.AreNotEqual(val, "a");
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            Assert.IsTrue(data.TryAdd(1, "a"))
            Assert.IsFalse(data.TryAdd(1, "a"))

            Assert.IsTrue(data.TryUpdate(1, "a"))
            Assert.IsTrue(data.TryUpdate(1, "c"))
            Assert.IsTrue(data.TryUpdate(1, "d", "c"))
            Assert.IsFalse(data.TryUpdate(1, "f", "c"))
            Assert.AreEqual("d", data(1))
            Assert.IsTrue(data.TryUpdate(1, "a", data(1)))
            Assert.AreEqual("a", data(1))
            Assert.IsFalse(data.TryUpdate(2, "b"))

            Dim val As String
            Assert.IsTrue(data.TryRemove(1, val) AndAlso val = "a")
            Assert.IsFalse(data.TryRemove(2, val))
            Assert.AreNotEqual(val, "a")
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})">
            <summary>
            Modify the value associated with the result of the provided update method
            as an atomic operation, Allows for reading/writing a single record within
            the tree lock.  Be cautious about the behavior and performance of the code 
            provided as it can cause a dead-lock to occur.  If the method returns an
            instance who .Equals the original, no update is applied.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#443" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.KeyValueUpdate{`0,`1}">KeyValueUpdate&lt;TKey,TValue&gt;</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Presorts the provided enumeration in batches and then performs an optimized insert on the resulting set(s).
            </summary>
            <param name="unorderedItems">The items to insert</param>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#463" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)">
            <summary>
            Presorts the provided enumeration in batches and then performs an optimized insert on the resulting set(s).
            </summary>
            <param name="unorderedItems">The items to insert</param>
            <param name="allowUpdates">True to overwrite any existing records</param>
            <returns>The total number of records inserted or updated</returns>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.AddRange(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#472" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#175">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            Stopwatch sw = Stopwatch.StartNew();
            var options = Options.Clone();
            using (TempFile temp = new TempFile())
            {
                //using (BPlusTree&lt;int, string&gt; data = Create(Options))
                using (BPlusTree&lt;int, string&gt; data = Create(options))
                {
                    const bool bulk = true;
                    Insert(data, CreateRandom(1000, 3000), bulk, false);

                    data.EnableCount();
                    Assert.AreEqual(1000, data.Count);

                    Insert(data, CreateCount(data.Last().Key + 1, 1, 1000), bulk, true);
                    Assert.AreEqual(2000, data.Count);

                    Insert(data, CreateCount(data.Last().Key + 10001, -1, 1000), bulk, false);
                    Assert.AreEqual(3000, data.Count);

                    int lastKey = data.Last().Key;
                    data.AddRange(CreateCount(1, 2, lastKey / 2), true);
                }
                temp.Dispose();
            }
            Trace.WriteLine("Inserted in " + sw.Elapsed);</code><code lang="VB.NET">        Dim sw As Stopwatch = Stopwatch.StartNew()
        Dim options As var = Options.Clone()
        Using temp As New TempFile()
            'using (BPlusTree&lt;int, string&gt; data = Create(Options))
            Using data As BPlusTree(Of Integer, String) = Create(options)
                Const  bulk As Boolean = True
                Insert(data, CreateRandom(1000, 3000), bulk, False)

                data.EnableCount()
                Assert.AreEqual(1000, data.Count)

                Insert(data, CreateCount(data.Last().Key + 1, 1, 1000), bulk, True)
                Assert.AreEqual(2000, data.Count)

                Insert(data, CreateCount(data.Last().Key + 10001, -1, 1000), bulk, False)
                Assert.AreEqual(3000, data.Count)

                Dim lastKey As Integer = data.Last().Key
                data.AddRange(CreateCount(1, 2, lastKey / 2), True)
            End Using
            temp.Dispose()
        End Using
        Trace.WriteLine("Inserted in " + sw.Elapsed)</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary> 
            Optimized insert of presorted key/value pairs.  
            If the input is not presorted, please use AddRange() instead.
            </summary>
            <param name="items">The ordered list of items to insert</param>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#511" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)">
            <summary>
            Optimized insert of presorted key/value pairs.  
            If the input is not presorted, please use AddRange() instead.
            </summary>
            <param name="items">The ordered list of items to insert</param>
            <param name="allowUpdates">True to overwrite any existing records</param>
            <returns>The total number of records inserted or updated</returns>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRange(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#521" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#540" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.GetOrAdd(`0,`1)">
            <summary>
            Adds a key/value pair to the  <see cref="T:System.Collections.Generic.IDictionary`2" /> if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value to be added, if the key does not already exist.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only.</exception>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#552" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#342">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                Assert.AreEqual("a", data.GetOrAdd(1, "a"));
                Assert.AreEqual("a", data.GetOrAdd(1, "b"));

                Assert.AreEqual("b", data.GetOrAdd(2, k =&gt; "b"));
                Assert.AreEqual("b", data.GetOrAdd(2, k =&gt; "c"));
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            Assert.AreEqual("a", data.GetOrAdd(1, "a"))
            Assert.AreEqual("a", data.GetOrAdd(1, "b"))

            Assert.AreEqual("b", data.GetOrAdd(2, Function(k) "b"))
            Assert.AreEqual("b", data.GetOrAdd(2, Function(k) "c"))
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.GetOrAdd(`0,System.Converter{`0,`1})">
            <summary>
            Adds a key/value pair to the  <see cref="T:System.Collections.Generic.IDictionary`2" /> if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="fnCreate">Constructs a new value for the key.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2" /> is read-only.</exception>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#565" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#342">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                Assert.AreEqual("a", data.GetOrAdd(1, "a"));
                Assert.AreEqual("a", data.GetOrAdd(1, "b"));

                Assert.AreEqual("b", data.GetOrAdd(2, k =&gt; "b"));
                Assert.AreEqual("b", data.GetOrAdd(2, k =&gt; "c"));
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            Assert.AreEqual("a", data.GetOrAdd(1, "a"))
            Assert.AreEqual("a", data.GetOrAdd(1, "b"))

            Assert.AreEqual("b", data.GetOrAdd(2, Function(k) "b"))
            Assert.AreEqual("b", data.GetOrAdd(2, Function(k) "c"))
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryAdd(`0,System.Converter{`0,`1})">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2" />
            by calling the provided factory method to construct the value if the key is not already present in the collection.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#576" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#216">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            const int CountPerThread = 100;

            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using (WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, CountPerThread).Run);

                for (int i = 0; i &lt; CountPerThread; i++)
                {
                    if(i%2 == 0)
                    {
                        try {
                            dictionary.TryAdd(new KeyInfo(Guid.NewGuid(), i), k =&gt; { throw new ExpectedException(); });
                        } catch { }
                    }
                    else
                    {
                        try
                        {
                            dictionary.TryRemove(dictionary.First().Key, (k, v) =&gt; { throw new ExpectedException(); });
                        }
                        catch { }
                    }
                }

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Const  CountPerThread As Integer = 100

        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, CountPerThread).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Dim i As Integer = 0
                While i &lt; CountPerThread
                    If i Mod 2 = 0 Then
                        Try
                            dictionary.TryAdd(New KeyInfo(Guid.NewGuid(), i), Function(k) 
                            Throw New ExpectedException()

End Function)
                        Catch
                        End Try
                    Else
                        Try
                            dictionary.TryRemove(dictionary.First().Key, Function(k, v) 
                            Throw New ExpectedException()

End Function)
                        Catch
                        End Try
                    End If
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryAdd(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#585" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestFileSerialized.cs#119">BPlusTree/BPlusTree.Test/TestFileSerialized.cs</see></para><code lang="C#">            try
            {
                using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(Options))
                {
                    Assert.IsTrue(tree.TryAdd(1, "hi"));
                    TempFile.Delete();
                }
                Assert.Fail();
            }
            catch(IOException) { }</code><code lang="VB.NET">        Try
            Using tree As New BPlusTree(Of Integer, String)(Options)
                Assert.IsTrue(tree.TryAdd(1, "hi"))
                TempFile.Delete()
            End Using
            Assert.Fail()
        Catch generatedExceptionName As IOException
        End Try</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,`1)">
            <summary>
            Adds or modifies an element with the provided key and value.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#595" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,`1,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Generic.IDictionary`2" /> if the key does not already exist, 
            or updates a key/value pair if the key already exists.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#605" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.KeyValueUpdate{`0,`1}">KeyValueUpdate&lt;TKey,TValue&gt;</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#268">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                Assert.AreEqual("a", data.AddOrUpdate(1, "a", (k, v) =&gt; k.ToString()));
                Assert.AreEqual("1", data.AddOrUpdate(1, "a", (k, v) =&gt; k.ToString()));

                Assert.AreEqual("b", data.AddOrUpdate(2, k =&gt; "b", (k, v) =&gt; k.ToString()));
                Assert.AreEqual("2", data.AddOrUpdate(2, k =&gt; "b", (k, v) =&gt; k.ToString()));
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            Assert.AreEqual("a", data.AddOrUpdate(1, "a", Function(k, v) k.ToString()))
            Assert.AreEqual("1", data.AddOrUpdate(1, "a", Function(k, v) k.ToString()))

            Assert.AreEqual("b", data.AddOrUpdate(2, Function(k) "b", Function(k, v) k.ToString()))
            Assert.AreEqual("2", data.AddOrUpdate(2, Function(k) "b", Function(k, v) k.ToString()))
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,System.Converter{`0,`1},CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Generic.IDictionary`2" /> if the key does not already exist, 
            or updates a key/value pair if the key already exists.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#616" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.KeyValueUpdate{`0,`1}">KeyValueUpdate&lt;TKey,TValue&gt;</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#268">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                Assert.AreEqual("a", data.AddOrUpdate(1, "a", (k, v) =&gt; k.ToString()));
                Assert.AreEqual("1", data.AddOrUpdate(1, "a", (k, v) =&gt; k.ToString()));

                Assert.AreEqual("b", data.AddOrUpdate(2, k =&gt; "b", (k, v) =&gt; k.ToString()));
                Assert.AreEqual("2", data.AddOrUpdate(2, k =&gt; "b", (k, v) =&gt; k.ToString()));
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            Assert.AreEqual("a", data.AddOrUpdate(1, "a", Function(k, v) k.ToString()))
            Assert.AreEqual("1", data.AddOrUpdate(1, "a", Function(k, v) k.ToString()))

            Assert.AreEqual("b", data.AddOrUpdate(2, Function(k) "b", Function(k, v) k.ToString()))
            Assert.AreEqual("2", data.AddOrUpdate(2, Function(k) "b", Function(k, v) k.ToString()))
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate``1(`0,``0@)">
            <summary>
            Add, update, or fetche a key/value pair from the dictionary via an implementation of the
            <see cref="T:CSharpTest.Net.Collections.ICreateOrUpdateValue`2" /> interface.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#627" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryRemove(`0,`1@)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key" /> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </returns>
            <param name="key">The key of the element to remove.</param>
            <param name="value">The value that was removed.</param>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#658" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#355">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                Assert.IsTrue(data.TryAdd(1, "a"));
                Assert.IsFalse(data.TryAdd(1, "a"));

                Assert.IsTrue(data.TryUpdate(1, "a"));
                Assert.IsTrue(data.TryUpdate(1, "c"));
                Assert.IsTrue(data.TryUpdate(1, "d", "c"));
                Assert.IsFalse(data.TryUpdate(1, "f", "c"));
                Assert.AreEqual("d", data[1]);
                Assert.IsTrue(data.TryUpdate(1, "a", data[1]));
                Assert.AreEqual("a", data[1]);
                Assert.IsFalse(data.TryUpdate(2, "b"));

                string val;
                Assert.IsTrue(data.TryRemove(1, out val) &amp;&amp; val == "a");
                Assert.IsFalse(data.TryRemove(2, out val));
                Assert.AreNotEqual(val, "a");
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            Assert.IsTrue(data.TryAdd(1, "a"))
            Assert.IsFalse(data.TryAdd(1, "a"))

            Assert.IsTrue(data.TryUpdate(1, "a"))
            Assert.IsTrue(data.TryUpdate(1, "c"))
            Assert.IsTrue(data.TryUpdate(1, "d", "c"))
            Assert.IsFalse(data.TryUpdate(1, "f", "c"))
            Assert.AreEqual("d", data(1))
            Assert.IsTrue(data.TryUpdate(1, "a", data(1)))
            Assert.AreEqual("a", data(1))
            Assert.IsFalse(data.TryUpdate(2, "b"))

            Dim val As String
            Assert.IsTrue(data.TryRemove(1, val) AndAlso val = "a")
            Assert.IsFalse(data.TryRemove(2, val))
            Assert.AreNotEqual(val, "a")
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#670" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#131">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.Options options = new BPlusTree&lt;KeyInfo, DataValue&gt;.Options(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (TempFile copy = new TempFile())
            {
                copy.Delete();
                int minRecordCreated = StartAndAbortWriters(options, copy);

                using (TempFile.Attach(copy.TempPath + ".recovered")) //used to create the new copy
                using (TempFile.Attach(copy.TempPath + ".deleted"))  //renamed existing file
                {
                    options.CreateFile = CreatePolicy.Never;
                    int recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    if (recoveredRecords != RecordsCreated)
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated);

                    options.FileName = copy.TempPath;
                    recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated);

                    using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
                    {
                        dictionary.EnableCount();
                        Assert.AreEqual(recoveredRecords, dictionary.Count);

                        foreach (KeyValuePair&lt;KeyInfo, DataValue&gt; kv in dictionary)
                        {
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID);
                            dictionary.Remove(kv.Key);
                        }

                        Assert.AreEqual(0, dictionary.Count);
                    }
                }
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).Options(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using copy As New TempFile()
            copy.Delete()
            Dim minRecordCreated As Integer = StartAndAbortWriters(options, copy)

            Using TempFile.Attach(copy.TempPath + ".recovered")
                'used to create the new copy
                Using TempFile.Attach(copy.TempPath + ".deleted")
                    'renamed existing file
                    options.CreateFile = CreatePolicy.Never
                    Dim recoveredRecords As Integer = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    If recoveredRecords &lt;&gt; RecordsCreated Then
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated)
                    End If

                    options.FileName = copy.TempPath
                    recoveredRecords = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated)

                    Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
                        dictionary.EnableCount()
                        Assert.AreEqual(recoveredRecords, dictionary.Count)

                        For Each kv As KeyValuePair(Of KeyInfo, DataValue) In dictionary
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID)
                            dictionary.Remove(kv.Key)
                        Next

                        Assert.AreEqual(0, dictionary.Count)
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryRemove(`0,CSharpTest.Net.Collections.KeyValuePredicate{`0,`1})">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2" />
            if the fnCondition predicate is null or returns true.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#680" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.KeyValuePredicate{`0,`1}">KeyValuePredicate&lt;TKey,TValue&gt;</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#216">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            const int CountPerThread = 100;

            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using (WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, CountPerThread).Run);

                for (int i = 0; i &lt; CountPerThread; i++)
                {
                    if(i%2 == 0)
                    {
                        try {
                            dictionary.TryAdd(new KeyInfo(Guid.NewGuid(), i), k =&gt; { throw new ExpectedException(); });
                        } catch { }
                    }
                    else
                    {
                        try
                        {
                            dictionary.TryRemove(dictionary.First().Key, (k, v) =&gt; { throw new ExpectedException(); });
                        }
                        catch { }
                    }
                }

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Const  CountPerThread As Integer = 100

        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, CountPerThread).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Dim i As Integer = 0
                While i &lt; CountPerThread
                    If i Mod 2 = 0 Then
                        Try
                            dictionary.TryAdd(New KeyInfo(Guid.NewGuid(), i), Function(k) 
                            Throw New ExpectedException()

End Function)
                        Catch
                        End Try
                    Else
                        Try
                            dictionary.TryRemove(dictionary.First().Key, Function(k, v) 
                            Throw New ExpectedException()

End Function)
                        Catch
                        End Try
                    End If
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryRemove``1(`0,``0@)">
            <summary>
            Conditionally removes a key/value pair from the dictionary via an implementation of the
            <see cref="T:CSharpTest.Net.Collections.IRemoveValue`2" /> interface.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#690" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.First">
            <summary>
            Returns the first key and it's associated value.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#709" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><exception cref="T:System.InvalidOperationException" /><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#216">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            const int CountPerThread = 100;

            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using (WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, CountPerThread).Run);

                for (int i = 0; i &lt; CountPerThread; i++)
                {
                    if(i%2 == 0)
                    {
                        try {
                            dictionary.TryAdd(new KeyInfo(Guid.NewGuid(), i), k =&gt; { throw new ExpectedException(); });
                        } catch { }
                    }
                    else
                    {
                        try
                        {
                            dictionary.TryRemove(dictionary.First().Key, (k, v) =&gt; { throw new ExpectedException(); });
                        }
                        catch { }
                    }
                }

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Const  CountPerThread As Integer = 100

        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, CountPerThread).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Dim i As Integer = 0
                While i &lt; CountPerThread
                    If i Mod 2 = 0 Then
                        Try
                            dictionary.TryAdd(New KeyInfo(Guid.NewGuid(), i), Function(k) 
                            Throw New ExpectedException()

End Function)
                        Catch
                        End Try
                    Else
                        Try
                            dictionary.TryRemove(dictionary.First().Key, Function(k, v) 
                            Throw New ExpectedException()

End Function)
                        Catch
                        End Try
                    End If
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetFirst(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Returns the first key and it's associated value.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.First" cat="Used By">KeyValuePair&lt;TKey,TValue&gt; BPlusTree&lt;TKey,TValue&gt;.First()</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#720" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#379">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                data.Add(1, "a");
                data.Add(2, "b");
                data.Add(3, "c");
                data.Add(4, "d");
                data.Add(5, "e");

                Assert.AreEqual(1, data.First().Key);
                Assert.AreEqual("a", data.First().Value);
                data.Remove(1);
                Assert.AreEqual(2, data.First().Key);
                Assert.AreEqual("b", data.First().Value);

                Assert.AreEqual(5, data.Last().Key);
                Assert.AreEqual("e", data.Last().Value);
                data.Remove(5);
                Assert.AreEqual(4, data.Last().Key);
                Assert.AreEqual("d", data.Last().Value);

                data.Remove(4);
                data.Remove(3);

                KeyValuePair&lt;int, string&gt; kv;
                Assert.IsTrue(data.TryGetLast(out kv));
                Assert.IsTrue(data.TryGetFirst(out kv));
                data.Remove(2);
                Assert.IsFalse(data.TryGetLast(out kv));
                Assert.IsFalse(data.TryGetFirst(out kv));

                try { data.First(); Assert.Fail("Should raise InvalidOperationException"); }
                catch (InvalidOperationException) { }
                try { data.Last(); Assert.Fail("Should raise InvalidOperationException"); }
                catch (InvalidOperationException) { }
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            data.Add(1, "a")
            data.Add(2, "b")
            data.Add(3, "c")
            data.Add(4, "d")
            data.Add(5, "e")

            Assert.AreEqual(1, data.First().Key)
            Assert.AreEqual("a", data.First().Value)
            data.Remove(1)
            Assert.AreEqual(2, data.First().Key)
            Assert.AreEqual("b", data.First().Value)

            Assert.AreEqual(5, data.Last().Key)
            Assert.AreEqual("e", data.Last().Value)
            data.Remove(5)
            Assert.AreEqual(4, data.Last().Key)
            Assert.AreEqual("d", data.Last().Value)

            data.Remove(4)
            data.Remove(3)

            Dim kv As KeyValuePair(Of Integer, String)
            Assert.IsTrue(data.TryGetLast(kv))
            Assert.IsTrue(data.TryGetFirst(kv))
            data.Remove(2)
            Assert.IsFalse(data.TryGetLast(kv))
            Assert.IsFalse(data.TryGetFirst(kv))

            Try
                data.First()
                Assert.Fail("Should raise InvalidOperationException")
            Catch generatedExceptionName As InvalidOperationException
            End Try
            Try
                data.Last()
                Assert.Fail("Should raise InvalidOperationException")
            Catch generatedExceptionName As InvalidOperationException
            End Try
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Last">
            <summary>
            Returns the last key and it's associated value.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#729" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><exception cref="T:System.InvalidOperationException" /><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#45">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                                  {
                                      CreateFile = CreatePolicy.Always,
                                      FileName = tempFile.TempPath,
                                  }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.CreateFile = CreatePolicy.Never;
                readcopy.ReadOnly = true;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                {
                    using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                    {
                        copy.EnableCount();
                        Assert.AreEqual(0, copy.Count);
                    }

                    //insert some data...
                    tree.AddRange(MakeValues(0, 100));

                    using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                    {
                        copy.EnableCount();
                        Assert.AreEqual(0, copy.Count);
                    }
                    tree.Commit();

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tree.AddRange(MakeValues(1000, 1000));

                    using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                    {
                        copy.EnableCount();
                        Assert.AreEqual(100, copy.Count);
                        Assert.AreEqual(0, copy.First().Key);
                        Assert.AreEqual(99, copy.Last().Key);
                    }

                    tree.Commit();

                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                Key .CreateFile = CreatePolicy.Always, _
                Key .FileName = tempFile.TempPath _
            }.CalcBTreeOrder(4, 10)

            Dim readcopy As var = options.Clone()
            readcopy.CreateFile = CreatePolicy.Never
            readcopy.[ReadOnly] = True

            Using tree As var = New BPlusTree(Of Integer, String)(options)
                Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                    copy.EnableCount()
                    Assert.AreEqual(0, copy.Count)
                End Using

                'insert some data...
                tree.AddRange(MakeValues(0, 100))

                Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                    copy.EnableCount()
                    Assert.AreEqual(0, copy.Count)
                End Using
                tree.Commit()

                'insert some data...
                Dim i As Integer = 0
                While i &lt; 100
                    tree.Remove(i)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While
                tree.AddRange(MakeValues(1000, 1000))

                Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                    copy.EnableCount()
                    Assert.AreEqual(100, copy.Count)
                    Assert.AreEqual(0, copy.First().Key)
                    Assert.AreEqual(99, copy.Last().Key)
                End Using


                tree.Commit()
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetLast(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Returns the last key and it's associated value.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Last" cat="Used By">KeyValuePair&lt;TKey,TValue&gt; BPlusTree&lt;TKey,TValue&gt;.Last()</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#740" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#379">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                data.Add(1, "a");
                data.Add(2, "b");
                data.Add(3, "c");
                data.Add(4, "d");
                data.Add(5, "e");

                Assert.AreEqual(1, data.First().Key);
                Assert.AreEqual("a", data.First().Value);
                data.Remove(1);
                Assert.AreEqual(2, data.First().Key);
                Assert.AreEqual("b", data.First().Value);

                Assert.AreEqual(5, data.Last().Key);
                Assert.AreEqual("e", data.Last().Value);
                data.Remove(5);
                Assert.AreEqual(4, data.Last().Key);
                Assert.AreEqual("d", data.Last().Value);

                data.Remove(4);
                data.Remove(3);

                KeyValuePair&lt;int, string&gt; kv;
                Assert.IsTrue(data.TryGetLast(out kv));
                Assert.IsTrue(data.TryGetFirst(out kv));
                data.Remove(2);
                Assert.IsFalse(data.TryGetLast(out kv));
                Assert.IsFalse(data.TryGetFirst(out kv));

                try { data.First(); Assert.Fail("Should raise InvalidOperationException"); }
                catch (InvalidOperationException) { }
                try { data.Last(); Assert.Fail("Should raise InvalidOperationException"); }
                catch (InvalidOperationException) { }
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            data.Add(1, "a")
            data.Add(2, "b")
            data.Add(3, "c")
            data.Add(4, "d")
            data.Add(5, "e")

            Assert.AreEqual(1, data.First().Key)
            Assert.AreEqual("a", data.First().Value)
            data.Remove(1)
            Assert.AreEqual(2, data.First().Key)
            Assert.AreEqual("b", data.First().Value)

            Assert.AreEqual(5, data.Last().Key)
            Assert.AreEqual("e", data.Last().Value)
            data.Remove(5)
            Assert.AreEqual(4, data.Last().Key)
            Assert.AreEqual("d", data.Last().Value)

            data.Remove(4)
            data.Remove(3)

            Dim kv As KeyValuePair(Of Integer, String)
            Assert.IsTrue(data.TryGetLast(kv))
            Assert.IsTrue(data.TryGetFirst(kv))
            data.Remove(2)
            Assert.IsFalse(data.TryGetLast(kv))
            Assert.IsFalse(data.TryGetFirst(kv))

            Try
                data.First()
                Assert.Fail("Should raise InvalidOperationException")
            Catch generatedExceptionName As InvalidOperationException
            End Try
            Try
                data.Last()
                Assert.Fail("Should raise InvalidOperationException")
            Catch generatedExceptionName As InvalidOperationException
            End Try
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateFrom(`0)">
            <summary>
            Inclusivly enumerates from start key to the end of the collection
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#749" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#116">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                for (int i = 0; i &lt; 100; i++)
                    data.Add(i, i.ToString());

                Assert.AreEqual(50, new List&lt;KeyValuePair&lt;int, string&gt;&gt;(data.EnumerateFrom(50)).Count);
                Assert.AreEqual(25, new List&lt;KeyValuePair&lt;int, string&gt;&gt;(data.EnumerateFrom(75)).Count);

                for (int i = 0; i &lt; 100; i++)
                {
                    int first = -1;
                    foreach (KeyValuePair&lt;int, string&gt; kv in data.EnumerateFrom(i))
                    {
                        first = kv.Key;
                        break;
                    }
                    Assert.AreEqual(i, first);
                }
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            Dim i As Integer = 0
            While i &lt; 100
                data.Add(i, i.ToString())
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            Assert.AreEqual(50, New List(Of KeyValuePair(Of Integer, String))(data.EnumerateFrom(50)).Count)
            Assert.AreEqual(25, New List(Of KeyValuePair(Of Integer, String))(data.EnumerateFrom(75)).Count)

            Dim i As Integer = 0
            While i &lt; 100
                Dim first As Integer = -1
                For Each kv As KeyValuePair(Of Integer, String) In data.EnumerateFrom(i)
                    first = kv.Key
                    Exit For
                Next
                Assert.AreEqual(i, first)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateRange(`0,`0)">
            <summary>
            Inclusivly enumerates from start key to stop key
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#16707565" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#93">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                for (int i = 0; i &lt; 100; i++)
                    data.Add(i, i.ToString());

                int ix = 0;
                foreach (KeyValuePair&lt;int, string&gt; kv in data.EnumerateRange(-500, 5000))
                    Assert.AreEqual(ix++, kv.Key);
                Assert.AreEqual(100, ix);

                foreach (KeyValuePair&lt;int, int&gt; range in new Dictionary&lt;int, int&gt; { { 6, 25 }, { 7, 25 }, { 8, 25 }, { 9, 25 }, { 22, 25 }, { 28, 28 } })
                {
                    ix = range.Key;
                    foreach (KeyValuePair&lt;int, string&gt; kv in data.EnumerateRange(ix, range.Value))
                        Assert.AreEqual(ix++, kv.Key);
                    Assert.AreEqual(range.Value, ix - 1);
                }
            }</code><code lang="VB.NET">        Using data As BPlusTree(Of Integer, String) = Create(Options)
            Dim i As Integer = 0
            While i &lt; 100
                data.Add(i, i.ToString())
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            Dim ix As Integer = 0
            For Each kv As KeyValuePair(Of Integer, String) In data.EnumerateRange(-500, 5000)
                Assert.AreEqual(System.Math.Max(System.Threading.Interlocked.Increment(ix),ix - 1), kv.Key)
            Next
            Assert.AreEqual(100, ix)

            For Each range As KeyValuePair(Of Integer, Integer) In New Dictionary(Of Integer, Integer)() From { _
                {6, 25}, _
                {7, 25}, _
                {8, 25}, _
                {9, 25}, _
                {22, 25}, _
                {28, 28} _
            }
                ix = range.Key
                For Each kv As KeyValuePair(Of Integer, String) In data.EnumerateRange(ix, range.Value)
                    Assert.AreEqual(System.Math.Max(System.Threading.Interlocked.Increment(ix),ix - 1), kv.Key)
                Next
                Assert.AreEqual(range.Value, ix - 1)
            Next
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#765" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.CopyTo(KeyValuePair&lt;TKey,TValue&gt;[],Int32)</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#131">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.Options options = new BPlusTree&lt;KeyInfo, DataValue&gt;.Options(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (TempFile copy = new TempFile())
            {
                copy.Delete();
                int minRecordCreated = StartAndAbortWriters(options, copy);

                using (TempFile.Attach(copy.TempPath + ".recovered")) //used to create the new copy
                using (TempFile.Attach(copy.TempPath + ".deleted"))  //renamed existing file
                {
                    options.CreateFile = CreatePolicy.Never;
                    int recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    if (recoveredRecords != RecordsCreated)
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated);

                    options.FileName = copy.TempPath;
                    recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated);

                    using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
                    {
                        dictionary.EnableCount();
                        Assert.AreEqual(recoveredRecords, dictionary.Count);

                        foreach (KeyValuePair&lt;KeyInfo, DataValue&gt; kv in dictionary)
                        {
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID);
                            dictionary.Remove(kv.Key);
                        }

                        Assert.AreEqual(0, dictionary.Count);
                    }
                }
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).Options(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using copy As New TempFile()
            copy.Delete()
            Dim minRecordCreated As Integer = StartAndAbortWriters(options, copy)

            Using TempFile.Attach(copy.TempPath + ".recovered")
                'used to create the new copy
                Using TempFile.Attach(copy.TempPath + ".deleted")
                    'renamed existing file
                    options.CreateFile = CreatePolicy.Never
                    Dim recoveredRecords As Integer = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    If recoveredRecords &lt;&gt; RecordsCreated Then
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated)
                    End If

                    options.FileName = copy.TempPath
                    recoveredRecords = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated)

                    Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
                        dictionary.EnableCount()
                        Assert.AreEqual(recoveredRecords, dictionary.Count)

                        For Each kv As KeyValuePair(Of KeyInfo, DataValue) In dictionary
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID)
                            dictionary.Remove(kv.Key)
                        Next

                        Assert.AreEqual(0, dictionary.Count)
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#897" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Clear">
            <summary>
            Removes all items from the collection and permanently destroys all storage.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#906" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#485">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            int iterations = 5;
            int limit = 255;

            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                data.EnableCount();

                List&lt;int&gt; numbers = new List&lt;int&gt;();
                while (iterations-- &gt; 0)
                {
                    data.Clear();
                    numbers.Clear();
                    data.DebugSetValidateOnCheckpoint(true);

                    for (int i = 0; i &lt; limit; i++)
                    {
                        int id = Random.Next(limit);
                        if (!numbers.Contains(id))
                        {
                            numbers.Add(id);
                            data.Add(id, "V" + id);
                        }
                    }

                    Assert.AreEqual(numbers.Count, data.Count);

                    foreach (int number in numbers)
                        Assert.IsTrue(data.Remove(number));

                    Assert.AreEqual(0, data.Count);
                }
            }</code><code lang="VB.NET">        Dim iterations As Integer = 5
        Dim limit As Integer = 255

        Using data As BPlusTree(Of Integer, String) = Create(Options)
            data.EnableCount()

            Dim numbers As New List(Of Integer)()
            While System.Math.Max(System.Threading.Interlocked.Decrement(iterations),iterations + 1) &gt; 0
                data.Clear()
                numbers.Clear()
                data.DebugSetValidateOnCheckpoint(True)

                Dim i As Integer = 0
                While i &lt; limit
                    Dim id As Integer = Random.[Next](limit)
                    If Not numbers.Contains(id) Then
                        numbers.Add(id)
                        data.Add(id, "V" + id)
                    End If
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.AreEqual(numbers.Count, data.Count)

                For Each number As Integer In numbers
                    Assert.IsTrue(data.Remove(number))
                Next

                Assert.AreEqual(0, data.Count)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugSetOutput(System.IO.TextWriter)">
            <summary>
            Sets a text writter that the entire btree will be dumped to after every read/write/seek operation.
            The format is a single line of text in abbreviated form: {k1{k1,k2,k3},k4{k4,k5}}
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Debug.cs#38" cat="Source Code">BPlusTree/Collections/BPlusTree.Debug.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#50">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            var options = Options;
            options.BTreeOrder = 4;
            using (BPlusTree&lt;int, string&gt; data = new BPlusTree&lt;int,string&gt;(options))
            {
                data.EnableCount();
                
                data.DebugSetOutput(new StringWriter());
                data.DebugSetValidateOnCheckpoint(true);

                for (int id = 0; id &lt; 10; id++)
                    data.Add(id, id.ToString());

                using (IEnumerator&lt;KeyValuePair&lt;int, string&gt;&gt; enu = data.GetEnumerator())
                {
                    Assert.IsTrue(enu.MoveNext());
                    Assert.AreEqual(0, enu.Current.Key);

                    for (int id = 2; id &lt; 10; id++)
                        Assert.IsTrue(data.Remove(id));
                    for (int id = 6; id &lt; 11; id++)
                        data.Add(id, id.ToString());

                    Assert.IsTrue(enu.MoveNext());
                    Assert.AreEqual(1, enu.Current.Key);
                    Assert.IsTrue(enu.MoveNext());
                    Assert.AreEqual(6, enu.Current.Key);
                    Assert.IsTrue(enu.MoveNext());
                    Assert.AreEqual(7, enu.Current.Key);
                    Assert.IsTrue(data.Remove(8));
                    Assert.IsTrue(data.Remove(9));
                    Assert.IsTrue(data.Remove(10));
                    data.Add(11, 11.ToString());
                    Assert.IsTrue(enu.MoveNext());
                    Assert.AreEqual(11, enu.Current.Key);
                    Assert.IsTrue(false == enu.MoveNext());
                }
                data.Clear();
            }</code><code lang="VB.NET">        Dim options As var = Options
        options.BTreeOrder = 4
        Using data As New BPlusTree(Of Integer, String)(options)
            data.EnableCount()

            data.DebugSetOutput(New StringWriter())
            data.DebugSetValidateOnCheckpoint(True)

            Dim id As Integer = 0
            While id &lt; 10
                data.Add(id, id.ToString())
                System.Math.Max(System.Threading.Interlocked.Increment(id),id - 1)
            End While

            Using enu As IEnumerator(Of KeyValuePair(Of Integer, String)) = data.GetEnumerator()
                Assert.IsTrue(enu.MoveNext())
                Assert.AreEqual(0, enu.Current.Key)

                Dim id As Integer = 2
                While id &lt; 10
                    Assert.IsTrue(data.Remove(id))
                    System.Math.Max(System.Threading.Interlocked.Increment(id),id - 1)
                End While
                Dim id As Integer = 6
                While id &lt; 11
                    data.Add(id, id.ToString())
                    System.Math.Max(System.Threading.Interlocked.Increment(id),id - 1)
                End While

                Assert.IsTrue(enu.MoveNext())
                Assert.AreEqual(1, enu.Current.Key)
                Assert.IsTrue(enu.MoveNext())
                Assert.AreEqual(6, enu.Current.Key)
                Assert.IsTrue(enu.MoveNext())
                Assert.AreEqual(7, enu.Current.Key)
                Assert.IsTrue(data.Remove(8))
                Assert.IsTrue(data.Remove(9))
                Assert.IsTrue(data.Remove(10))
                data.Add(11, 11.ToString())
                Assert.IsTrue(enu.MoveNext())
                Assert.AreEqual(11, enu.Current.Key)
                Assert.IsTrue(False = enu.MoveNext())
            End Using
            data.Clear()
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugSetValidateOnCheckpoint(System.Boolean)">
            <summary>
            Sets a boolean condition that will validate the state of the entire btree after every operation.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Debug.cs#47" cat="Source Code">BPlusTree/Collections/BPlusTree.Debug.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#485">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            int iterations = 5;
            int limit = 255;

            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                data.EnableCount();

                List&lt;int&gt; numbers = new List&lt;int&gt;();
                while (iterations-- &gt; 0)
                {
                    data.Clear();
                    numbers.Clear();
                    data.DebugSetValidateOnCheckpoint(true);

                    for (int i = 0; i &lt; limit; i++)
                    {
                        int id = Random.Next(limit);
                        if (!numbers.Contains(id))
                        {
                            numbers.Add(id);
                            data.Add(id, "V" + id);
                        }
                    }

                    Assert.AreEqual(numbers.Count, data.Count);

                    foreach (int number in numbers)
                        Assert.IsTrue(data.Remove(number));

                    Assert.AreEqual(0, data.Count);
                }
            }</code><code lang="VB.NET">        Dim iterations As Integer = 5
        Dim limit As Integer = 255

        Using data As BPlusTree(Of Integer, String) = Create(Options)
            data.EnableCount()

            Dim numbers As New List(Of Integer)()
            While System.Math.Max(System.Threading.Interlocked.Decrement(iterations),iterations + 1) &gt; 0
                data.Clear()
                numbers.Clear()
                data.DebugSetValidateOnCheckpoint(True)

                Dim i As Integer = 0
                While i &lt; limit
                    Dim id As Integer = Random.[Next](limit)
                    If Not numbers.Contains(id) Then
                        numbers.Add(id)
                        data.Add(id, "V" + id)
                    End If
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.AreEqual(numbers.Count, data.Count)

                For Each number As Integer In numbers
                    Assert.IsTrue(data.Remove(number))
                Next

                Assert.AreEqual(0, data.Count)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Print(System.IO.TextWriter,CSharpTest.Net.Collections.BPlusTree{`0,`1}.DebugFormat)">
            <summary>
            Prints the entire tree to the text writer
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Debug.cs#87" cat="Source Code">BPlusTree/Collections/BPlusTree.Debug.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat">BPlusTree&lt;TKey,TValue&gt;.DebugFormat</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Validate">
            <summary>
            Forces a top-down, depth-first, crawl of the entire tree in which every node and
            every link or key is checked for accuracy.  Throws on error.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Debug.cs#144" cat="Source Code">BPlusTree/Collections/BPlusTree.Debug.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateFile(CSharpTest.Net.Collections.BPlusTreeOptions{`0,`1})">
            <summary>
            Directly enumerates the contents of BPlusTree from disk in read-only mode.
            </summary>
            <param name="options"> The options normally used to create the <see cref="T:CSharpTest.Net.Collections.BPlusTree`2" /> instance </param>
            <returns> Yields the Key/Value pairs found in the file </returns>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.BPlusTreeOptions{`0,`1}">BPlusTreeOptions&lt;TKey,TValue&gt;</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)">
            <summary>
            Recovers as much file content as possible into a newly created <see cref="T:CSharpTest.Net.Collections.BPlusTree`2" />, if the operation returns
            a non-zero result it was successful and the file has been replaced with a new database containing
            the recovered data.  The original file remains in-tact but was renamed with a '.deleted' extension.
            </summary>
            <remarks> 
            If an exception occurs during the parsing of the file and one or more records were recovered, they will
            be stored in a file by the same name with an added extension of '.recovered'.  This recovered file can be
            opened as a normal <see cref="T:CSharpTest.Net.Collections.BPlusTree`2" /> to view it's contents.  During the restore it is possible that
            a single Key was found multiple times, in this case the first occurrence found will be used.
            </remarks>
            <param name="options"> The options normally used to create the <see cref="T:CSharpTest.Net.Collections.BPlusTree`2" /> instance </param>
            <returns>Returns 0 on failure, or the number of records successfully retrieved from the original file </returns>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Recovery.cs#89" cat="Source Code">BPlusTree/Collections/BPlusTree.Recovery.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.BPlusTree`2.Options">BPlusTree&lt;TKey,TValue&gt;.Options</seealso><exception cref="T:CSharpTest.Net.InvalidConfigurationValueException" /><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#131">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.Options options = new BPlusTree&lt;KeyInfo, DataValue&gt;.Options(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (TempFile copy = new TempFile())
            {
                copy.Delete();
                int minRecordCreated = StartAndAbortWriters(options, copy);

                using (TempFile.Attach(copy.TempPath + ".recovered")) //used to create the new copy
                using (TempFile.Attach(copy.TempPath + ".deleted"))  //renamed existing file
                {
                    options.CreateFile = CreatePolicy.Never;
                    int recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    if (recoveredRecords != RecordsCreated)
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated);

                    options.FileName = copy.TempPath;
                    recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated);

                    using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
                    {
                        dictionary.EnableCount();
                        Assert.AreEqual(recoveredRecords, dictionary.Count);

                        foreach (KeyValuePair&lt;KeyInfo, DataValue&gt; kv in dictionary)
                        {
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID);
                            dictionary.Remove(kv.Key);
                        }

                        Assert.AreEqual(0, dictionary.Count);
                    }
                }
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).Options(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using copy As New TempFile()
            copy.Delete()
            Dim minRecordCreated As Integer = StartAndAbortWriters(options, copy)

            Using TempFile.Attach(copy.TempPath + ".recovered")
                'used to create the new copy
                Using TempFile.Attach(copy.TempPath + ".deleted")
                    'renamed existing file
                    options.CreateFile = CreatePolicy.Never
                    Dim recoveredRecords As Integer = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    If recoveredRecords &lt;&gt; RecordsCreated Then
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated)
                    End If

                    options.FileName = copy.TempPath
                    recoveredRecords = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated)

                    Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
                        dictionary.EnableCount()
                        Assert.AreEqual(recoveredRecords, dictionary.Count)

                        For Each kv As KeyValuePair(Of KeyInfo, DataValue) In dictionary
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID)
                            dictionary.Remove(kv.Key)
                        Next

                        Assert.AreEqual(0, dictionary.Count)
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.RecoveryScan(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options,System.IO.FileShare)">
            <summary>
            Performs a low-level scan of the storage file to yield all Key/Value pairs it was able to read from the file.
            </summary>
            <param name="options"> The options normally used to create the <see cref="T:CSharpTest.Net.Collections.BPlusTree`2" /> instance </param>
            <param name="sharing"> <see cref="T:System.IO.FileShare" /> options used to open the file </param>
            <returns> Yields the Key/Value pairs found in the file </returns>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.BPlusTree`2.Options">BPlusTree&lt;TKey,TValue&gt;.Options</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestFileSerialized.cs#56">BPlusTree/BPlusTree.Test/TestFileSerialized.cs</see></para><code lang="C#">            BPlusTree&lt;int, string&gt;.Options options = (BPlusTree&lt;int, string&gt;.Options)Options;
            options.BTreeOrder = 4;
            options.FileBlockSize = 512;
            options.FileGrowthRate = 25;
            options.ConcurrentWriters = 4;
            options.FileOpenOptions = FileOptions.None;

            using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
            {
                for(int i=0; i &lt; 100; i++)
                    Assert.IsTrue(tree.TryAdd(i, i.ToString()));
            }

            using (Stream io = TempFile.Open())
            {
                //first we can corrupt the root node, which is always at an offset of BlockSize
                io.Seek(512, SeekOrigin.Begin);
                io.Write(new byte[512], 0, 512);

                //Now let's corrupt one byte from the end of the node at index 3
                io.Seek(1024 + 16, SeekOrigin.Begin);
                int len = PrimitiveSerializer.Int32.ReadFrom(io);
                io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin);//secrets of fragmented file revealed... ugly i know.
                io.WriteByte(255); //overwrite last used byte in chunk.
            }

            options.CreateFile = CreatePolicy.Never;

            //Now that we've corrupted part of the file content, let's take a peek
            try
            {
                using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
                {
                    foreach (KeyValuePair&lt;int, string&gt; kv in tree)
                        Assert.AreEqual(kv.Key.ToString(), kv.Value);
                }
                Assert.Fail("Expected InvalidDataException");
            }
            catch (InvalidDataException)
            { }

            Dictionary&lt;int, string&gt; found = new Dictionary&lt;int, string&gt;();
            List&lt;int&gt; duplicates = new List&lt;int&gt;();
            foreach (KeyValuePair&lt;int, string&gt; kv in BPlusTree&lt;int, string&gt;.RecoveryScan(options, FileShare.None))
            {
                if (!found.ContainsKey(kv.Key))
                    found.Add(kv.Key, kv.Value);
                else
                    duplicates.Add(kv.Key);
                
                Assert.AreEqual(kv.Key.ToString(), kv.Value);
            }
            Assert.AreNotEqual(0, found.Count);

            //The following may change...
            Assert.AreEqual(99, found.Count);
            Assert.IsFalse(found.ContainsKey(3), "should be missing #3");
            Assert.AreEqual(0, duplicates.Count);</code><code lang="VB.NET">        Dim options As BPlusTree(Of Integer, String).Options = DirectCast(Options, BPlusTree(Of Integer, String).Options)
        options.BTreeOrder = 4
        options.FileBlockSize = 512
        options.FileGrowthRate = 25
        options.ConcurrentWriters = 4
        options.FileOpenOptions = FileOptions.None

        Using tree As New BPlusTree(Of Integer, String)(options)
            Dim i As Integer = 0
            While i &lt; 100
                Assert.IsTrue(tree.TryAdd(i, i.ToString()))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
        End Using

        Using io As Stream = TempFile.Open()
            'first we can corrupt the root node, which is always at an offset of BlockSize
            io.Seek(512, SeekOrigin.Begin)
            io.Write(New Byte(512) {}, 0, 512)

            'Now let's corrupt one byte from the end of the node at index 3
            io.Seek(1024 + 16, SeekOrigin.Begin)
            Dim len As Integer = PrimitiveSerializer.Int32.ReadFrom(io)
            io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin)
            'secrets of fragmented file revealed... ugly i know.
                'overwrite last used byte in chunk.
            io.WriteByte(255)
        End Using

        options.CreateFile = CreatePolicy.Never

        'Now that we've corrupted part of the file content, let's take a peek
        Try
            Using tree As New BPlusTree(Of Integer, String)(options)
                For Each kv As KeyValuePair(Of Integer, String) In tree
                    Assert.AreEqual(kv.Key.ToString(), kv.Value)
                Next
            End Using
            Assert.Fail("Expected InvalidDataException")
        Catch generatedExceptionName As InvalidDataException
        End Try

        Dim found As New Dictionary(Of Integer, String)()
        Dim duplicates As New List(Of Integer)()
        For Each kv As KeyValuePair(Of Integer, String) In BPlusTree(Of Integer, String).RecoveryScan(options, FileShare.None)
            If Not found.ContainsKey(kv.Key) Then
                found.Add(kv.Key, kv.Value)
            Else
                duplicates.Add(kv.Key)
            End If

            Assert.AreEqual(kv.Key.ToString(), kv.Value)
        Next
        Assert.AreNotEqual(0, found.Count)

        'The following may change...
        Assert.AreEqual(99, found.Count)
        Assert.IsFalse(found.ContainsKey(3), "should be missing #3")
        Assert.AreEqual(0, duplicates.Count)</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Rewrite the entire BTree as a transaction to include the provided items.  This method is Thread safe.
            If the input is already sorted, use BulkInsertOptions overload to specify InputIsSorted = true.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/Node.BulkInsert.cs#232" cat="Source Code">BPlusTree/Collections/Node.BulkInsert.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)">
            <summary>
            Rewrite the entire BTree as a transaction to include the provided items.  This method is Thread safe.
            If the input is already sorted, use BulkInsertOptions overload to specify InputIsSorted = true.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/Node.BulkInsert.cs#238" cat="Source Code">BPlusTree/Collections/Node.BulkInsert.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.BulkInsertOptions">BulkInsertOptions</seealso><exception cref="T:System.IO.InvalidDataException" /><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateNodeContents(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin)">
            <summary>
            Exclusive access, deep-locking enumeration for bulk-insert, essentially this enumerates
            while at the same time it chases existing writers out of the tree.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.CallLevelLock">
            <summary>
            Defines the lock used to provide tree-level exclusive operations.  This should be set at the time of construction, or not at all since
            operations depending on this (Clear, EnableCount, and UnloadCache) may behave poorly if operations that started prior to setting this
            value are still being processed.  Out of the locks I've tested the ReaderWriterLocking implementation performs best here since it is
            a highly read-intensive lock.  All public APIs that access tree content will aquire this lock as a reader except the tree exclusive 
            operations.  This also allows you, by way of aquiring a write lock, to gain exclusive access and perform mass updates, atomic 
            enumeration, etc.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Synchronization.ILockStrategy">ILockStrategy</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#83">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;int, int&gt;.OptionsV2 options = new BPlusTree&lt;int, int&gt;.OptionsV2(
                new PrimitiveSerializer(), new PrimitiveSerializer());
            options.LockTimeout = 100;
            options.CallLevelLock = new ReaderWriterLocking();
        
            using (BPlusTree&lt;int, int&gt; dictionary = new BPlusTree&lt;int, int&gt;(options))
            {
                bool canwrite = false, canread = false;
                ThreadStart proc = delegate()
                {
                    try { dictionary[1] = 1; canwrite = true; } catch { canwrite = false; }
                    try { int i; dictionary.TryGetValue(1, out i); canread = true; } catch { canread = false; }
                };

                Assert.IsTrue(proc.BeginInvoke(null, null).AsyncWaitHandle.WaitOne(1000, false));
                Assert.IsTrue(canwrite);
                Assert.IsTrue(canread);

                //now we lock the entire btree:
                using (dictionary.CallLevelLock.Write())
                {
                    //they can't read or write
                    Assert.IsTrue(proc.BeginInvoke(null, null).AsyncWaitHandle.WaitOne(1000, false));
                    Assert.IsFalse(canwrite);
                    Assert.IsFalse(canread);
                    //but we can
                    proc();
                    Assert.IsTrue(canwrite);
                    Assert.IsTrue(canread);
                }
                //lock release all is well
                Assert.IsTrue(proc.BeginInvoke(null, null).AsyncWaitHandle.WaitOne(1000, false));
                Assert.IsTrue(canwrite);
                Assert.IsTrue(canread);

                //We can also make sure noone else gains exclusive access with a read lock
                using (dictionary.CallLevelLock.Read())
                {
                    Assert.IsTrue(proc.BeginInvoke(null, null).AsyncWaitHandle.WaitOne(1000, false));
                    Assert.IsTrue(canwrite);
                    Assert.IsTrue(canread);
                }
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of Integer, Integer).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer())
        options.LockTimeout = 100
        options.CallLevelLock = New ReaderWriterLocking()

        Using dictionary As New BPlusTree(Of Integer, Integer)(options)
            Dim canwrite As Boolean = False, canread As Boolean = False
            Dim proc As ThreadStart = Function() Do
                Try
                    dictionary(1) = 1
                    canwrite = True
                Catch
                    canwrite = False
                End Try
                Try
                    Dim i As Integer
                    dictionary.TryGetValue(1, i)
                    canread = True
                Catch
                    canread = False
                End Try
            End Function

            Assert.IsTrue(proc.BeginInvoke(Nothing, Nothing).AsyncWaitHandle.WaitOne(1000, False))
            Assert.IsTrue(canwrite)
            Assert.IsTrue(canread)

            'now we lock the entire btree:
            Using dictionary.CallLevelLock.Write()
                'they can't read or write
                Assert.IsTrue(proc.BeginInvoke(Nothing, Nothing).AsyncWaitHandle.WaitOne(1000, False))
                Assert.IsFalse(canwrite)
                Assert.IsFalse(canread)
                'but we can
                proc()
                Assert.IsTrue(canwrite)
                Assert.IsTrue(canread)
            End Using
            'lock release all is well
            Assert.IsTrue(proc.BeginInvoke(Nothing, Nothing).AsyncWaitHandle.WaitOne(1000, False))
            Assert.IsTrue(canwrite)
            Assert.IsTrue(canread)

            'We can also make sure noone else gains exclusive access with a read lock
            Using dictionary.CallLevelLock.Read()
                Assert.IsTrue(proc.BeginInvoke(Nothing, Nothing).AsyncWaitHandle.WaitOne(1000, False))
                Assert.IsTrue(canwrite)
                Assert.IsTrue(canread)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Count">
            <summary> See comments on EnableCount() for usage of this property </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs#32">BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs</see></para><code lang="C#">            mreStop.Reset();
            using(TempFile temp = new TempFile())
            {
                BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2 options = new BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2(
                    PrimitiveSerializer.Guid, new TestInfoSerializer());
                options.CalcBTreeOrder(16, 24);
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                using (BPlusTree&lt;Guid, TestInfo&gt; tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    var actions = new List&lt;IAsyncResult&gt;();
                    var tests = new Action&lt;BPlusTree&lt;Guid, TestInfo&gt;&gt;[] 
                    {
                        DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts,
                        FetchStuff, FetchStuff, FetchStuff, FetchStuff, FetchStuff
                    };

                    foreach (var t in tests)
                        actions.Add(t.BeginInvoke(tree, null, null));

                    do
                    {
                        Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                        Thread.Sleep(1000);
                    } while (Debugger.IsAttached);

                    mreStop.Set();
                    for (int i = 0; i &lt; actions.Count; i++)
                    {
                        tests[i].EndInvoke(actions[i]);
                    }

                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                }
            }</code><code lang="VB.NET">        mreStop.Reset()
        Using temp As New TempFile()
            Dim options As New BPlusTree(Of Guid, TestInfo).OptionsV2(PrimitiveSerializer.Guid, New TestInfoSerializer())
            options.CalcBTreeOrder(16, 24)
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            Using tree As New BPlusTree(Of Guid, TestInfo)(options)
                tree.EnableCount()
                Dim actions As var = New List(Of IAsyncResult)()
                Dim tests As var = New Action(Of BPlusTree(Of Guid, TestInfo))() {DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts, FetchStuff, _
                    FetchStuff, FetchStuff, FetchStuff, FetchStuff}

                For Each t As var In tests
                    actions.Add(t.BeginInvoke(tree, Nothing, Nothing))
                Next

                Do
                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
                    Thread.Sleep(1000)
                Loop While Debugger.IsAttached

                mreStop.[Set]()
                Dim i As Integer = 0
                While i &lt; actions.Count
                    tests(i).EndInvoke(actions(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.LockTimeout">
            <summary> Returns the lock timeout being used by this instance. </summary>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#592">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            List&lt;KeyValuePair&lt;int, string&gt;&gt; sample = new List&lt;KeyValuePair&lt;int, string&gt;&gt;();
            for (int i = 0; i &lt; 20; i++)
                sample.Add(new KeyValuePair&lt;int,string&gt;(i, i.ToString()));

            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                data.AddRange(sample);
                //Key collection
                Assert.AreEqual(data.Count, data.Keys.Count);
                Assert.IsTrue(data.Keys.IsReadOnly);
                for (int i = 0; i &lt; sample.Count &amp;&amp; i &lt; 5; i++)
                    Assert.IsTrue(data.Keys.Contains(sample[i].Key));

                IEnumerator&lt;int&gt; ek = data.Keys.GetEnumerator();
                Assert.IsTrue(ek.MoveNext());
                int firstkey = ek.Current;
                Assert.IsTrue(ek.MoveNext());
                Assert.AreNotEqual(firstkey, ek.Current);
                ek.Reset();
                Assert.IsTrue(ek.MoveNext());
                Assert.AreEqual(firstkey, ek.Current);
                Assert.AreEqual(firstkey, ((System.Collections.IEnumerator) ek).Current);

                //Value collection
                Assert.AreEqual(data.Count, data.Values.Count);
                Assert.IsTrue(data.Values.IsReadOnly);
                for (int i = 0; i &lt; sample.Count &amp;&amp; i &lt; 5; i++)
                    Assert.IsTrue(data.Values.Contains(sample[i].Value));

                IEnumerator&lt;string&gt; ev = data.Values.GetEnumerator();
                Assert.IsTrue(ev.MoveNext());
                string firstvalue = ev.Current;
                Assert.IsTrue(ev.MoveNext());
                Assert.AreNotEqual(firstvalue, ev.Current);
                ev.Reset();
                Assert.IsTrue(ev.MoveNext());
                Assert.AreEqual(firstvalue, ((System.Collections.IEnumerator) ev).Current);
            }</code><code lang="VB.NET">        Dim sample As New List(Of KeyValuePair(Of Integer, String))()
        Dim i As Integer = 0
        While i &lt; 20
            sample.Add(New KeyValuePair(Of Integer, String)(i, i.ToString()))
            System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
        End While

        Using data As BPlusTree(Of Integer, String) = Create(Options)
            data.AddRange(sample)
            'Key collection
            Assert.AreEqual(data.Count, data.Keys.Count)
            Assert.IsTrue(data.Keys.IsReadOnly)
            Dim i As Integer = 0
            While i &lt; sample.Count AndAlso i &lt; 5
                Assert.IsTrue(data.Keys.Contains(sample(i).Key))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            Dim ek As IEnumerator(Of Integer) = data.Keys.GetEnumerator()
            Assert.IsTrue(ek.MoveNext())
            Dim firstkey As Integer = ek.Current
            Assert.IsTrue(ek.MoveNext())
            Assert.AreNotEqual(firstkey, ek.Current)
            ek.Reset()
            Assert.IsTrue(ek.MoveNext())
            Assert.AreEqual(firstkey, ek.Current)
            Assert.AreEqual(firstkey, (DirectCast(ek, System.Collections.IEnumerator)).Current)

            'Value collection
            Assert.AreEqual(data.Count, data.Values.Count)
            Assert.IsTrue(data.Values.IsReadOnly)
            Dim i As Integer = 0
            While i &lt; sample.Count AndAlso i &lt; 5
                Assert.IsTrue(data.Values.Contains(sample(i).Value))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            Dim ev As IEnumerator(Of String) = data.Values.GetEnumerator()
            Assert.IsTrue(ev.MoveNext())
            Dim firstvalue As String = ev.Current
            Assert.IsTrue(ev.MoveNext())
            Assert.AreNotEqual(firstvalue, ev.Current)
            ev.Reset()
            Assert.IsTrue(ev.MoveNext())
            Assert.AreEqual(firstvalue, (DirectCast(ev, System.Collections.IEnumerator)).Current)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1" /> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2" />.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTests.cs#592">BPlusTree/BPlusTree.Test/BasicTests.cs</see></para><code lang="C#">            List&lt;KeyValuePair&lt;int, string&gt;&gt; sample = new List&lt;KeyValuePair&lt;int, string&gt;&gt;();
            for (int i = 0; i &lt; 20; i++)
                sample.Add(new KeyValuePair&lt;int,string&gt;(i, i.ToString()));

            using (BPlusTree&lt;int, string&gt; data = Create(Options))
            {
                data.AddRange(sample);
                //Key collection
                Assert.AreEqual(data.Count, data.Keys.Count);
                Assert.IsTrue(data.Keys.IsReadOnly);
                for (int i = 0; i &lt; sample.Count &amp;&amp; i &lt; 5; i++)
                    Assert.IsTrue(data.Keys.Contains(sample[i].Key));

                IEnumerator&lt;int&gt; ek = data.Keys.GetEnumerator();
                Assert.IsTrue(ek.MoveNext());
                int firstkey = ek.Current;
                Assert.IsTrue(ek.MoveNext());
                Assert.AreNotEqual(firstkey, ek.Current);
                ek.Reset();
                Assert.IsTrue(ek.MoveNext());
                Assert.AreEqual(firstkey, ek.Current);
                Assert.AreEqual(firstkey, ((System.Collections.IEnumerator) ek).Current);

                //Value collection
                Assert.AreEqual(data.Count, data.Values.Count);
                Assert.IsTrue(data.Values.IsReadOnly);
                for (int i = 0; i &lt; sample.Count &amp;&amp; i &lt; 5; i++)
                    Assert.IsTrue(data.Values.Contains(sample[i].Value));

                IEnumerator&lt;string&gt; ev = data.Values.GetEnumerator();
                Assert.IsTrue(ev.MoveNext());
                string firstvalue = ev.Current;
                Assert.IsTrue(ev.MoveNext());
                Assert.AreNotEqual(firstvalue, ev.Current);
                ev.Reset();
                Assert.IsTrue(ev.MoveNext());
                Assert.AreEqual(firstvalue, ((System.Collections.IEnumerator) ev).Current);
            }</code><code lang="VB.NET">        Dim sample As New List(Of KeyValuePair(Of Integer, String))()
        Dim i As Integer = 0
        While i &lt; 20
            sample.Add(New KeyValuePair(Of Integer, String)(i, i.ToString()))
            System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
        End While

        Using data As BPlusTree(Of Integer, String) = Create(Options)
            data.AddRange(sample)
            'Key collection
            Assert.AreEqual(data.Count, data.Keys.Count)
            Assert.IsTrue(data.Keys.IsReadOnly)
            Dim i As Integer = 0
            While i &lt; sample.Count AndAlso i &lt; 5
                Assert.IsTrue(data.Keys.Contains(sample(i).Key))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            Dim ek As IEnumerator(Of Integer) = data.Keys.GetEnumerator()
            Assert.IsTrue(ek.MoveNext())
            Dim firstkey As Integer = ek.Current
            Assert.IsTrue(ek.MoveNext())
            Assert.AreNotEqual(firstkey, ek.Current)
            ek.Reset()
            Assert.IsTrue(ek.MoveNext())
            Assert.AreEqual(firstkey, ek.Current)
            Assert.AreEqual(firstkey, (DirectCast(ek, System.Collections.IEnumerator)).Current)

            'Value collection
            Assert.AreEqual(data.Count, data.Values.Count)
            Assert.IsTrue(data.Values.IsReadOnly)
            Dim i As Integer = 0
            While i &lt; sample.Count AndAlso i &lt; 5
                Assert.IsTrue(data.Values.Contains(sample(i).Value))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            Dim ev As IEnumerator(Of String) = data.Values.GetEnumerator()
            Assert.IsTrue(ev.MoveNext())
            Dim firstvalue As String = ev.Current
            Assert.IsTrue(ev.MoveNext())
            Assert.AreNotEqual(firstvalue, ev.Current)
            ev.Reset()
            Assert.IsTrue(ev.MoveNext())
            Assert.AreEqual(firstvalue, (DirectCast(ev, System.Collections.IEnumerator)).Current)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.IsReadOnly">
            <summary>
            Returns true if the file was opened in ReadOnly mode.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Dispose()</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat">
            <summary> Print formatting for nodes </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Print(System.IO.TextWriter,CSharpTest.Net.Collections.BPlusTree{`0,`1}.DebugFormat)">BPlusTree&lt;TKey,TValue&gt;.Print(TextWriter,BPlusTree&lt;TKey,TValue&gt;.DebugFormat)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.Full">
            <summary> Full information for all nodes </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.Formatted">
            <summary> Formatted new lines and tabbify, but reduced information </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.Compact">
            <summary> Compact single line format </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso></member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2">
            <summary>
            Defines the options nessessary to construct a BPlusTree implementation
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.Clone" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.OptionsV2 BPlusTree&lt;TKey,TValue&gt;.OptionsV2.Clone()</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs#32">BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs</see></para><code lang="C#">            mreStop.Reset();
            using(TempFile temp = new TempFile())
            {
                BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2 options = new BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2(
                    PrimitiveSerializer.Guid, new TestInfoSerializer());
                options.CalcBTreeOrder(16, 24);
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                using (BPlusTree&lt;Guid, TestInfo&gt; tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    var actions = new List&lt;IAsyncResult&gt;();
                    var tests = new Action&lt;BPlusTree&lt;Guid, TestInfo&gt;&gt;[] 
                    {
                        DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts,
                        FetchStuff, FetchStuff, FetchStuff, FetchStuff, FetchStuff
                    };

                    foreach (var t in tests)
                        actions.Add(t.BeginInvoke(tree, null, null));

                    do
                    {
                        Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                        Thread.Sleep(1000);
                    } while (Debugger.IsAttached);

                    mreStop.Set();
                    for (int i = 0; i &lt; actions.Count; i++)
                    {
                        tests[i].EndInvoke(actions[i]);
                    }

                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                }
            }</code><code lang="VB.NET">        mreStop.Reset()
        Using temp As New TempFile()
            Dim options As New BPlusTree(Of Guid, TestInfo).OptionsV2(PrimitiveSerializer.Guid, New TestInfoSerializer())
            options.CalcBTreeOrder(16, 24)
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            Using tree As New BPlusTree(Of Guid, TestInfo)(options)
                tree.EnableCount()
                Dim actions As var = New List(Of IAsyncResult)()
                Dim tests As var = New Action(Of BPlusTree(Of Guid, TestInfo))() {DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts, FetchStuff, _
                    FetchStuff, FetchStuff, FetchStuff, FetchStuff}

                For Each t As var In tests
                    actions.Add(t.BeginInvoke(tree, Nothing, Nothing))
                Next

                Do
                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
                    Thread.Sleep(1000)
                Loop While Debugger.IsAttached

                mreStop.[Set]()
                Dim i As Integer = 0
                While i &lt; actions.Count
                    tests(i).EndInvoke(actions(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
            End Using
        End Using</code></example></member>
        <member name="T:CSharpTest.Net.Collections.BPlusTreeOptions`2">
            <summary>
            Defines the options nessessary to construct a BPlusTree implementation
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTreeOptions`2.#ctor(CSharpTest.Net.Serialization.ISerializer{`0},CSharpTest.Net.Serialization.ISerializer{`1},System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructs the options configuration to initialize a BPlusTree instance
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTreeOptions`2.CalcBTreeOrder(System.Int32,System.Int32)">
            <summary>
            Calculates default node-threasholds based upon the average number of bytes in key and value
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#187" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBulkInsert.cs#155">BPlusTree/BPlusTree.Test/TestBulkInsert.cs</see></para><code lang="C#">            BPlusTreeOptions&lt;int, string&gt; options = Options;
            using (TempFile temp = new TempFile())
            {
                temp.Delete();
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                options.CalcBTreeOrder(4, 4);
                Stopwatch sw = Stopwatch.StartNew();
                
                Dictionary&lt;int, string&gt; expected = 
                    TestMergeRandom(options, 2, 300);

                Trace.TraceInformation("Creating {0} nodes in {1}.", expected.Count, sw.Elapsed);
                sw = Stopwatch.StartNew();

                options = Options;
                options.CreateFile = CreatePolicy.Never;
                options.FileName = temp.TempPath;
                options.CalcBTreeOrder(4, 4);
                using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
                {
                    VerifyDictionary(expected, tree);
                }

                Trace.TraceInformation("Verified {0} nodes in {1}.", expected.Count, sw.Elapsed);
            }</code><code lang="VB.NET">        Dim options As BPlusTreeOptions(Of Integer, String) = Options
        Using temp As New TempFile()
            temp.Delete()
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            options.CalcBTreeOrder(4, 4)
            Dim sw As Stopwatch = Stopwatch.StartNew()

            Dim expected As Dictionary(Of Integer, String) = TestMergeRandom(options, 2, 300)

            Trace.TraceInformation("Creating {0} nodes in {1}.", expected.Count, sw.Elapsed)
            sw = Stopwatch.StartNew()

            options = Options
            options.CreateFile = CreatePolicy.Never
            options.FileName = temp.TempPath
            options.CalcBTreeOrder(4, 4)
            Using tree As New BPlusTree(Of Integer, String)(options)
                VerifyDictionary(expected, tree)
            End Using

            Trace.TraceInformation("Verified {0} nodes in {1}.", expected.Count, sw.Elapsed)
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTreeOptions`2.CalculateOrder(System.Int32,System.Int32)">
            <summary>
            Calculates default node-threasholds based upon the average number of bytes in key and value
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTreeOptions`2.CalcBTreeOrder(System.Int32,System.Int32)" cat="Used By">BPlusTreeOptions&lt;TKey,TValue&gt;.CalcBTreeOrder(Int32,Int32)</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CalcBTreeOrder(System.Int32,System.Int32)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.OptionsV2 BPlusTree&lt;TKey,TValue&gt;.OptionsV2.CalcBTreeOrder(Int32,Int32)</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Options.CalcBTreeOrder(System.Int32,System.Int32)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Options BPlusTree&lt;TKey,TValue&gt;.Options.CalcBTreeOrder(Int32,Int32)</seealso></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTreeOptions`2.Clone">
            <summary>
            Creates a shallow clone of the configuration options.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#460" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBulkInsert.cs#111">BPlusTree/BPlusTree.Test/TestBulkInsert.cs</see></para><code lang="C#">            BPlusTreeOptions&lt;int, string&gt; options = Options;
            using (TempFile temp = new TempFile())
            {
                options = Options;
                temp.Delete();
                //options.CreateFile = CreatePolicy.Always;
                //options.FileName = temp.TempPath;
                options.MaximumValueNodes = 14;
                options.MinimumValueNodes = 7;
                options.MaximumChildNodes = 6;
                options.MinimumChildNodes = 2;

                // Just to make sure we don't break some fencepost condition in the future
                for (int i = 0; i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1; i++)
                    TestMergeSequenceInFile(options.Clone(), i);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1);
            }</code><code lang="VB.NET">        Dim options As BPlusTreeOptions(Of Integer, String) = Options
        Using temp As New TempFile()
            options = Options
            temp.Delete()
            'options.CreateFile = CreatePolicy.Always;
            'options.FileName = temp.TempPath;
            options.MaximumValueNodes = 14
            options.MinimumValueNodes = 7
            options.MaximumChildNodes = 6
            options.MinimumChildNodes = 2

            ' Just to make sure we don't break some fencepost condition in the future
            Dim i As Integer = 0
            While i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1
                TestMergeSequenceInFile(options.Clone(), i)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes)
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1)
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTreeOptions`2.SetStorageCache(System.Boolean)">
            <summary> Enables or disables the caching and reordering of node write operations </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTreeOptions`2.SetLogFile(CSharpTest.Net.Collections.ITransactionLog{`0,`1})">
            <summary> Sets the transaction log to use </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTreeOptions`2.CreateStorage">
            <summary> Used to create the correct storage type </summary>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.KeySerializer">
            <summary> Accesses the key serializer given to the constructor </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#161" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><seealso cref="T:CSharpTest.Net.Serialization.ISerializer{`0}">ISerializer&lt;TKey&gt;</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBackupAndRecovery.cs#199">BPlusTree/BPlusTree.Test/TestBackupAndRecovery.cs</see></para><code lang="C#">            using (TempFile temp = new TempFile())
            {
                var options = GetOptions(temp);
                options.MaximumValueNodes = 255;
                options.MinimumValueNodes = 100;
                options.TransactionLog = new TransactionLog&lt;Guid, TestInfo&gt;(
                    new TransactionLogOptions&lt;Guid, TestInfo&gt;(
                        options.TransactionLogFileName,
                        options.KeySerializer,
                        options.ValueSerializer
                        ) { FileOptions = FileOptions.None } /* no-write through */
                    );
                TestRecoveryOnExisting(options, 100, ushort.MaxValue);
            }</code><code lang="VB.NET">        Using temp As New TempFile()
            Dim options As var = GetOptions(temp)
            options.MaximumValueNodes = 255
            options.MinimumValueNodes = 100
                ' no-write through 
            options.TransactionLog = New TransactionLog(Of Guid, TestInfo)(New TransactionLogOptions(Of Guid, TestInfo)(options.TransactionLogFileName, options.KeySerializer, options.ValueSerializer) With { _
                Key .FileOptions = FileOptions.None _
            })
            TestRecoveryOnExisting(options, 100, UShort.MaxValue)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.ValueSerializer">
            <summary> Accesses the key serializer given to the constructor </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#164" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><seealso cref="T:CSharpTest.Net.Serialization.ISerializer{`1}">ISerializer&lt;TValue&gt;</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBackupAndRecovery.cs#199">BPlusTree/BPlusTree.Test/TestBackupAndRecovery.cs</see></para><code lang="C#">            using (TempFile temp = new TempFile())
            {
                var options = GetOptions(temp);
                options.MaximumValueNodes = 255;
                options.MinimumValueNodes = 100;
                options.TransactionLog = new TransactionLog&lt;Guid, TestInfo&gt;(
                    new TransactionLogOptions&lt;Guid, TestInfo&gt;(
                        options.TransactionLogFileName,
                        options.KeySerializer,
                        options.ValueSerializer
                        ) { FileOptions = FileOptions.None } /* no-write through */
                    );
                TestRecoveryOnExisting(options, 100, ushort.MaxValue);
            }</code><code lang="VB.NET">        Using temp As New TempFile()
            Dim options As var = GetOptions(temp)
            options.MaximumValueNodes = 255
            options.MinimumValueNodes = 100
                ' no-write through 
            options.TransactionLog = New TransactionLog(Of Guid, TestInfo)(New TransactionLogOptions(Of Guid, TestInfo)(options.TransactionLogFileName, options.KeySerializer, options.ValueSerializer) With { _
                Key .FileOptions = FileOptions.None _
            })
            TestRecoveryOnExisting(options, 100, UShort.MaxValue)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.KeyComparer">
            <summary> Defines a custom IComparer&lt;T&gt; to be used for comparing keys </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#171" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBulkInsert.cs#79">BPlusTree/BPlusTree.Test/TestBulkInsert.cs</see></para><code lang="C#">            Dictionary&lt;int, string&gt; test = new Dictionary&lt;int, string&gt;();
            List&lt;IEnumerable&lt;KeyValuePair&lt;int, string&gt;&gt;&gt; sets = 
                new List&lt;IEnumerable&lt;KeyValuePair&lt;int, string&gt;&gt;&gt;(CreateSets(2, 100, test));
            foreach (KeyValuePair&lt;int, string&gt; pair in 
                OrderedKeyValuePairs&lt;int, string&gt;.Merge(Options.KeyComparer, DuplicateHandling.LastValueWins, sets.ToArray()))
            {
                string val;
                Assert.IsTrue(test.TryGetValue(pair.Key, out val));
                Assert.AreEqual(pair.Value, val);
                Assert.IsTrue(test.Remove(pair.Key));
            }

            Assert.AreEqual(0, test.Count);</code><code lang="VB.NET">        Dim test As New Dictionary(Of Integer, String)()
        Dim sets As New List(Of IEnumerable(Of KeyValuePair(Of Integer, String)))(CreateSets(2, 100, test))
        For Each pair As KeyValuePair(Of Integer, String) In OrderedKeyValuePairs(Of Integer, String).Merge(Options.KeyComparer, DuplicateHandling.LastValueWins, sets.ToArray())
            Dim val As String
            Assert.IsTrue(test.TryGetValue(pair.Key, val))
            Assert.AreEqual(pair.Value, val)
            Assert.IsTrue(test.Remove(pair.Key))
        Next

        Assert.AreEqual(0, test.Count)</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.FileVersion">
            <summary>
            Returns the version this option set is compatable with.
            </summary>
        <seealso cref="T:CSharpTest.Net.Collections.FileVersion">FileVersion</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/SampleCustomTypeTest.cs#80">BPlusTree/BPlusTree.Test/SampleCustomTypeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.Options options =
                new BPlusTree&lt;KeyInfo, DataValue&gt;.Options(new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);//we can simply just guess close
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;//obviously this is just for testing
            Assert.AreEqual(FileVersion.Version1, options.FileVersion);

            Random rand = new Random();
            KeyInfo k1 = new KeyInfo(), k2 = new KeyInfo();

            using (BPlusTree&lt;KeyInfo, DataValue&gt; tree = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            {
                byte[] data = new byte[255];

                rand.NextBytes(data);
                tree.Add(k1, new DataValue(k1, data));

                Assert.IsTrue(tree.ContainsKey(k1));
                Assert.IsFalse(tree.ContainsKey(k1.Next()));
                Assert.AreEqual(data, tree[k1].Bytes);

                rand.NextBytes(data);
                tree.Add(k2, new DataValue(k2, data));

                Assert.IsTrue(tree.ContainsKey(k2));
                Assert.IsFalse(tree.ContainsKey(k2.Next()));
                Assert.AreEqual(data, tree[k2].Bytes);
            }
            options.CreateFile = CreatePolicy.Never;
            using (BPlusTree&lt;KeyInfo, DataValue&gt; tree = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            {
                Assert.IsTrue(tree.ContainsKey(k1));
                Assert.IsTrue(tree.ContainsKey(k2));
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).Options(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        'we can simply just guess close
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        'obviously this is just for testing
        Assert.AreEqual(FileVersion.Version1, options.FileVersion)

        Dim rand As New Random()
        Dim k1 As New KeyInfo(), k2 As New KeyInfo()

        Using tree As New BPlusTree(Of KeyInfo, DataValue)(options)
            Dim data As Byte() = New Byte(255) {}

            rand.NextBytes(data)
            tree.Add(k1, New DataValue(k1, data))

            Assert.IsTrue(tree.ContainsKey(k1))
            Assert.IsFalse(tree.ContainsKey(k1.[Next]()))
            Assert.AreEqual(data, tree(k1).Bytes)

            rand.NextBytes(data)
            tree.Add(k2, New DataValue(k2, data))

            Assert.IsTrue(tree.ContainsKey(k2))
            Assert.IsFalse(tree.ContainsKey(k2.[Next]()))
            Assert.AreEqual(data, tree(k2).Bytes)
        End Using
        options.CreateFile = CreatePolicy.Never
        Using tree As New BPlusTree(Of KeyInfo, DataValue)(options)
            Assert.IsTrue(tree.ContainsKey(k1))
            Assert.IsTrue(tree.ContainsKey(k2))
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.StorageType">
            <summary> 
            Can be used to explicitly specify the storage type, or by simply providing a file name this
            will be done for you.  If no file name was specified the default is to use a memory store.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#203" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.StorageType">StorageType</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#259">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            
            const int keysize = 16 + 4;
            const int valuesize = keysize + 256 + 44;

            options.CalcBTreeOrder(keysize, valuesize); 
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;
            options.FileBlockSize = 8192;
            options.StorageType = StorageType.Disk;
            
            options.CacheKeepAliveTimeout = 10000;
            options.CacheKeepAliveMinimumHistory = 0;
            options.CacheKeepAliveMaximumHistory = 200;
            
            options.CallLevelLock = new ReaderWriterLocking();
            options.LockingFactory = new LockFactory&lt;SimpleReadWriteLocking&gt;();
            options.LockTimeout = 10000;

            using(BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using(WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, 1000).Run);

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())

        Const  keysize As Integer = 16 + 4
        Const  valuesize As Integer = keysize + 256 + 44

        options.CalcBTreeOrder(keysize, valuesize)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        options.FileBlockSize = 8192
        options.StorageType = StorageType.Disk

        options.CacheKeepAliveTimeout = 10000
        options.CacheKeepAliveMinimumHistory = 0
        options.CacheKeepAliveMaximumHistory = 200

        options.CallLevelLock = New ReaderWriterLocking()
        options.LockingFactory = New LockFactory(Of SimpleReadWriteLocking)()
        options.LockTimeout = 10000

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, 1000).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.ReadOnly">
            <summary>
            Sets the BTree into a read-only mode (only supported when opening an existing file)
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#217" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#45">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                                  {
                                      CreateFile = CreatePolicy.Always,
                                      FileName = tempFile.TempPath,
                                  }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.CreateFile = CreatePolicy.Never;
                readcopy.ReadOnly = true;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                {
                    using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                    {
                        copy.EnableCount();
                        Assert.AreEqual(0, copy.Count);
                    }

                    //insert some data...
                    tree.AddRange(MakeValues(0, 100));

                    using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                    {
                        copy.EnableCount();
                        Assert.AreEqual(0, copy.Count);
                    }
                    tree.Commit();

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tree.AddRange(MakeValues(1000, 1000));

                    using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                    {
                        copy.EnableCount();
                        Assert.AreEqual(100, copy.Count);
                        Assert.AreEqual(0, copy.First().Key);
                        Assert.AreEqual(99, copy.Last().Key);
                    }

                    tree.Commit();

                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                Key .CreateFile = CreatePolicy.Always, _
                Key .FileName = tempFile.TempPath _
            }.CalcBTreeOrder(4, 10)

            Dim readcopy As var = options.Clone()
            readcopy.CreateFile = CreatePolicy.Never
            readcopy.[ReadOnly] = True

            Using tree As var = New BPlusTree(Of Integer, String)(options)
                Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                    copy.EnableCount()
                    Assert.AreEqual(0, copy.Count)
                End Using

                'insert some data...
                tree.AddRange(MakeValues(0, 100))

                Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                    copy.EnableCount()
                    Assert.AreEqual(0, copy.Count)
                End Using
                tree.Commit()

                'insert some data...
                Dim i As Integer = 0
                While i &lt; 100
                    tree.Remove(i)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While
                tree.AddRange(MakeValues(1000, 1000))

                Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                    copy.EnableCount()
                    Assert.AreEqual(100, copy.Count)
                    Assert.AreEqual(0, copy.First().Key)
                    Assert.AreEqual(99, copy.Last().Key)
                End Using


                tree.Commit()
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.StorageSystem">
            <summary>
            Sets the custom implementation of the storage back-end to use for the BTree
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#233" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.INodeStorage">INodeStorage</seealso></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.FileName">
            <summary>
            Gets or sets the FileName that should be used to store the BTree
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#242" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs#32">BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs</see></para><code lang="C#">            mreStop.Reset();
            using(TempFile temp = new TempFile())
            {
                BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2 options = new BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2(
                    PrimitiveSerializer.Guid, new TestInfoSerializer());
                options.CalcBTreeOrder(16, 24);
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                using (BPlusTree&lt;Guid, TestInfo&gt; tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    var actions = new List&lt;IAsyncResult&gt;();
                    var tests = new Action&lt;BPlusTree&lt;Guid, TestInfo&gt;&gt;[] 
                    {
                        DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts,
                        FetchStuff, FetchStuff, FetchStuff, FetchStuff, FetchStuff
                    };

                    foreach (var t in tests)
                        actions.Add(t.BeginInvoke(tree, null, null));

                    do
                    {
                        Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                        Thread.Sleep(1000);
                    } while (Debugger.IsAttached);

                    mreStop.Set();
                    for (int i = 0; i &lt; actions.Count; i++)
                    {
                        tests[i].EndInvoke(actions[i]);
                    }

                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                }
            }</code><code lang="VB.NET">        mreStop.Reset()
        Using temp As New TempFile()
            Dim options As New BPlusTree(Of Guid, TestInfo).OptionsV2(PrimitiveSerializer.Guid, New TestInfoSerializer())
            options.CalcBTreeOrder(16, 24)
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            Using tree As New BPlusTree(Of Guid, TestInfo)(options)
                tree.EnableCount()
                Dim actions As var = New List(Of IAsyncResult)()
                Dim tests As var = New Action(Of BPlusTree(Of Guid, TestInfo))() {DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts, FetchStuff, _
                    FetchStuff, FetchStuff, FetchStuff, FetchStuff}

                For Each t As var In tests
                    actions.Add(t.BeginInvoke(tree, Nothing, Nothing))
                Next

                Do
                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
                    Thread.Sleep(1000)
                Loop While Debugger.IsAttached

                mreStop.[Set]()
                Dim i As Integer = 0
                While i &lt; actions.Count
                    tests(i).EndInvoke(actions(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.CreateFile">
            <summary>
            Gets or sets the file-create policy used when backing with a file storage
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#258" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.CreatePolicy">CreatePolicy</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs#32">BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs</see></para><code lang="C#">            mreStop.Reset();
            using(TempFile temp = new TempFile())
            {
                BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2 options = new BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2(
                    PrimitiveSerializer.Guid, new TestInfoSerializer());
                options.CalcBTreeOrder(16, 24);
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                using (BPlusTree&lt;Guid, TestInfo&gt; tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    var actions = new List&lt;IAsyncResult&gt;();
                    var tests = new Action&lt;BPlusTree&lt;Guid, TestInfo&gt;&gt;[] 
                    {
                        DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts,
                        FetchStuff, FetchStuff, FetchStuff, FetchStuff, FetchStuff
                    };

                    foreach (var t in tests)
                        actions.Add(t.BeginInvoke(tree, null, null));

                    do
                    {
                        Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                        Thread.Sleep(1000);
                    } while (Debugger.IsAttached);

                    mreStop.Set();
                    for (int i = 0; i &lt; actions.Count; i++)
                    {
                        tests[i].EndInvoke(actions[i]);
                    }

                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                }
            }</code><code lang="VB.NET">        mreStop.Reset()
        Using temp As New TempFile()
            Dim options As New BPlusTree(Of Guid, TestInfo).OptionsV2(PrimitiveSerializer.Guid, New TestInfoSerializer())
            options.CalcBTreeOrder(16, 24)
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            Using tree As New BPlusTree(Of Guid, TestInfo)(options)
                tree.EnableCount()
                Dim actions As var = New List(Of IAsyncResult)()
                Dim tests As var = New Action(Of BPlusTree(Of Guid, TestInfo))() {DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts, FetchStuff, _
                    FetchStuff, FetchStuff, FetchStuff, FetchStuff}

                For Each t As var In tests
                    actions.Add(t.BeginInvoke(tree, Nothing, Nothing))
                Next

                Do
                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
                    Thread.Sleep(1000)
                Loop While Debugger.IsAttached

                mreStop.[Set]()
                Dim i As Integer = 0
                While i &lt; actions.Count
                    tests(i).EndInvoke(actions(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.FileBlockSize">
            <summary>
            Gets or sets the number of bytes per file-block used in the file storage
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#270" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#259">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            
            const int keysize = 16 + 4;
            const int valuesize = keysize + 256 + 44;

            options.CalcBTreeOrder(keysize, valuesize); 
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;
            options.FileBlockSize = 8192;
            options.StorageType = StorageType.Disk;
            
            options.CacheKeepAliveTimeout = 10000;
            options.CacheKeepAliveMinimumHistory = 0;
            options.CacheKeepAliveMaximumHistory = 200;
            
            options.CallLevelLock = new ReaderWriterLocking();
            options.LockingFactory = new LockFactory&lt;SimpleReadWriteLocking&gt;();
            options.LockTimeout = 10000;

            using(BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using(WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, 1000).Run);

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())

        Const  keysize As Integer = 16 + 4
        Const  valuesize As Integer = keysize + 256 + 44

        options.CalcBTreeOrder(keysize, valuesize)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        options.FileBlockSize = 8192
        options.StorageType = StorageType.Disk

        options.CacheKeepAliveTimeout = 10000
        options.CacheKeepAliveMinimumHistory = 0
        options.CacheKeepAliveMaximumHistory = 200

        options.CallLevelLock = New ReaderWriterLocking()
        options.LockingFactory = New LockFactory(Of SimpleReadWriteLocking)()
        options.LockTimeout = 10000

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, 1000).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.LockTimeout">
            <summary>
            Gets or sets the number of milliseconds to wait before failing a lock request, the default
            of two minutes should be more than adequate.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#283" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#259">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            
            const int keysize = 16 + 4;
            const int valuesize = keysize + 256 + 44;

            options.CalcBTreeOrder(keysize, valuesize); 
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;
            options.FileBlockSize = 8192;
            options.StorageType = StorageType.Disk;
            
            options.CacheKeepAliveTimeout = 10000;
            options.CacheKeepAliveMinimumHistory = 0;
            options.CacheKeepAliveMaximumHistory = 200;
            
            options.CallLevelLock = new ReaderWriterLocking();
            options.LockingFactory = new LockFactory&lt;SimpleReadWriteLocking&gt;();
            options.LockTimeout = 10000;

            using(BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using(WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, 1000).Run);

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())

        Const  keysize As Integer = 16 + 4
        Const  valuesize As Integer = keysize + 256 + 44

        options.CalcBTreeOrder(keysize, valuesize)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        options.FileBlockSize = 8192
        options.StorageType = StorageType.Disk

        options.CacheKeepAliveTimeout = 10000
        options.CacheKeepAliveMinimumHistory = 0
        options.CacheKeepAliveMaximumHistory = 200

        options.CallLevelLock = New ReaderWriterLocking()
        options.LockingFactory = New LockFactory(Of SimpleReadWriteLocking)()
        options.LockTimeout = 10000

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, 1000).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.LockingFactory">
            <summary>
            Gets or sets the locking factory to use for accessing shared data. The default is WriterOnlyLocking() 
            which does not perform read locks, rather it will rely on the cache of the btree and may preform dirty
            reads.  You can use any implementation of ILockFactory; however, the SimpleReadWriteLocking seems to 
            perform the most efficiently for both reader/writer locks.  Additionally wrapping that instance in a
            ReserveredWriterLocking() instance will allow reads to continue up until a writer begins the commit
            process.  If you are only accessing the BTree instance from a single thread this can be set to 
            IgnoreLocking. Be careful of using ReaderWriterLocking as the write-intesive nature of the BTree will 
            suffer extreme performance penalties with this lock.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#301" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><seealso cref="T:CSharpTest.Net.Synchronization.ILockFactory">ILockFactory</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#259">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            
            const int keysize = 16 + 4;
            const int valuesize = keysize + 256 + 44;

            options.CalcBTreeOrder(keysize, valuesize); 
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;
            options.FileBlockSize = 8192;
            options.StorageType = StorageType.Disk;
            
            options.CacheKeepAliveTimeout = 10000;
            options.CacheKeepAliveMinimumHistory = 0;
            options.CacheKeepAliveMaximumHistory = 200;
            
            options.CallLevelLock = new ReaderWriterLocking();
            options.LockingFactory = new LockFactory&lt;SimpleReadWriteLocking&gt;();
            options.LockTimeout = 10000;

            using(BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using(WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, 1000).Run);

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())

        Const  keysize As Integer = 16 + 4
        Const  valuesize As Integer = keysize + 256 + 44

        options.CalcBTreeOrder(keysize, valuesize)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        options.FileBlockSize = 8192
        options.StorageType = StorageType.Disk

        options.CacheKeepAliveTimeout = 10000
        options.CacheKeepAliveMinimumHistory = 0
        options.CacheKeepAliveMaximumHistory = 200

        options.CallLevelLock = New ReaderWriterLocking()
        options.LockingFactory = New LockFactory(Of SimpleReadWriteLocking)()
        options.LockTimeout = 10000

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, 1000).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.CallLevelLock">
            <summary>
            Defines a reader/writer lock that used to control exclusive tree access when needed.  The public
            methods for EnableCount(), Clear(), and UnloadCache() each acquire an exclusive (write) lock while
            all other public methods acquire a shared (read) lock.  By default this lock is non-operational
            (an instance of IgnoreLocking) so if you need the above methods to work while multiple threads are
            accessing the tree, or if you exclusive access to the tree, specify a lock instance.  Since this
            lock is primarily a read-heavy lock consider using the ReaderWriterLocking or SimpleReadWriteLocking.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#314" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><seealso cref="T:CSharpTest.Net.Synchronization.ILockStrategy">ILockStrategy</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#259">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            
            const int keysize = 16 + 4;
            const int valuesize = keysize + 256 + 44;

            options.CalcBTreeOrder(keysize, valuesize); 
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;
            options.FileBlockSize = 8192;
            options.StorageType = StorageType.Disk;
            
            options.CacheKeepAliveTimeout = 10000;
            options.CacheKeepAliveMinimumHistory = 0;
            options.CacheKeepAliveMaximumHistory = 200;
            
            options.CallLevelLock = new ReaderWriterLocking();
            options.LockingFactory = new LockFactory&lt;SimpleReadWriteLocking&gt;();
            options.LockTimeout = 10000;

            using(BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using(WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, 1000).Run);

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())

        Const  keysize As Integer = 16 + 4
        Const  valuesize As Integer = keysize + 256 + 44

        options.CalcBTreeOrder(keysize, valuesize)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        options.FileBlockSize = 8192
        options.StorageType = StorageType.Disk

        options.CacheKeepAliveTimeout = 10000
        options.CacheKeepAliveMinimumHistory = 0
        options.CacheKeepAliveMaximumHistory = 200

        options.CallLevelLock = New ReaderWriterLocking()
        options.LockingFactory = New LockFactory(Of SimpleReadWriteLocking)()
        options.LockTimeout = 10000

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, 1000).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.BTreeOrder">
            <summary>
            A quick means of setting all the min/max values for the node counts using this value as a basis
            for the Maximum fields and one-quarter of this value for Minimum fields provided the result is in
            range.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#324" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestFileSerialized.cs#56">BPlusTree/BPlusTree.Test/TestFileSerialized.cs</see></para><code lang="C#">            BPlusTree&lt;int, string&gt;.Options options = (BPlusTree&lt;int, string&gt;.Options)Options;
            options.BTreeOrder = 4;
            options.FileBlockSize = 512;
            options.FileGrowthRate = 25;
            options.ConcurrentWriters = 4;
            options.FileOpenOptions = FileOptions.None;

            using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
            {
                for(int i=0; i &lt; 100; i++)
                    Assert.IsTrue(tree.TryAdd(i, i.ToString()));
            }

            using (Stream io = TempFile.Open())
            {
                //first we can corrupt the root node, which is always at an offset of BlockSize
                io.Seek(512, SeekOrigin.Begin);
                io.Write(new byte[512], 0, 512);

                //Now let's corrupt one byte from the end of the node at index 3
                io.Seek(1024 + 16, SeekOrigin.Begin);
                int len = PrimitiveSerializer.Int32.ReadFrom(io);
                io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin);//secrets of fragmented file revealed... ugly i know.
                io.WriteByte(255); //overwrite last used byte in chunk.
            }

            options.CreateFile = CreatePolicy.Never;

            //Now that we've corrupted part of the file content, let's take a peek
            try
            {
                using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
                {
                    foreach (KeyValuePair&lt;int, string&gt; kv in tree)
                        Assert.AreEqual(kv.Key.ToString(), kv.Value);
                }
                Assert.Fail("Expected InvalidDataException");
            }
            catch (InvalidDataException)
            { }

            Dictionary&lt;int, string&gt; found = new Dictionary&lt;int, string&gt;();
            List&lt;int&gt; duplicates = new List&lt;int&gt;();
            foreach (KeyValuePair&lt;int, string&gt; kv in BPlusTree&lt;int, string&gt;.RecoveryScan(options, FileShare.None))
            {
                if (!found.ContainsKey(kv.Key))
                    found.Add(kv.Key, kv.Value);
                else
                    duplicates.Add(kv.Key);
                
                Assert.AreEqual(kv.Key.ToString(), kv.Value);
            }
            Assert.AreNotEqual(0, found.Count);

            //The following may change...
            Assert.AreEqual(99, found.Count);
            Assert.IsFalse(found.ContainsKey(3), "should be missing #3");
            Assert.AreEqual(0, duplicates.Count);</code><code lang="VB.NET">        Dim options As BPlusTree(Of Integer, String).Options = DirectCast(Options, BPlusTree(Of Integer, String).Options)
        options.BTreeOrder = 4
        options.FileBlockSize = 512
        options.FileGrowthRate = 25
        options.ConcurrentWriters = 4
        options.FileOpenOptions = FileOptions.None

        Using tree As New BPlusTree(Of Integer, String)(options)
            Dim i As Integer = 0
            While i &lt; 100
                Assert.IsTrue(tree.TryAdd(i, i.ToString()))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
        End Using

        Using io As Stream = TempFile.Open()
            'first we can corrupt the root node, which is always at an offset of BlockSize
            io.Seek(512, SeekOrigin.Begin)
            io.Write(New Byte(512) {}, 0, 512)

            'Now let's corrupt one byte from the end of the node at index 3
            io.Seek(1024 + 16, SeekOrigin.Begin)
            Dim len As Integer = PrimitiveSerializer.Int32.ReadFrom(io)
            io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin)
            'secrets of fragmented file revealed... ugly i know.
                'overwrite last used byte in chunk.
            io.WriteByte(255)
        End Using

        options.CreateFile = CreatePolicy.Never

        'Now that we've corrupted part of the file content, let's take a peek
        Try
            Using tree As New BPlusTree(Of Integer, String)(options)
                For Each kv As KeyValuePair(Of Integer, String) In tree
                    Assert.AreEqual(kv.Key.ToString(), kv.Value)
                Next
            End Using
            Assert.Fail("Expected InvalidDataException")
        Catch generatedExceptionName As InvalidDataException
        End Try

        Dim found As New Dictionary(Of Integer, String)()
        Dim duplicates As New List(Of Integer)()
        For Each kv As KeyValuePair(Of Integer, String) In BPlusTree(Of Integer, String).RecoveryScan(options, FileShare.None)
            If Not found.ContainsKey(kv.Key) Then
                found.Add(kv.Key, kv.Value)
            Else
                duplicates.Add(kv.Key)
            End If

            Assert.AreEqual(kv.Key.ToString(), kv.Value)
        Next
        Assert.AreNotEqual(0, found.Count)

        'The following may change...
        Assert.AreEqual(99, found.Count)
        Assert.IsFalse(found.ContainsKey(3), "should be missing #3")
        Assert.AreEqual(0, duplicates.Count)</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.MinimumChildNodes">
            <summary>
            The smallest number of child nodes that should be linked to before refactoring the tree to remove
            this node.  In a 'normal' and/or purest B+Tree this is always half of max; however for performance
            reasons this B+Tree allow any value equal to or less than half of max but at least 2.
            </summary>
            <value>A number in the range of 2 to 128 that is at most half of MaximumChildNodes.</value>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#340" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBulkInsert.cs#111">BPlusTree/BPlusTree.Test/TestBulkInsert.cs</see></para><code lang="C#">            BPlusTreeOptions&lt;int, string&gt; options = Options;
            using (TempFile temp = new TempFile())
            {
                options = Options;
                temp.Delete();
                //options.CreateFile = CreatePolicy.Always;
                //options.FileName = temp.TempPath;
                options.MaximumValueNodes = 14;
                options.MinimumValueNodes = 7;
                options.MaximumChildNodes = 6;
                options.MinimumChildNodes = 2;

                // Just to make sure we don't break some fencepost condition in the future
                for (int i = 0; i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1; i++)
                    TestMergeSequenceInFile(options.Clone(), i);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1);
            }</code><code lang="VB.NET">        Dim options As BPlusTreeOptions(Of Integer, String) = Options
        Using temp As New TempFile()
            options = Options
            temp.Delete()
            'options.CreateFile = CreatePolicy.Always;
            'options.FileName = temp.TempPath;
            options.MaximumValueNodes = 14
            options.MinimumValueNodes = 7
            options.MaximumChildNodes = 6
            options.MinimumChildNodes = 2

            ' Just to make sure we don't break some fencepost condition in the future
            Dim i As Integer = 0
            While i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1
                TestMergeSequenceInFile(options.Clone(), i)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes)
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.MaximumChildNodes">
            <summary>
            The largest number of child nodes that should be linked to before refactoring the tree to split
            this node into two.  This property has a side-effect on MinimumChildNodes to ensure that it continues
            to be at most half of MaximumChildNodes.
            </summary>
            <value>A number in the range of 4 to 256.</value>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#356" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBulkInsert.cs#111">BPlusTree/BPlusTree.Test/TestBulkInsert.cs</see></para><code lang="C#">            BPlusTreeOptions&lt;int, string&gt; options = Options;
            using (TempFile temp = new TempFile())
            {
                options = Options;
                temp.Delete();
                //options.CreateFile = CreatePolicy.Always;
                //options.FileName = temp.TempPath;
                options.MaximumValueNodes = 14;
                options.MinimumValueNodes = 7;
                options.MaximumChildNodes = 6;
                options.MinimumChildNodes = 2;

                // Just to make sure we don't break some fencepost condition in the future
                for (int i = 0; i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1; i++)
                    TestMergeSequenceInFile(options.Clone(), i);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1);
            }</code><code lang="VB.NET">        Dim options As BPlusTreeOptions(Of Integer, String) = Options
        Using temp As New TempFile()
            options = Options
            temp.Delete()
            'options.CreateFile = CreatePolicy.Always;
            'options.FileName = temp.TempPath;
            options.MaximumValueNodes = 14
            options.MinimumValueNodes = 7
            options.MaximumChildNodes = 6
            options.MinimumChildNodes = 2

            ' Just to make sure we don't break some fencepost condition in the future
            Dim i As Integer = 0
            While i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1
                TestMergeSequenceInFile(options.Clone(), i)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes)
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.MinimumValueNodes">
            <summary>
            The smallest number of values that should be contained in this node before refactoring the tree to remove
            this node.  In a 'normal' and/or purest B+Tree this is always half of max; however for performance
            reasons this B+Tree allow any value equal to or less than half of max but at least 2.
            </summary>
            <value>A number in the range of 2 to 128 that is at most half of MaximumValueNodes.</value>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#373" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBulkInsert.cs#111">BPlusTree/BPlusTree.Test/TestBulkInsert.cs</see></para><code lang="C#">            BPlusTreeOptions&lt;int, string&gt; options = Options;
            using (TempFile temp = new TempFile())
            {
                options = Options;
                temp.Delete();
                //options.CreateFile = CreatePolicy.Always;
                //options.FileName = temp.TempPath;
                options.MaximumValueNodes = 14;
                options.MinimumValueNodes = 7;
                options.MaximumChildNodes = 6;
                options.MinimumChildNodes = 2;

                // Just to make sure we don't break some fencepost condition in the future
                for (int i = 0; i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1; i++)
                    TestMergeSequenceInFile(options.Clone(), i);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1);
            }</code><code lang="VB.NET">        Dim options As BPlusTreeOptions(Of Integer, String) = Options
        Using temp As New TempFile()
            options = Options
            temp.Delete()
            'options.CreateFile = CreatePolicy.Always;
            'options.FileName = temp.TempPath;
            options.MaximumValueNodes = 14
            options.MinimumValueNodes = 7
            options.MaximumChildNodes = 6
            options.MinimumChildNodes = 2

            ' Just to make sure we don't break some fencepost condition in the future
            Dim i As Integer = 0
            While i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1
                TestMergeSequenceInFile(options.Clone(), i)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes)
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.MaximumValueNodes">
            <summary>
            The largest number of values that should be contained in this node before refactoring the tree to split
            this node into two.  This property has a side-effect on MinimumValueNodes to ensure that it continues
            to be at most half of MaximumValueNodes.
            </summary>
            <value>A number in the range of 4 to 256.</value>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#389" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBulkInsert.cs#111">BPlusTree/BPlusTree.Test/TestBulkInsert.cs</see></para><code lang="C#">            BPlusTreeOptions&lt;int, string&gt; options = Options;
            using (TempFile temp = new TempFile())
            {
                options = Options;
                temp.Delete();
                //options.CreateFile = CreatePolicy.Always;
                //options.FileName = temp.TempPath;
                options.MaximumValueNodes = 14;
                options.MinimumValueNodes = 7;
                options.MaximumChildNodes = 6;
                options.MinimumChildNodes = 2;

                // Just to make sure we don't break some fencepost condition in the future
                for (int i = 0; i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1; i++)
                    TestMergeSequenceInFile(options.Clone(), i);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes);
                TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1);
            }</code><code lang="VB.NET">        Dim options As BPlusTreeOptions(Of Integer, String) = Options
        Using temp As New TempFile()
            options = Options
            temp.Delete()
            'options.CreateFile = CreatePolicy.Always;
            'options.FileName = temp.TempPath;
            options.MaximumValueNodes = 14
            options.MinimumValueNodes = 7
            options.MaximumChildNodes = 6
            options.MinimumChildNodes = 2

            ' Just to make sure we don't break some fencepost condition in the future
            Dim i As Integer = 0
            While i &lt;= (options.MaximumValueNodes * options.MaximumChildNodes) + 1
                TestMergeSequenceInFile(options.Clone(), i)
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes)
            TestMergeSequenceInFile(options.Clone(), options.MaximumValueNodes * options.MaximumChildNodes * options.MaximumChildNodes + 1)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.CachePolicy">
            <summary>
            Determines how long loaded nodes stay in memory, Full keeps all loaded nodes alive and is the
            most efficient, The default Recent keeps recently visited nodes alive based on the CacheKeepAlive
            properties, and None does not cache the nodes at all but does maintain a cache of locks for 
            each node visited.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#406" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.CachePolicy">CachePolicy</seealso></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.CacheKeepAliveMinimumHistory">
            <summary> 
            Determins minimum number of recently visited nodes to keep alive in memory.  This number defines
            the history size, not the number of distinct nodes.  This number will always be kept reguardless
            of the timeout.  Specify a value of 0 to allow the timeout to empty the cache.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#420" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#259">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            
            const int keysize = 16 + 4;
            const int valuesize = keysize + 256 + 44;

            options.CalcBTreeOrder(keysize, valuesize); 
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;
            options.FileBlockSize = 8192;
            options.StorageType = StorageType.Disk;
            
            options.CacheKeepAliveTimeout = 10000;
            options.CacheKeepAliveMinimumHistory = 0;
            options.CacheKeepAliveMaximumHistory = 200;
            
            options.CallLevelLock = new ReaderWriterLocking();
            options.LockingFactory = new LockFactory&lt;SimpleReadWriteLocking&gt;();
            options.LockTimeout = 10000;

            using(BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using(WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, 1000).Run);

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())

        Const  keysize As Integer = 16 + 4
        Const  valuesize As Integer = keysize + 256 + 44

        options.CalcBTreeOrder(keysize, valuesize)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        options.FileBlockSize = 8192
        options.StorageType = StorageType.Disk

        options.CacheKeepAliveTimeout = 10000
        options.CacheKeepAliveMinimumHistory = 0
        options.CacheKeepAliveMaximumHistory = 200

        options.CallLevelLock = New ReaderWriterLocking()
        options.LockingFactory = New LockFactory(Of SimpleReadWriteLocking)()
        options.LockTimeout = 10000

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, 1000).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.CacheKeepAliveMaximumHistory">
            <summary> 
            Determins maximum number of recently visited nodes to keep alive in memory.  This number defines
            the history size, not the number of distinct nodes.  The ceiling is always respected reguardless
            of the timeout.  Specify a value of 0 to disable history keep alive.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#435" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#259">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            
            const int keysize = 16 + 4;
            const int valuesize = keysize + 256 + 44;

            options.CalcBTreeOrder(keysize, valuesize); 
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;
            options.FileBlockSize = 8192;
            options.StorageType = StorageType.Disk;
            
            options.CacheKeepAliveTimeout = 10000;
            options.CacheKeepAliveMinimumHistory = 0;
            options.CacheKeepAliveMaximumHistory = 200;
            
            options.CallLevelLock = new ReaderWriterLocking();
            options.LockingFactory = new LockFactory&lt;SimpleReadWriteLocking&gt;();
            options.LockTimeout = 10000;

            using(BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using(WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, 1000).Run);

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())

        Const  keysize As Integer = 16 + 4
        Const  valuesize As Integer = keysize + 256 + 44

        options.CalcBTreeOrder(keysize, valuesize)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        options.FileBlockSize = 8192
        options.StorageType = StorageType.Disk

        options.CacheKeepAliveTimeout = 10000
        options.CacheKeepAliveMinimumHistory = 0
        options.CacheKeepAliveMaximumHistory = 200

        options.CallLevelLock = New ReaderWriterLocking()
        options.LockingFactory = New LockFactory(Of SimpleReadWriteLocking)()
        options.LockTimeout = 10000

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, 1000).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.CacheKeepAliveTimeout">
            <summary>
            If the cache contains more that CacheKeepAliveMinimumHistory items, this timeout will start to
            remove those items until the cache history is reduced to CacheKeepAliveMinimumHistory.  It is 
            important to know that the BPlusTree itself contains no theads and this timeout will not be 
            respected if cache is not in use.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.OptionsBase.cs#451" cat="Source Code">BPlusTree/Collections/BPlusTree.OptionsBase.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#259">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            
            const int keysize = 16 + 4;
            const int valuesize = keysize + 256 + 44;

            options.CalcBTreeOrder(keysize, valuesize); 
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;
            options.FileBlockSize = 8192;
            options.StorageType = StorageType.Disk;
            
            options.CacheKeepAliveTimeout = 10000;
            options.CacheKeepAliveMinimumHistory = 0;
            options.CacheKeepAliveMaximumHistory = 200;
            
            options.CallLevelLock = new ReaderWriterLocking();
            options.LockingFactory = new LockFactory&lt;SimpleReadWriteLocking&gt;();
            options.LockTimeout = 10000;

            using(BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using(WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, 1000).Run);

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())

        Const  keysize As Integer = 16 + 4
        Const  valuesize As Integer = keysize + 256 + 44

        options.CalcBTreeOrder(keysize, valuesize)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        options.FileBlockSize = 8192
        options.StorageType = StorageType.Disk

        options.CacheKeepAliveTimeout = 10000
        options.CacheKeepAliveMinimumHistory = 0
        options.CacheKeepAliveMaximumHistory = 200

        options.CallLevelLock = New ReaderWriterLocking()
        options.LockingFactory = New LockFactory(Of SimpleReadWriteLocking)()
        options.LockTimeout = 10000

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, 1000).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.FillChildNodes">
            <summary> The desired fill-size of node that contain children </summary>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.FillValueNodes">
            <summary> The desired fill-size of node that contain values </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.#ctor(CSharpTest.Net.Serialization.ISerializer{`0},CSharpTest.Net.Serialization.ISerializer{`1})">
            <summary>
            Constructs the options configuration to initialize a BPlusTree instance using the default Comparer for TKey
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#41" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs#32">BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs</see></para><code lang="C#">            mreStop.Reset();
            using(TempFile temp = new TempFile())
            {
                BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2 options = new BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2(
                    PrimitiveSerializer.Guid, new TestInfoSerializer());
                options.CalcBTreeOrder(16, 24);
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                using (BPlusTree&lt;Guid, TestInfo&gt; tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    var actions = new List&lt;IAsyncResult&gt;();
                    var tests = new Action&lt;BPlusTree&lt;Guid, TestInfo&gt;&gt;[] 
                    {
                        DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts,
                        FetchStuff, FetchStuff, FetchStuff, FetchStuff, FetchStuff
                    };

                    foreach (var t in tests)
                        actions.Add(t.BeginInvoke(tree, null, null));

                    do
                    {
                        Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                        Thread.Sleep(1000);
                    } while (Debugger.IsAttached);

                    mreStop.Set();
                    for (int i = 0; i &lt; actions.Count; i++)
                    {
                        tests[i].EndInvoke(actions[i]);
                    }

                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                }
            }</code><code lang="VB.NET">        mreStop.Reset()
        Using temp As New TempFile()
            Dim options As New BPlusTree(Of Guid, TestInfo).OptionsV2(PrimitiveSerializer.Guid, New TestInfoSerializer())
            options.CalcBTreeOrder(16, 24)
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            Using tree As New BPlusTree(Of Guid, TestInfo)(options)
                tree.EnableCount()
                Dim actions As var = New List(Of IAsyncResult)()
                Dim tests As var = New Action(Of BPlusTree(Of Guid, TestInfo))() {DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts, FetchStuff, _
                    FetchStuff, FetchStuff, FetchStuff, FetchStuff}

                For Each t As var In tests
                    actions.Add(t.BeginInvoke(tree, Nothing, Nothing))
                Next

                Do
                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
                    Thread.Sleep(1000)
                Loop While Debugger.IsAttached

                mreStop.[Set]()
                Dim i As Integer = 0
                While i &lt; actions.Count
                    tests(i).EndInvoke(actions(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.#ctor(CSharpTest.Net.Serialization.ISerializer{`0},CSharpTest.Net.Serialization.ISerializer{`1},System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructs the options configuration to initialize a BPlusTree instance
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#35" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#259">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2 options = new BPlusTree&lt;KeyInfo, DataValue&gt;.OptionsV2(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            
            const int keysize = 16 + 4;
            const int valuesize = keysize + 256 + 44;

            options.CalcBTreeOrder(keysize, valuesize); 
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;
            options.FileBlockSize = 8192;
            options.StorageType = StorageType.Disk;
            
            options.CacheKeepAliveTimeout = 10000;
            options.CacheKeepAliveMinimumHistory = 0;
            options.CacheKeepAliveMaximumHistory = 200;
            
            options.CallLevelLock = new ReaderWriterLocking();
            options.LockingFactory = new LockFactory&lt;SimpleReadWriteLocking&gt;();
            options.LockTimeout = 10000;

            using(BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            using(WorkQueue work = new WorkQueue(Environment.ProcessorCount))
            {
                Exception lastError = null;
                work.OnError += delegate(object o, ErrorEventArgs e) { lastError = e.GetException(); };

                for (int i = 0; i &lt; Environment.ProcessorCount; i++)
                    work.Enqueue(new ThreadedTest(dictionary, 1000).Run);

                Assert.IsTrue(work.Complete(true, 60000));
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError);
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).OptionsV2(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())

        Const  keysize As Integer = 16 + 4
        Const  valuesize As Integer = keysize + 256 + 44

        options.CalcBTreeOrder(keysize, valuesize)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        options.FileBlockSize = 8192
        options.StorageType = StorageType.Disk

        options.CacheKeepAliveTimeout = 10000
        options.CacheKeepAliveMinimumHistory = 0
        options.CacheKeepAliveMaximumHistory = 200

        options.CallLevelLock = New ReaderWriterLocking()
        options.LockingFactory = New LockFactory(Of SimpleReadWriteLocking)()
        options.LockTimeout = 10000

        Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
            Using work As New WorkQueue(Environment.ProcessorCount)
                Dim lastError As Exception = Nothing
                work.OnError += Function(o As Object, e As ErrorEventArgs) Do
                    lastError = e.GetException()
                End Function

                Dim i As Integer = 0
                While i &lt; Environment.ProcessorCount
                    work.Enqueue(New ThreadedTest(dictionary, 1000).Run)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Assert.IsTrue(work.Complete(True, 60000))
                Assert.IsNull(lastError, "Exception raised in worker: {0}", lastError)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.Clone">
            <summary>
            Creates a shallow clone of the configuration options.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#56" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CalcBTreeOrder(System.Int32,System.Int32)">
            <summary>
            Calculates default node-thresholds based upon the average number of bytes in key and value
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#145" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs#32">BPlusTree/BPlusTree.Test/ThreadedMassInsertTest.cs</see></para><code lang="C#">            mreStop.Reset();
            using(TempFile temp = new TempFile())
            {
                BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2 options = new BPlusTree&lt;Guid, TestInfo&gt;.OptionsV2(
                    PrimitiveSerializer.Guid, new TestInfoSerializer());
                options.CalcBTreeOrder(16, 24);
                options.CreateFile = CreatePolicy.Always;
                options.FileName = temp.TempPath;
                using (BPlusTree&lt;Guid, TestInfo&gt; tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    var actions = new List&lt;IAsyncResult&gt;();
                    var tests = new Action&lt;BPlusTree&lt;Guid, TestInfo&gt;&gt;[] 
                    {
                        DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts,
                        FetchStuff, FetchStuff, FetchStuff, FetchStuff, FetchStuff
                    };

                    foreach (var t in tests)
                        actions.Add(t.BeginInvoke(tree, null, null));

                    do
                    {
                        Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                        Thread.Sleep(1000);
                    } while (Debugger.IsAttached);

                    mreStop.Set();
                    for (int i = 0; i &lt; actions.Count; i++)
                    {
                        tests[i].EndInvoke(actions[i]);
                    }

                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count);
                }
            }</code><code lang="VB.NET">        mreStop.Reset()
        Using temp As New TempFile()
            Dim options As New BPlusTree(Of Guid, TestInfo).OptionsV2(PrimitiveSerializer.Guid, New TestInfoSerializer())
            options.CalcBTreeOrder(16, 24)
            options.CreateFile = CreatePolicy.Always
            options.FileName = temp.TempPath
            Using tree As New BPlusTree(Of Guid, TestInfo)(options)
                tree.EnableCount()
                Dim actions As var = New List(Of IAsyncResult)()
                Dim tests As var = New Action(Of BPlusTree(Of Guid, TestInfo))() {DeleteStuff, UpdateStuff, AddStuff, AddRanges, BulkyInserts, FetchStuff, _
                    FetchStuff, FetchStuff, FetchStuff, FetchStuff}

                For Each t As var In tests
                    actions.Add(t.BeginInvoke(tree, Nothing, Nothing))
                Next

                Do
                    Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
                    Thread.Sleep(1000)
                Loop While Debugger.IsAttached

                mreStop.[Set]()
                Dim i As Integer = 0
                While i &lt; actions.Count
                    tests(i).EndInvoke(actions(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Trace.TraceInformation("Dictionary.Count = {0}", tree.Count)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CalculateOrder(System.Int32,System.Int32)">
            <summary>
            Calculates default node-thresholds based upon the average number of bytes in key and value
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CreateStorage">
            <summary> Used to create the correct storage type </summary>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CallLevelLock">
            <summary>
            Defines a reader/writer lock that used to control exclusive tree access when needed.  
            Version2 files using trasacation logs will use this to gain exclusive access to the tree
            during calls to Commit, Rollback, etc.  The default is to use a SimpleReadWriteLocking
            class.  If you are accessing the tree from a single thread, consider using the IgnoreLocking
            class for better performance.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#73" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Synchronization.ILockStrategy">ILockStrategy</seealso></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.FileVersion">
            <summary>
            Returns the version this option set is compatible with.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#81" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.FileVersion">FileVersion</seealso></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.StoragePerformance">
            <summary>
            Returns the DurabilityProtection of the underlying storage to create.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#89" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.StoragePerformance">StoragePerformance</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.TransactionLogFileName">
            <summary>
            Gets or sets a filename to write binary log files to.
            </summary>
            <remarks> 
            This is just a short-hand way of setting the TransactionLog instance.  For better performance
            at the risk of loosing a record or two, consider creating the TransactionLog instance with the
            FileOptions set to (FileOptions.WriteThrough | FileOptions.Asynchronous).
            </remarks>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#102" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.TransactionLog">
            <summary>
            Gets or sets an implementation of ITransactionLog&lt;TKey, TValue&gt; used to log writes to this
            tree for recovery and/or monitoring.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#118" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.ITransactionLog{`0,`1}">ITransactionLog&lt;TKey,TValue&gt;</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBackupAndRecovery.cs#199">BPlusTree/BPlusTree.Test/TestBackupAndRecovery.cs</see></para><code lang="C#">            using (TempFile temp = new TempFile())
            {
                var options = GetOptions(temp);
                options.MaximumValueNodes = 255;
                options.MinimumValueNodes = 100;
                options.TransactionLog = new TransactionLog&lt;Guid, TestInfo&gt;(
                    new TransactionLogOptions&lt;Guid, TestInfo&gt;(
                        options.TransactionLogFileName,
                        options.KeySerializer,
                        options.ValueSerializer
                        ) { FileOptions = FileOptions.None } /* no-write through */
                    );
                TestRecoveryOnExisting(options, 100, ushort.MaxValue);
            }</code><code lang="VB.NET">        Using temp As New TempFile()
            Dim options As var = GetOptions(temp)
            options.MaximumValueNodes = 255
            options.MinimumValueNodes = 100
                ' no-write through 
            options.TransactionLog = New TransactionLog(Of Guid, TestInfo)(New TransactionLogOptions(Of Guid, TestInfo)(options.TransactionLogFileName, options.KeySerializer, options.ValueSerializer) With { _
                Key .FileOptions = FileOptions.None _
            })
            TestRecoveryOnExisting(options, 100, UShort.MaxValue)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.ExistingLogAction">
            <summary>
            Defines the action to perform when opening a BPlusTree with an existing log file.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#127" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.ExistingLogAction">ExistingLogAction</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs#51">BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs</see></para><code lang="C#">            var options = (BPlusTree&lt;int, string&gt;.OptionsV2)Options;

            Assert.AreEqual(ExistingLogAction.Default, options.ExistingLogAction);
            options.ExistingLogAction = ExistingLogAction.Ignore;
            Assert.AreEqual(ExistingLogAction.Ignore, options.ExistingLogAction);

            Assert.AreEqual(-1, options.TransactionLogLimit);
            options.TransactionLogLimit = int.MaxValue;
            Assert.AreEqual(int.MaxValue, options.TransactionLogLimit);</code><code lang="VB.NET">        Dim options As var = DirectCast(Options, BPlusTree(Of Integer, String).OptionsV2)

        Assert.AreEqual(ExistingLogAction.[Default], options.ExistingLogAction)
        options.ExistingLogAction = ExistingLogAction.Ignore
        Assert.AreEqual(ExistingLogAction.Ignore, options.ExistingLogAction)

        Assert.AreEqual(-1, options.TransactionLogLimit)
        options.TransactionLogLimit = Integer.MaxValue
        Assert.AreEqual(Integer.MaxValue, options.TransactionLogLimit)</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.TransactionLogLimit">
            <summary>
            Defines the number of bytes in the transaction log file before the BPlusTree will auto-commit
            and truncate the log.  Values equal to or less than zero will not auto-commit (default).
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#137" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs#65">BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs</see></para><code lang="C#">            var options = (BPlusTree&lt;int, string&gt;.OptionsV2)Options;
            options.TransactionLogLimit = 30;

            using (BPlusTree&lt;int, string&gt; tree = Create(options))
            {
                tree.EnableCount();
                Assert.AreEqual(0, tree.Count);

                tree.Add(1, "A");
                tree.Rollback();
                Assert.AreEqual(0, tree.Count);

                tree.Add(1, "A");
                tree.Add(2, "B"); //The second write exceeds 30 bytes and auto-commits
                tree.Rollback();
                Assert.AreEqual(2, tree.Count);
                tree.Add(3, "C");
                tree.Add(4, "D"); //The second write will commit, but not the last
                tree.Add(5, "E");
                tree.Rollback();
                Assert.AreEqual(4, tree.Count);
                Assert.IsFalse(tree.ContainsKey(5));
            }</code><code lang="VB.NET">        Dim options As var = DirectCast(Options, BPlusTree(Of Integer, String).OptionsV2)
        options.TransactionLogLimit = 30

        Using tree As BPlusTree(Of Integer, String) = Create(options)
            tree.EnableCount()
            Assert.AreEqual(0, tree.Count)

            tree.Add(1, "A")
            tree.Rollback()
            Assert.AreEqual(0, tree.Count)

            tree.Add(1, "A")
            tree.Add(2, "B")
            'The second write exceeds 30 bytes and auto-commits
            tree.Rollback()
            Assert.AreEqual(2, tree.Count)
            tree.Add(3, "C")
            tree.Add(4, "D")
            'The second write will commit, but not the last
            tree.Add(5, "E")
            tree.Rollback()
            Assert.AreEqual(4, tree.Count)
            Assert.IsFalse(tree.ContainsKey(5))
        End Using</code></example></member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.Options">
            <summary>
            Defines the options nessessary to construct a BPlusTree implementation
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoveryScan(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options,System.IO.FileShare)">IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; BPlusTree&lt;TKey,TValue&gt;.RecoveryScan(BPlusTree&lt;TKey,TValue&gt;.Options,FileShare)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Options.Clone" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Options BPlusTree&lt;TKey,TValue&gt;.Options.Clone()</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#131">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.Options options = new BPlusTree&lt;KeyInfo, DataValue&gt;.Options(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (TempFile copy = new TempFile())
            {
                copy.Delete();
                int minRecordCreated = StartAndAbortWriters(options, copy);

                using (TempFile.Attach(copy.TempPath + ".recovered")) //used to create the new copy
                using (TempFile.Attach(copy.TempPath + ".deleted"))  //renamed existing file
                {
                    options.CreateFile = CreatePolicy.Never;
                    int recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    if (recoveredRecords != RecordsCreated)
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated);

                    options.FileName = copy.TempPath;
                    recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated);

                    using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
                    {
                        dictionary.EnableCount();
                        Assert.AreEqual(recoveredRecords, dictionary.Count);

                        foreach (KeyValuePair&lt;KeyInfo, DataValue&gt; kv in dictionary)
                        {
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID);
                            dictionary.Remove(kv.Key);
                        }

                        Assert.AreEqual(0, dictionary.Count);
                    }
                }
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).Options(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using copy As New TempFile()
            copy.Delete()
            Dim minRecordCreated As Integer = StartAndAbortWriters(options, copy)

            Using TempFile.Attach(copy.TempPath + ".recovered")
                'used to create the new copy
                Using TempFile.Attach(copy.TempPath + ".deleted")
                    'renamed existing file
                    options.CreateFile = CreatePolicy.Never
                    Dim recoveredRecords As Integer = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    If recoveredRecords &lt;&gt; RecordsCreated Then
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated)
                    End If

                    options.FileName = copy.TempPath
                    recoveredRecords = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated)

                    Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
                        dictionary.EnableCount()
                        Assert.AreEqual(recoveredRecords, dictionary.Count)

                        For Each kv As KeyValuePair(Of KeyInfo, DataValue) In dictionary
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID)
                            dictionary.Remove(kv.Key)
                        Next

                        Assert.AreEqual(0, dictionary.Count)
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.#ctor(CSharpTest.Net.Serialization.ISerializer{`0},CSharpTest.Net.Serialization.ISerializer{`1})">
            <summary>
            Constructs the options configuration to initialize a BPlusTree instance using the default Comparer for TKey
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#256" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBPlusTreeOptions.cs#78">BPlusTree/BPlusTree.Test/TestBPlusTreeOptions.cs</see></para><code lang="C#">            var options = new BPlusTree&lt;int, int&gt;.Options(PrimitiveSerializer.Int32, PrimitiveSerializer.Int32)
            {
                CreateFile = CreatePolicy.IfNeeded,
                BTreeOrder = 4
            };
            var copy = options.Clone();

            Assert.IsFalse(Object.ReferenceEquals(options, copy));
            Assert.IsTrue(Object.ReferenceEquals(options.CallLevelLock, copy.CallLevelLock));

            //If we get/set the lock prior to clone we will have the same lock instance.
            options.CallLevelLock = new SimpleReadWriteLocking();
            copy = options.Clone();

            Assert.IsFalse(Object.ReferenceEquals(options, copy));
            Assert.IsTrue(Object.ReferenceEquals(options.CallLevelLock, copy.CallLevelLock));</code><code lang="VB.NET">        Dim options As var = New BPlusTree(Of Integer, Integer).Options(PrimitiveSerializer.Int32, PrimitiveSerializer.Int32) With { _
            Key .CreateFile = CreatePolicy.IfNeeded, _
            Key .BTreeOrder = 4 _
        }
        Dim copy As var = options.Clone()

        Assert.IsFalse([Object].ReferenceEquals(options, copy))
        Assert.IsTrue([Object].ReferenceEquals(options.CallLevelLock, copy.CallLevelLock))

        'If we get/set the lock prior to clone we will have the same lock instance.
        options.CallLevelLock = New SimpleReadWriteLocking()
        copy = options.Clone()

        Assert.IsFalse([Object].ReferenceEquals(options, copy))
        Assert.IsTrue([Object].ReferenceEquals(options.CallLevelLock, copy.CallLevelLock))</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.#ctor(CSharpTest.Net.Serialization.ISerializer{`0},CSharpTest.Net.Serialization.ISerializer{`1},System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructs the options configuration to initialize a BPlusTree instance
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#249" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#131">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.Options options = new BPlusTree&lt;KeyInfo, DataValue&gt;.Options(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (TempFile copy = new TempFile())
            {
                copy.Delete();
                int minRecordCreated = StartAndAbortWriters(options, copy);

                using (TempFile.Attach(copy.TempPath + ".recovered")) //used to create the new copy
                using (TempFile.Attach(copy.TempPath + ".deleted"))  //renamed existing file
                {
                    options.CreateFile = CreatePolicy.Never;
                    int recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    if (recoveredRecords != RecordsCreated)
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated);

                    options.FileName = copy.TempPath;
                    recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated);

                    using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
                    {
                        dictionary.EnableCount();
                        Assert.AreEqual(recoveredRecords, dictionary.Count);

                        foreach (KeyValuePair&lt;KeyInfo, DataValue&gt; kv in dictionary)
                        {
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID);
                            dictionary.Remove(kv.Key);
                        }

                        Assert.AreEqual(0, dictionary.Count);
                    }
                }
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).Options(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using copy As New TempFile()
            copy.Delete()
            Dim minRecordCreated As Integer = StartAndAbortWriters(options, copy)

            Using TempFile.Attach(copy.TempPath + ".recovered")
                'used to create the new copy
                Using TempFile.Attach(copy.TempPath + ".deleted")
                    'renamed existing file
                    options.CreateFile = CreatePolicy.Never
                    Dim recoveredRecords As Integer = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    If recoveredRecords &lt;&gt; RecordsCreated Then
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated)
                    End If

                    options.FileName = copy.TempPath
                    recoveredRecords = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated)

                    Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
                        dictionary.EnableCount()
                        Assert.AreEqual(recoveredRecords, dictionary.Count)

                        For Each kv As KeyValuePair(Of KeyInfo, DataValue) In dictionary
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID)
                            dictionary.Remove(kv.Key)
                        Next

                        Assert.AreEqual(0, dictionary.Count)
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.Clone">
            <summary>
            Creates a shallow clone of the configuration options.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#276" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBPlusTreeOptions.cs#78">BPlusTree/BPlusTree.Test/TestBPlusTreeOptions.cs</see></para><code lang="C#">            var options = new BPlusTree&lt;int, int&gt;.Options(PrimitiveSerializer.Int32, PrimitiveSerializer.Int32)
            {
                CreateFile = CreatePolicy.IfNeeded,
                BTreeOrder = 4
            };
            var copy = options.Clone();

            Assert.IsFalse(Object.ReferenceEquals(options, copy));
            Assert.IsTrue(Object.ReferenceEquals(options.CallLevelLock, copy.CallLevelLock));

            //If we get/set the lock prior to clone we will have the same lock instance.
            options.CallLevelLock = new SimpleReadWriteLocking();
            copy = options.Clone();

            Assert.IsFalse(Object.ReferenceEquals(options, copy));
            Assert.IsTrue(Object.ReferenceEquals(options.CallLevelLock, copy.CallLevelLock));</code><code lang="VB.NET">        Dim options As var = New BPlusTree(Of Integer, Integer).Options(PrimitiveSerializer.Int32, PrimitiveSerializer.Int32) With { _
            Key .CreateFile = CreatePolicy.IfNeeded, _
            Key .BTreeOrder = 4 _
        }
        Dim copy As var = options.Clone()

        Assert.IsFalse([Object].ReferenceEquals(options, copy))
        Assert.IsTrue([Object].ReferenceEquals(options.CallLevelLock, copy.CallLevelLock))

        'If we get/set the lock prior to clone we will have the same lock instance.
        options.CallLevelLock = New SimpleReadWriteLocking()
        copy = options.Clone()

        Assert.IsFalse([Object].ReferenceEquals(options, copy))
        Assert.IsTrue([Object].ReferenceEquals(options.CallLevelLock, copy.CallLevelLock))</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.CalcBTreeOrder(System.Int32,System.Int32)">
            <summary>
            Calculates default node-threasholds based upon the average number of bytes in key and value
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#320" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs#131">BPlusTree/BPlusTree.Test/ThreadedBTreeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.Options options = new BPlusTree&lt;KeyInfo, DataValue&gt;.Options(
                new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;

            using (TempFile copy = new TempFile())
            {
                copy.Delete();
                int minRecordCreated = StartAndAbortWriters(options, copy);

                using (TempFile.Attach(copy.TempPath + ".recovered")) //used to create the new copy
                using (TempFile.Attach(copy.TempPath + ".deleted"))  //renamed existing file
                {
                    options.CreateFile = CreatePolicy.Never;
                    int recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    if (recoveredRecords != RecordsCreated)
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated);

                    options.FileName = copy.TempPath;
                    recoveredRecords = BPlusTree&lt;KeyInfo, DataValue&gt;.RecoverFile(options);
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated);

                    using (BPlusTree&lt;KeyInfo, DataValue&gt; dictionary = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
                    {
                        dictionary.EnableCount();
                        Assert.AreEqual(recoveredRecords, dictionary.Count);

                        foreach (KeyValuePair&lt;KeyInfo, DataValue&gt; kv in dictionary)
                        {
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID);
                            dictionary.Remove(kv.Key);
                        }

                        Assert.AreEqual(0, dictionary.Count);
                    }
                }
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).Options(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always

        Using copy As New TempFile()
            copy.Delete()
            Dim minRecordCreated As Integer = StartAndAbortWriters(options, copy)

            Using TempFile.Attach(copy.TempPath + ".recovered")
                'used to create the new copy
                Using TempFile.Attach(copy.TempPath + ".deleted")
                    'renamed existing file
                    options.CreateFile = CreatePolicy.Never
                    Dim recoveredRecords As Integer = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    If recoveredRecords &lt;&gt; RecordsCreated Then
                        Assert.Fail("Unable to recover records, recieved ({0} of {1}).", recoveredRecords, RecordsCreated)
                    End If

                    options.FileName = copy.TempPath
                    recoveredRecords = BPlusTree(Of KeyInfo, DataValue).RecoverFile(options)
                    Assert.IsTrue(recoveredRecords &gt;= minRecordCreated)

                    Using dictionary As New BPlusTree(Of KeyInfo, DataValue)(options)
                        dictionary.EnableCount()
                        Assert.AreEqual(recoveredRecords, dictionary.Count)

                        For Each kv As KeyValuePair(Of KeyInfo, DataValue) In dictionary
                            Assert.AreEqual(kv.Key.UID, kv.Value.Key.UID)
                            dictionary.Remove(kv.Key)
                        Next

                        Assert.AreEqual(0, dictionary.Count)
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.CalculateOrder(System.Int32,System.Int32)">
            <summary>
            Calculates default node-threasholds based upon the average number of bytes in key and value
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.CreateStorage">
            <summary> Used to create the correct storage type </summary>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.FileOpenOptions">
            <summary>
            Gets or sets the number of bytes per file-block used in the file storage
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#283" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestFileSerialized.cs#56">BPlusTree/BPlusTree.Test/TestFileSerialized.cs</see></para><code lang="C#">            BPlusTree&lt;int, string&gt;.Options options = (BPlusTree&lt;int, string&gt;.Options)Options;
            options.BTreeOrder = 4;
            options.FileBlockSize = 512;
            options.FileGrowthRate = 25;
            options.ConcurrentWriters = 4;
            options.FileOpenOptions = FileOptions.None;

            using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
            {
                for(int i=0; i &lt; 100; i++)
                    Assert.IsTrue(tree.TryAdd(i, i.ToString()));
            }

            using (Stream io = TempFile.Open())
            {
                //first we can corrupt the root node, which is always at an offset of BlockSize
                io.Seek(512, SeekOrigin.Begin);
                io.Write(new byte[512], 0, 512);

                //Now let's corrupt one byte from the end of the node at index 3
                io.Seek(1024 + 16, SeekOrigin.Begin);
                int len = PrimitiveSerializer.Int32.ReadFrom(io);
                io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin);//secrets of fragmented file revealed... ugly i know.
                io.WriteByte(255); //overwrite last used byte in chunk.
            }

            options.CreateFile = CreatePolicy.Never;

            //Now that we've corrupted part of the file content, let's take a peek
            try
            {
                using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
                {
                    foreach (KeyValuePair&lt;int, string&gt; kv in tree)
                        Assert.AreEqual(kv.Key.ToString(), kv.Value);
                }
                Assert.Fail("Expected InvalidDataException");
            }
            catch (InvalidDataException)
            { }

            Dictionary&lt;int, string&gt; found = new Dictionary&lt;int, string&gt;();
            List&lt;int&gt; duplicates = new List&lt;int&gt;();
            foreach (KeyValuePair&lt;int, string&gt; kv in BPlusTree&lt;int, string&gt;.RecoveryScan(options, FileShare.None))
            {
                if (!found.ContainsKey(kv.Key))
                    found.Add(kv.Key, kv.Value);
                else
                    duplicates.Add(kv.Key);
                
                Assert.AreEqual(kv.Key.ToString(), kv.Value);
            }
            Assert.AreNotEqual(0, found.Count);

            //The following may change...
            Assert.AreEqual(99, found.Count);
            Assert.IsFalse(found.ContainsKey(3), "should be missing #3");
            Assert.AreEqual(0, duplicates.Count);</code><code lang="VB.NET">        Dim options As BPlusTree(Of Integer, String).Options = DirectCast(Options, BPlusTree(Of Integer, String).Options)
        options.BTreeOrder = 4
        options.FileBlockSize = 512
        options.FileGrowthRate = 25
        options.ConcurrentWriters = 4
        options.FileOpenOptions = FileOptions.None

        Using tree As New BPlusTree(Of Integer, String)(options)
            Dim i As Integer = 0
            While i &lt; 100
                Assert.IsTrue(tree.TryAdd(i, i.ToString()))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
        End Using

        Using io As Stream = TempFile.Open()
            'first we can corrupt the root node, which is always at an offset of BlockSize
            io.Seek(512, SeekOrigin.Begin)
            io.Write(New Byte(512) {}, 0, 512)

            'Now let's corrupt one byte from the end of the node at index 3
            io.Seek(1024 + 16, SeekOrigin.Begin)
            Dim len As Integer = PrimitiveSerializer.Int32.ReadFrom(io)
            io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin)
            'secrets of fragmented file revealed... ugly i know.
                'overwrite last used byte in chunk.
            io.WriteByte(255)
        End Using

        options.CreateFile = CreatePolicy.Never

        'Now that we've corrupted part of the file content, let's take a peek
        Try
            Using tree As New BPlusTree(Of Integer, String)(options)
                For Each kv As KeyValuePair(Of Integer, String) In tree
                    Assert.AreEqual(kv.Key.ToString(), kv.Value)
                Next
            End Using
            Assert.Fail("Expected InvalidDataException")
        Catch generatedExceptionName As InvalidDataException
        End Try

        Dim found As New Dictionary(Of Integer, String)()
        Dim duplicates As New List(Of Integer)()
        For Each kv As KeyValuePair(Of Integer, String) In BPlusTree(Of Integer, String).RecoveryScan(options, FileShare.None)
            If Not found.ContainsKey(kv.Key) Then
                found.Add(kv.Key, kv.Value)
            Else
                duplicates.Add(kv.Key)
            End If

            Assert.AreEqual(kv.Key.ToString(), kv.Value)
        Next
        Assert.AreNotEqual(0, found.Count)

        'The following may change...
        Assert.AreEqual(99, found.Count)
        Assert.IsFalse(found.ContainsKey(3), "should be missing #3")
        Assert.AreEqual(0, duplicates.Count)</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.FileGrowthRate">
            <summary>
            Gets or sets the number of blocks that a file will grow by when all blocks are used, use zero for incremental growth
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#292" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestFileSerialized.cs#56">BPlusTree/BPlusTree.Test/TestFileSerialized.cs</see></para><code lang="C#">            BPlusTree&lt;int, string&gt;.Options options = (BPlusTree&lt;int, string&gt;.Options)Options;
            options.BTreeOrder = 4;
            options.FileBlockSize = 512;
            options.FileGrowthRate = 25;
            options.ConcurrentWriters = 4;
            options.FileOpenOptions = FileOptions.None;

            using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
            {
                for(int i=0; i &lt; 100; i++)
                    Assert.IsTrue(tree.TryAdd(i, i.ToString()));
            }

            using (Stream io = TempFile.Open())
            {
                //first we can corrupt the root node, which is always at an offset of BlockSize
                io.Seek(512, SeekOrigin.Begin);
                io.Write(new byte[512], 0, 512);

                //Now let's corrupt one byte from the end of the node at index 3
                io.Seek(1024 + 16, SeekOrigin.Begin);
                int len = PrimitiveSerializer.Int32.ReadFrom(io);
                io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin);//secrets of fragmented file revealed... ugly i know.
                io.WriteByte(255); //overwrite last used byte in chunk.
            }

            options.CreateFile = CreatePolicy.Never;

            //Now that we've corrupted part of the file content, let's take a peek
            try
            {
                using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
                {
                    foreach (KeyValuePair&lt;int, string&gt; kv in tree)
                        Assert.AreEqual(kv.Key.ToString(), kv.Value);
                }
                Assert.Fail("Expected InvalidDataException");
            }
            catch (InvalidDataException)
            { }

            Dictionary&lt;int, string&gt; found = new Dictionary&lt;int, string&gt;();
            List&lt;int&gt; duplicates = new List&lt;int&gt;();
            foreach (KeyValuePair&lt;int, string&gt; kv in BPlusTree&lt;int, string&gt;.RecoveryScan(options, FileShare.None))
            {
                if (!found.ContainsKey(kv.Key))
                    found.Add(kv.Key, kv.Value);
                else
                    duplicates.Add(kv.Key);
                
                Assert.AreEqual(kv.Key.ToString(), kv.Value);
            }
            Assert.AreNotEqual(0, found.Count);

            //The following may change...
            Assert.AreEqual(99, found.Count);
            Assert.IsFalse(found.ContainsKey(3), "should be missing #3");
            Assert.AreEqual(0, duplicates.Count);</code><code lang="VB.NET">        Dim options As BPlusTree(Of Integer, String).Options = DirectCast(Options, BPlusTree(Of Integer, String).Options)
        options.BTreeOrder = 4
        options.FileBlockSize = 512
        options.FileGrowthRate = 25
        options.ConcurrentWriters = 4
        options.FileOpenOptions = FileOptions.None

        Using tree As New BPlusTree(Of Integer, String)(options)
            Dim i As Integer = 0
            While i &lt; 100
                Assert.IsTrue(tree.TryAdd(i, i.ToString()))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
        End Using

        Using io As Stream = TempFile.Open()
            'first we can corrupt the root node, which is always at an offset of BlockSize
            io.Seek(512, SeekOrigin.Begin)
            io.Write(New Byte(512) {}, 0, 512)

            'Now let's corrupt one byte from the end of the node at index 3
            io.Seek(1024 + 16, SeekOrigin.Begin)
            Dim len As Integer = PrimitiveSerializer.Int32.ReadFrom(io)
            io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin)
            'secrets of fragmented file revealed... ugly i know.
                'overwrite last used byte in chunk.
            io.WriteByte(255)
        End Using

        options.CreateFile = CreatePolicy.Never

        'Now that we've corrupted part of the file content, let's take a peek
        Try
            Using tree As New BPlusTree(Of Integer, String)(options)
                For Each kv As KeyValuePair(Of Integer, String) In tree
                    Assert.AreEqual(kv.Key.ToString(), kv.Value)
                Next
            End Using
            Assert.Fail("Expected InvalidDataException")
        Catch generatedExceptionName As InvalidDataException
        End Try

        Dim found As New Dictionary(Of Integer, String)()
        Dim duplicates As New List(Of Integer)()
        For Each kv As KeyValuePair(Of Integer, String) In BPlusTree(Of Integer, String).RecoveryScan(options, FileShare.None)
            If Not found.ContainsKey(kv.Key) Then
                found.Add(kv.Key, kv.Value)
            Else
                duplicates.Add(kv.Key)
            End If

            Assert.AreEqual(kv.Key.ToString(), kv.Value)
        Next
        Assert.AreNotEqual(0, found.Count)

        'The following may change...
        Assert.AreEqual(99, found.Count)
        Assert.IsFalse(found.ContainsKey(3), "should be missing #3")
        Assert.AreEqual(0, duplicates.Count)</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.ConcurrentWriters">
            <summary>
            Gets or sets the number of streams that will be created for threads to write in the file store
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#304" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestFileSerialized.cs#56">BPlusTree/BPlusTree.Test/TestFileSerialized.cs</see></para><code lang="C#">            BPlusTree&lt;int, string&gt;.Options options = (BPlusTree&lt;int, string&gt;.Options)Options;
            options.BTreeOrder = 4;
            options.FileBlockSize = 512;
            options.FileGrowthRate = 25;
            options.ConcurrentWriters = 4;
            options.FileOpenOptions = FileOptions.None;

            using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
            {
                for(int i=0; i &lt; 100; i++)
                    Assert.IsTrue(tree.TryAdd(i, i.ToString()));
            }

            using (Stream io = TempFile.Open())
            {
                //first we can corrupt the root node, which is always at an offset of BlockSize
                io.Seek(512, SeekOrigin.Begin);
                io.Write(new byte[512], 0, 512);

                //Now let's corrupt one byte from the end of the node at index 3
                io.Seek(1024 + 16, SeekOrigin.Begin);
                int len = PrimitiveSerializer.Int32.ReadFrom(io);
                io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin);//secrets of fragmented file revealed... ugly i know.
                io.WriteByte(255); //overwrite last used byte in chunk.
            }

            options.CreateFile = CreatePolicy.Never;

            //Now that we've corrupted part of the file content, let's take a peek
            try
            {
                using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(options))
                {
                    foreach (KeyValuePair&lt;int, string&gt; kv in tree)
                        Assert.AreEqual(kv.Key.ToString(), kv.Value);
                }
                Assert.Fail("Expected InvalidDataException");
            }
            catch (InvalidDataException)
            { }

            Dictionary&lt;int, string&gt; found = new Dictionary&lt;int, string&gt;();
            List&lt;int&gt; duplicates = new List&lt;int&gt;();
            foreach (KeyValuePair&lt;int, string&gt; kv in BPlusTree&lt;int, string&gt;.RecoveryScan(options, FileShare.None))
            {
                if (!found.ContainsKey(kv.Key))
                    found.Add(kv.Key, kv.Value);
                else
                    duplicates.Add(kv.Key);
                
                Assert.AreEqual(kv.Key.ToString(), kv.Value);
            }
            Assert.AreNotEqual(0, found.Count);

            //The following may change...
            Assert.AreEqual(99, found.Count);
            Assert.IsFalse(found.ContainsKey(3), "should be missing #3");
            Assert.AreEqual(0, duplicates.Count);</code><code lang="VB.NET">        Dim options As BPlusTree(Of Integer, String).Options = DirectCast(Options, BPlusTree(Of Integer, String).Options)
        options.BTreeOrder = 4
        options.FileBlockSize = 512
        options.FileGrowthRate = 25
        options.ConcurrentWriters = 4
        options.FileOpenOptions = FileOptions.None

        Using tree As New BPlusTree(Of Integer, String)(options)
            Dim i As Integer = 0
            While i &lt; 100
                Assert.IsTrue(tree.TryAdd(i, i.ToString()))
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While
        End Using

        Using io As Stream = TempFile.Open()
            'first we can corrupt the root node, which is always at an offset of BlockSize
            io.Seek(512, SeekOrigin.Begin)
            io.Write(New Byte(512) {}, 0, 512)

            'Now let's corrupt one byte from the end of the node at index 3
            io.Seek(1024 + 16, SeekOrigin.Begin)
            Dim len As Integer = PrimitiveSerializer.Int32.ReadFrom(io)
            io.Seek(1024 + 32 + len - 1, SeekOrigin.Begin)
            'secrets of fragmented file revealed... ugly i know.
                'overwrite last used byte in chunk.
            io.WriteByte(255)
        End Using

        options.CreateFile = CreatePolicy.Never

        'Now that we've corrupted part of the file content, let's take a peek
        Try
            Using tree As New BPlusTree(Of Integer, String)(options)
                For Each kv As KeyValuePair(Of Integer, String) In tree
                    Assert.AreEqual(kv.Key.ToString(), kv.Value)
                Next
            End Using
            Assert.Fail("Expected InvalidDataException")
        Catch generatedExceptionName As InvalidDataException
        End Try

        Dim found As New Dictionary(Of Integer, String)()
        Dim duplicates As New List(Of Integer)()
        For Each kv As KeyValuePair(Of Integer, String) In BPlusTree(Of Integer, String).RecoveryScan(options, FileShare.None)
            If Not found.ContainsKey(kv.Key) Then
                found.Add(kv.Key, kv.Value)
            Else
                duplicates.Add(kv.Key)
            End If

            Assert.AreEqual(kv.Key.ToString(), kv.Value)
        Next
        Assert.AreNotEqual(0, found.Count)

        'The following may change...
        Assert.AreEqual(99, found.Count)
        Assert.IsFalse(found.ContainsKey(3), "should be missing #3")
        Assert.AreEqual(0, duplicates.Count)</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.FileVersion">
            <summary>
            Returns the version this option set is compatable with.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.Options.cs#313" cat="Source Code">BPlusTree/Collections/BPlusTree.Options.cs</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.FileVersion">FileVersion</seealso></member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheBase">
            <summary> Provides base functionality of a node cache, not much exciting here </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheFull">
            <summary> performs a perfect cache of the entire tree </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheNone">
            <summary> performs a perfect cache of the entire tree </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Node.CopyTo(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Element[],System.Int32@)">
            <summary> For enumeration </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheNormal">
            <summary>
            This is the default cache type, uses weakreferences and the GC to collect unused nodes after they exit
            the ObjectKeepAlive containment policy.
            </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.INodeStorage">
            <summary> Represents a persistance mechanic for node data </summary>
        <seealso cref="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.StorageSystem">INodeStorage BPlusTreeOptions&lt;TKey,TValue&gt;.StorageSystem</seealso></member>
        <member name="M:CSharpTest.Net.Collections.INodeStorage.OpenRoot(System.Boolean@)">
            <summary> Returns an immutable handle to the root node, sets isNew to true if no data exists </summary>
        <seealso cref="T:CSharpTest.Net.Collections.IStorageHandle">IStorageHandle</seealso></member>
        <member name="M:CSharpTest.Net.Collections.INodeStorage.Reset">
            <summary> Destroys the entire contents of the storage system except for the root handle which remains valid </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.INodeStorage.TryGetNode``1(CSharpTest.Net.Collections.IStorageHandle,``0@,CSharpTest.Net.Serialization.ISerializer{``0})">
            <summary> Retrieves a single node from storage </summary>
        <seealso cref="T:CSharpTest.Net.Collections.IStorageHandle">IStorageHandle</seealso><seealso cref="T:CSharpTest.Net.Serialization.ISerializer{``0}">ISerializer&lt;TNode&gt;</seealso></member>
        <member name="M:CSharpTest.Net.Collections.INodeStorage.Create">
            <summary> Creates a node handle that will represent a new node instance </summary>
        <seealso cref="T:CSharpTest.Net.Collections.IStorageHandle">IStorageHandle</seealso></member>
        <member name="M:CSharpTest.Net.Collections.INodeStorage.Destroy(CSharpTest.Net.Collections.IStorageHandle)">
            <summary> Destroys the node that was formally stored by the specified handle </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><seealso cref="T:CSharpTest.Net.Collections.IStorageHandle">IStorageHandle</seealso></member>
        <member name="M:CSharpTest.Net.Collections.INodeStorage.Update``1(CSharpTest.Net.Collections.IStorageHandle,CSharpTest.Net.Serialization.ISerializer{``0},``0)">
            <summary> Updates the node of the specified handle with the instance given </summary>
        <seealso cref="T:CSharpTest.Net.Collections.IStorageHandle">IStorageHandle</seealso><seealso cref="T:CSharpTest.Net.Serialization.ISerializer{``0}">ISerializer&lt;TNode&gt;</seealso></member>
        <member name="T:CSharpTest.Net.Collections.StorageType">
            <summary> Defines the storage type to use </summary>
        <seealso cref="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.StorageType">StorageType BPlusTreeOptions&lt;TKey,TValue&gt;.StorageType</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestCustomStorage.cs#40">BPlusTree/BPlusTree.Test/TestCustomStorage.cs</see></para><code lang="C#">            BPlusTreeOptions&lt;int, string&gt; options = Options;
            Assert.AreEqual(StorageType.Custom, options.StorageType);</code><code lang="VB.NET">        Dim options As BPlusTreeOptions(Of Integer, String) = Options
        Assert.AreEqual(StorageType.[Custom], options.StorageType)</code></example></member>
        <member name="F:CSharpTest.Net.Collections.StorageType.Memory">
            <summary> Uses in-memory storage </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.StorageType.Disk">
            <summary> Uses a file to store data, (Set by setting the FileName property) </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.StorageType.Custom">
            <summary> Uses a custom data store, (Set by setting the StorageSystem property) </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.CreatePolicy">
            <summary> Determines if the file specified should be created </summary>
        <seealso cref="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.CreateFile">CreatePolicy BPlusTreeOptions&lt;TKey,TValue&gt;.CreateFile</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBPlusTreeOptions.cs#29">BPlusTree/BPlusTree.Test/TestBPlusTreeOptions.cs</see></para><code lang="C#">            ICloneable opt = new BPlusTree&lt;int, int&gt;.Options(PrimitiveSerializer.Int32, PrimitiveSerializer.Int32) 
            {
                CreateFile = CreatePolicy.IfNeeded,
                BTreeOrder = 4
            };
            BPlusTree&lt;int, int&gt;.Options options = (BPlusTree&lt;int, int&gt;.Options)opt.Clone();
            
            Assert.AreEqual(CreatePolicy.IfNeeded, options.CreateFile);
            Assert.AreEqual(4, options.MaximumChildNodes);
            Assert.AreEqual(4, options.MaximumValueNodes);</code><code lang="VB.NET">        Dim opt As ICloneable = New BPlusTree(Of Integer, Integer).Options(PrimitiveSerializer.Int32, PrimitiveSerializer.Int32) With { _
            Key .CreateFile = CreatePolicy.IfNeeded, _
            Key .BTreeOrder = 4 _
        }
        Dim options As BPlusTree(Of Integer, Integer).Options = DirectCast(opt.Clone(), BPlusTree(Of Integer, Integer).Options)

        Assert.AreEqual(CreatePolicy.IfNeeded, options.CreateFile)
        Assert.AreEqual(4, options.MaximumChildNodes)
        Assert.AreEqual(4, options.MaximumValueNodes)</code></example></member>
        <member name="F:CSharpTest.Net.Collections.CreatePolicy.Never">
            <summary> Does not create a new file </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.CreatePolicy.Always">
            <summary> Creates a new file even if one already exists </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.CreatePolicy.IfNeeded">
            <summary> Creates a new file only if it does not exist </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.CachePolicy">
            <summary> Determines the type of node caching used in the tree </summary>
        <seealso cref="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.CachePolicy">CachePolicy BPlusTreeOptions&lt;TKey,TValue&gt;.CachePolicy</seealso></member>
        <member name="F:CSharpTest.Net.Collections.CachePolicy.None">
            <summary> Does not cache, allways loads from storage. </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.CachePolicy.All">
            <summary> Keeps every loaded object in memory. </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.CachePolicy.Recent">
            <summary> Keeps a history of objects in memory (see CacheKeepAliveXXX properties) </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.ExistingLogAction">
            <summary>
            Defines the action to perform when opening a BPlusTree with an existing log file.
            </summary>
        <seealso cref="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.ExistingLogAction">ExistingLogAction BPlusTree&lt;TKey,TValue&gt;.OptionsV2.ExistingLogAction</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs#51">BPlusTree/BPlusTree.Test/BasicTestsVersion2.cs</see></para><code lang="C#">            var options = (BPlusTree&lt;int, string&gt;.OptionsV2)Options;

            Assert.AreEqual(ExistingLogAction.Default, options.ExistingLogAction);
            options.ExistingLogAction = ExistingLogAction.Ignore;
            Assert.AreEqual(ExistingLogAction.Ignore, options.ExistingLogAction);

            Assert.AreEqual(-1, options.TransactionLogLimit);
            options.TransactionLogLimit = int.MaxValue;
            Assert.AreEqual(int.MaxValue, options.TransactionLogLimit);</code><code lang="VB.NET">        Dim options As var = DirectCast(Options, BPlusTree(Of Integer, String).OptionsV2)

        Assert.AreEqual(ExistingLogAction.[Default], options.ExistingLogAction)
        options.ExistingLogAction = ExistingLogAction.Ignore
        Assert.AreEqual(ExistingLogAction.Ignore, options.ExistingLogAction)

        Assert.AreEqual(-1, options.TransactionLogLimit)
        options.TransactionLogLimit = Integer.MaxValue
        Assert.AreEqual(Integer.MaxValue, options.TransactionLogLimit)</code></example></member>
        <member name="F:CSharpTest.Net.Collections.ExistingLogAction.Default">
            <summary> 
            Infers the default wether or not the data file was created.  For newly created data
            files (CreatePolicy = Always, or IfNeeded and the file is missing) the default will
            be Truncate.  When existing data files are opened the default will ReplayAndCommit.
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.ExistingLogAction.Ignore">
            <summary> Ignore the existing entries in the log </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.ExistingLogAction.Replay">
            <summary> Replay the log entries uncommitted </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.ExistingLogAction.ReplayAndCommit">
            <summary> Replay the log entries and commit the changes to the store </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.ExistingLogAction.Truncate">
            <summary> Ignore the existing entries and truncate the log </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.StoragePerformance">
            <summary>
            Defines the levels of durability the store will try to achieve.  'Uncommitted changes' in the descriptions below
            refers to all changes made to the tree since the last call to CommitChanges() on the BPlusTree class.
            </summary>
        <seealso cref="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.StoragePerformance">StoragePerformance BPlusTree&lt;TKey,TValue&gt;.OptionsV2.StoragePerformance</seealso></member>
        <member name="F:CSharpTest.Net.Collections.StoragePerformance.Fastest">
            <summary> (100k rps) Uncommitted changes will be lost, a crash durring commit may corrupt state. </summary>
            <remarks> 
            No changes are committed until a call to Commit is made, durring the commit a partial write may corrupt the store.
            </remarks>
        </member>
        <member name="F:CSharpTest.Net.Collections.StoragePerformance.LogFileInCache">
            <summary> (30k rps) Uses a system-cached transaction log to recover uncommitted changes after a process crash. </summary>
            <remarks> Will not corrupt state; however, in a power outage or system failure it may loose some comitted records. </remarks>
        </member>
        <member name="F:CSharpTest.Net.Collections.StoragePerformance.CommitToCache">
            <summary> (8k rps) Every write will commit changes to the storage file immediately into system cache </summary>
            <remarks> May corrupt state and/or loose data in the event of a power outage </remarks>
        </member>
        <member name="F:CSharpTest.Net.Collections.StoragePerformance.LogFileNoCache">
            <summary> (2k rps) Uses a cache-writethrough transaction log to recover uncommitted changes after a power outage or system crash. </summary>
            <remarks> Complies with ACID durability requirements, can be expensive to recover from the log. </remarks>
        </member>
        <member name="F:CSharpTest.Net.Collections.StoragePerformance.CommitToDisk">
            <summary> (1k rps) Every write will commit changes to the storage file immediately bypassing system cache (Slowest/Safest) </summary>
            <remarks> Complies with ACID durability requirements </remarks>
        </member>
        <member name="F:CSharpTest.Net.Collections.StoragePerformance.Default">
            <summary> Defaults to using a transaction log in system cache for best performance/durability. </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.FileVersion">
            <summary> Determines the binary file format and backwards compatibility </summary>
        <seealso cref="P:CSharpTest.Net.Collections.BPlusTreeOptions`2.FileVersion">FileVersion BPlusTreeOptions&lt;TKey,TValue&gt;.FileVersion</seealso><seealso cref="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.FileVersion">FileVersion BPlusTree&lt;TKey,TValue&gt;.OptionsV2.FileVersion</seealso><seealso cref="P:CSharpTest.Net.Collections.BPlusTree`2.Options.FileVersion">FileVersion BPlusTree&lt;TKey,TValue&gt;.Options.FileVersion</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/SampleCustomTypeTest.cs#80">BPlusTree/BPlusTree.Test/SampleCustomTypeTest.cs</see></para><code lang="C#">            BPlusTree&lt;KeyInfo, DataValue&gt;.Options options =
                new BPlusTree&lt;KeyInfo, DataValue&gt;.Options(new KeyInfoSerializer(), new DataValueSerializer(), new KeyInfoComparer());
            options.CalcBTreeOrder(32, 300);//we can simply just guess close
            options.FileName = TempFile.TempPath;
            options.CreateFile = CreatePolicy.Always;//obviously this is just for testing
            Assert.AreEqual(FileVersion.Version1, options.FileVersion);

            Random rand = new Random();
            KeyInfo k1 = new KeyInfo(), k2 = new KeyInfo();

            using (BPlusTree&lt;KeyInfo, DataValue&gt; tree = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            {
                byte[] data = new byte[255];

                rand.NextBytes(data);
                tree.Add(k1, new DataValue(k1, data));

                Assert.IsTrue(tree.ContainsKey(k1));
                Assert.IsFalse(tree.ContainsKey(k1.Next()));
                Assert.AreEqual(data, tree[k1].Bytes);

                rand.NextBytes(data);
                tree.Add(k2, new DataValue(k2, data));

                Assert.IsTrue(tree.ContainsKey(k2));
                Assert.IsFalse(tree.ContainsKey(k2.Next()));
                Assert.AreEqual(data, tree[k2].Bytes);
            }
            options.CreateFile = CreatePolicy.Never;
            using (BPlusTree&lt;KeyInfo, DataValue&gt; tree = new BPlusTree&lt;KeyInfo, DataValue&gt;(options))
            {
                Assert.IsTrue(tree.ContainsKey(k1));
                Assert.IsTrue(tree.ContainsKey(k2));
            }</code><code lang="VB.NET">        Dim options As New BPlusTree(Of KeyInfo, DataValue).Options(New KeyInfoSerializer(), New DataValueSerializer(), New KeyInfoComparer())
        options.CalcBTreeOrder(32, 300)
        'we can simply just guess close
        options.FileName = TempFile.TempPath
        options.CreateFile = CreatePolicy.Always
        'obviously this is just for testing
        Assert.AreEqual(FileVersion.Version1, options.FileVersion)

        Dim rand As New Random()
        Dim k1 As New KeyInfo(), k2 As New KeyInfo()

        Using tree As New BPlusTree(Of KeyInfo, DataValue)(options)
            Dim data As Byte() = New Byte(255) {}

            rand.NextBytes(data)
            tree.Add(k1, New DataValue(k1, data))

            Assert.IsTrue(tree.ContainsKey(k1))
            Assert.IsFalse(tree.ContainsKey(k1.[Next]()))
            Assert.AreEqual(data, tree(k1).Bytes)

            rand.NextBytes(data)
            tree.Add(k2, New DataValue(k2, data))

            Assert.IsTrue(tree.ContainsKey(k2))
            Assert.IsFalse(tree.ContainsKey(k2.[Next]()))
            Assert.AreEqual(data, tree(k2).Bytes)
        End Using
        options.CreateFile = CreatePolicy.Never
        Using tree As New BPlusTree(Of KeyInfo, DataValue)(options)
            Assert.IsTrue(tree.ContainsKey(k1))
            Assert.IsTrue(tree.ContainsKey(k2))
        End Using</code></example></member>
        <member name="F:CSharpTest.Net.Collections.FileVersion.Version1">
            <summary> Version 1 compatable </summary>
        </member>
        <member name="F:CSharpTest.Net.Collections.FileVersion.Version2">
            <summary> Version 2 compatable </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.BulkInsertOptions">
            <summary>
            Options for bulk insertion
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/Node.BulkInsert.cs" cat="Source Code">BPlusTree/Collections/Node.BulkInsert.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.BulkInsertOptions.#ctor">
            <summary> Constructs with defaults: false/RaisesException </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/Node.BulkInsert.cs#35" cat="Source Code">BPlusTree/Collections/Node.BulkInsert.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BulkInsertOptions.InputIsSorted">
            <summary> Gets or sets a value that controls input presorting </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/Node.BulkInsert.cs#47" cat="Source Code">BPlusTree/Collections/Node.BulkInsert.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BulkInsertOptions.DuplicateHandling">
            <summary> Gets or sets the handling for duplicate key collisions </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/Node.BulkInsert.cs#54" cat="Source Code">BPlusTree/Collections/Node.BulkInsert.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.DuplicateHandling">DuplicateHandling</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBulkInsert.cs#254">BPlusTree/BPlusTree.Test/TestBulkInsert.cs</see></para><code lang="C#">            Dictionary&lt;int, string&gt; test = new Dictionary&lt;int, string&gt;();
            IEnumerable&lt;KeyValuePair&lt;int, string&gt;&gt;[] sets =
                new List&lt;IEnumerable&lt;KeyValuePair&lt;int, string&gt;&gt;&gt;(CreateSets(1, 1000, test)).ToArray();

            using (BPlusTree&lt;int, string&gt; tree = new BPlusTree&lt;int, string&gt;(Options))
            {
                tree.BulkInsert(
                    new OrderedKeyValuePairs&lt;int, string&gt;(sets[0]),
                    new BulkInsertOptions { DuplicateHandling = DuplicateHandling.LastValueWins, InputIsSorted = true }
                    );

                VerifyDictionary(test, tree);

                // Use bulk insert to overwrite the contents of tree
                test = new Dictionary&lt;int, string&gt;();
                sets = new List&lt;IEnumerable&lt;KeyValuePair&lt;int, string&gt;&gt;&gt;(CreateSets(1, 100, test)).ToArray();

                tree.BulkInsert(
                    new OrderedKeyValuePairs&lt;int, string&gt;(sets[0]),
                    new BulkInsertOptions 
                    {
                        CommitOnCompletion = false,
                        InputIsSorted = true,
                        ReplaceContents = true,
                        DuplicateHandling = DuplicateHandling.RaisesException, 
                    }
                );

                VerifyDictionary(test, tree);
            }</code><code lang="VB.NET">        Dim test As New Dictionary(Of Integer, String)()
        Dim sets As IEnumerable(Of KeyValuePair(Of Integer, String))() = New List(Of IEnumerable(Of KeyValuePair(Of Integer, String)))(CreateSets(1, 1000, test)).ToArray()

        Using tree As New BPlusTree(Of Integer, String)(Options)
            tree.BulkInsert(New OrderedKeyValuePairs(Of Integer, String)(sets(0)), New BulkInsertOptions() With { _
                Key .DuplicateHandling = DuplicateHandling.LastValueWins, _
                Key .InputIsSorted = True _
            })

            VerifyDictionary(test, tree)

            ' Use bulk insert to overwrite the contents of tree
            test = New Dictionary(Of Integer, String)()
            sets = New List(Of IEnumerable(Of KeyValuePair(Of Integer, String)))(CreateSets(1, 100, test)).ToArray()

            tree.BulkInsert(New OrderedKeyValuePairs(Of Integer, String)(sets(0)), New BulkInsertOptions() With { _
                Key .CommitOnCompletion = False, _
                Key .InputIsSorted = True, _
                Key .ReplaceContents = True, _
                Key .DuplicateHandling = DuplicateHandling.RaisesException _
            })

            VerifyDictionary(test, tree)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BulkInsertOptions.CommitOnCompletion">
            <summary> When true (default) BulkInsert will call CommitChanges() on successfull completion </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/Node.BulkInsert.cs#61" cat="Source Code">BPlusTree/Collections/Node.BulkInsert.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.BulkInsertOptions.ReplaceContents">
            <summary> When false merges the data with the existing contents, set to true to replace all content </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/Node.BulkInsert.cs#68" cat="Source Code">BPlusTree/Collections/Node.BulkInsert.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestMultiInstance.cs#100">BPlusTree/BPlusTree.Test/TestMultiInstance.cs</see></para><code lang="C#">            using (var tempFile = new TempFile())
            using (var logfile = new TempFile())
            using (var tempCopy = new TempFile())
            {
                var options = new BPlusTree&lt;int, string&gt;.OptionsV2(new PrimitiveSerializer(), new PrimitiveSerializer())
                {
                    CreateFile = CreatePolicy.Always,
                    FileName = tempFile.TempPath,
                    TransactionLogFileName = logfile.TempPath,
                }.CalcBTreeOrder(4, 10);

                var readcopy = options.Clone();
                readcopy.FileName = tempCopy.TempPath;
                readcopy.StoragePerformance = StoragePerformance.Fastest;

                using (var tree = new BPlusTree&lt;int, string&gt;(options))
                using (var copy = new BPlusTree&lt;int, string&gt;(readcopy))
                using (var tlog = new TransactionLog&lt;int, string&gt;(
                    new TransactionLogOptions&lt;int, string&gt;(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.String) { ReadOnly = true }))
                {
                    tree.Add(0, "0");
                    tree.Commit();

                    long logpos = 0;
                    copy.EnableCount();
                    //start by copying the data from tree's file into the copy instance:
                    copy.BulkInsert(
                        BPlusTree&lt;int, string&gt;.EnumerateFile(options),
                        new BulkInsertOptions { InputIsSorted = true, CommitOnCompletion = false, ReplaceContents = true }
                        );

                    Assert.AreEqual(1, copy.Count);
                    Assert.AreEqual("0", copy[0]);

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1, copy.Count);

                    //insert some data...
                    tree.AddRange(MakeValues(1, 99));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(100, copy.Count);

                    //insert some data...
                    for (int i = 0; i &lt; 100; i++)
                        tree.Remove(i);
                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(0, copy.Count);

                    tree.AddRange(MakeValues(1000, 1000));

                    tlog.ReplayLog(copy, ref logpos);
                    Assert.AreEqual(1000, copy.Count);
                }
            }</code><code lang="VB.NET">        Using tempFile As var = New TempFile()
            Using logfile As var = New TempFile()
                Using tempCopy As var = New TempFile()
                    Dim options As var = New BPlusTree(Of Integer, String).OptionsV2(New PrimitiveSerializer(), New PrimitiveSerializer()) With { _
                        Key .CreateFile = CreatePolicy.Always, _
                        Key .FileName = tempFile.TempPath, _
                        Key .TransactionLogFileName = logfile.TempPath _
                    }.CalcBTreeOrder(4, 10)

                    Dim readcopy As var = options.Clone()
                    readcopy.FileName = tempCopy.TempPath
                    readcopy.StoragePerformance = StoragePerformance.Fastest

                    Using tree As var = New BPlusTree(Of Integer, String)(options)
                        Using copy As var = New BPlusTree(Of Integer, String)(readcopy)
                            Using tlog As var = New TransactionLog(Of Integer, String)(New TransactionLogOptions(Of Integer, String)(logfile.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String]) With { _
                                Key .[ReadOnly] = True _
                            })
                                tree.Add(0, "0")
                                tree.Commit()

                                Dim logpos As Long = 0
                                copy.EnableCount()
                                'start by copying the data from tree's file into the copy instance:
                                copy.BulkInsert(BPlusTree(Of Integer, String).EnumerateFile(options), New BulkInsertOptions() With { _
                                    Key .InputIsSorted = True, _
                                    Key .CommitOnCompletion = False, _
                                    Key .ReplaceContents = True _
                                })

                                Assert.AreEqual(1, copy.Count)
                                Assert.AreEqual("0", copy(0))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1, copy.Count)

                                'insert some data...
                                tree.AddRange(MakeValues(1, 99))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(100, copy.Count)

                                'insert some data...
                                Dim i As Integer = 0
                                While i &lt; 100
                                    tree.Remove(i)
                                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                                End While
                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(0, copy.Count)

                                tree.AddRange(MakeValues(1000, 1000))

                                tlog.ReplayLog(copy, logpos)
                                Assert.AreEqual(1000, copy.Count)
                            End Using
                        End Using
                    End Using
                End Using
            End Using
        End Using</code></example></member>
        <member name="T:CSharpTest.Net.Collections.TransactionToken">
            <summary>
            A value representing the state/identifer/object of a single transaction.  The field's
            meaning is defined by the ITrasactionLog implementation and is otherwise treated as an
            opaque token identifier of the transaction.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.ITransactionLog`2.BeginTransaction">TransactionToken ITransactionLog&lt;TKey,TValue&gt;.BeginTransaction()</seealso><seealso cref="M:CSharpTest.Net.Collections.ITransactionLog`2.AddValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)">ITransactionLog&lt;TKey,TValue&gt;.AddValue(TransactionToken,TKey,TValue)</seealso><seealso cref="M:CSharpTest.Net.Collections.ITransactionLog`2.UpdateValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)">ITransactionLog&lt;TKey,TValue&gt;.UpdateValue(TransactionToken,TKey,TValue)</seealso><seealso cref="M:CSharpTest.Net.Collections.ITransactionLog`2.RemoveValue(CSharpTest.Net.Collections.TransactionToken@,`0)">ITransactionLog&lt;TKey,TValue&gt;.RemoveValue(TransactionToken,TKey)</seealso><seealso cref="M:CSharpTest.Net.Collections.ITransactionLog`2.CommitTransaction(CSharpTest.Net.Collections.TransactionToken@)">ITransactionLog&lt;TKey,TValue&gt;.CommitTransaction(TransactionToken)</seealso><seealso cref="M:CSharpTest.Net.Collections.ITransactionLog`2.RollbackTransaction(CSharpTest.Net.Collections.TransactionToken@)">ITransactionLog&lt;TKey,TValue&gt;.RollbackTransaction(TransactionToken)</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.BeginTransaction" cat="Used By">TransactionToken TransactionLog&lt;TKey,TValue&gt;.BeginTransaction()</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.AddValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)">TransactionLog&lt;TKey,TValue&gt;.AddValue(TransactionToken,TKey,TValue)</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.UpdateValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)">TransactionLog&lt;TKey,TValue&gt;.UpdateValue(TransactionToken,TKey,TValue)</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.RemoveValue(CSharpTest.Net.Collections.TransactionToken@,`0)">TransactionLog&lt;TKey,TValue&gt;.RemoveValue(TransactionToken,TKey)</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.CommitTransaction(CSharpTest.Net.Collections.TransactionToken@)">TransactionLog&lt;TKey,TValue&gt;.CommitTransaction(TransactionToken)</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.RollbackTransaction(CSharpTest.Net.Collections.TransactionToken@)">TransactionLog&lt;TKey,TValue&gt;.RollbackTransaction(TransactionToken)</seealso></member>
        <member name="F:CSharpTest.Net.Collections.TransactionToken.State">
            <summary> Undefined </summary>
        <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.BeginTransaction" cat="Used By">TransactionToken TransactionLog&lt;TKey,TValue&gt;.BeginTransaction()</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.CommitTransaction(CSharpTest.Net.Collections.TransactionToken@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.CommitTransaction(TransactionToken)</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.RollbackTransaction(CSharpTest.Net.Collections.TransactionToken@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.RollbackTransaction(TransactionToken)</seealso></member>
        <member name="F:CSharpTest.Net.Collections.TransactionToken.Handle">
            <summary> Undefined </summary>
        <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.BeginTransaction" cat="Used By">TransactionToken TransactionLog&lt;TKey,TValue&gt;.BeginTransaction()</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.RollbackTransaction(CSharpTest.Net.Collections.TransactionToken@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.RollbackTransaction(TransactionToken)</seealso></member>
        <member name="F:CSharpTest.Net.Collections.TransactionToken.Object">
            <summary> Undefined </summary>
        <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.CommitTransaction(CSharpTest.Net.Collections.TransactionToken@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.CommitTransaction(TransactionToken)</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.RollbackTransaction(CSharpTest.Net.Collections.TransactionToken@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.RollbackTransaction(TransactionToken)</seealso></member>
        <member name="T:CSharpTest.Net.Collections.TransactionLogOptions`2">
            <summary>
            Options used to initialize a TransactionLog
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#173">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            //Write 2,147,483,776 bytes in: 00:02:09.7934237 (in chunks of 128 bytes)
            //Write 4,295,032,832 bytes in: 00:00:18.4990581 (in chunks of 65536 bytes)
            //Logged 2,398,000,000 bytes in: 00:00:36.7621027


            string newpath = Path.Combine(@"C:\Temp\LogTest\", Guid.NewGuid() + ".tmp");
            using (TempFile tmp = TempFile.Attach(newpath))
            {
                byte[] bytes;
                DateTime start;
                //bytes = new byte[128];
                //new Random().NextBytes(bytes);

                //start = DateTime.UtcNow;
                //using (var io = new FileStream(tmp.TempPath, FileMode.Append, FileAccess.Write, FileShare.Read, 8))
                //{
                //    for (int i = 0; i &lt;= 16777216; i++)
                //        io.Write(bytes, 0, 128);
                //}
                //Console.WriteLine("Write {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
                //tmp.Delete();

                var options = new TransactionLogOptions&lt;Guid, byte[]&gt;(
                    tmp.TempPath, PrimitiveSerializer.Guid, PrimitiveSerializer.Bytes) 
                    {
                        FileBuffer = ushort.MaxValue,
                        FileOptions = FileOptions.None | FileOptions.SequentialScan,
                    };

                Guid[] ids = new Guid[1000000];
                for (int i = 0; i &lt; ids.Length; i++)
                    ids[i] = Guid.NewGuid();

                bytes = new byte[100];
                new Random().NextBytes(bytes);

                start = DateTime.UtcNow;

                using (var log = new TransactionLog&lt;Guid, byte[]&gt;(options))
                {
                    foreach(Guid id in ids)
                    {
                        var token = log.BeginTransaction();
                        for (int i = 0; i &lt; 20; i++)
                            log.AddValue(ref token, id, bytes);
                        log.CommitTransaction(ref token);
                    }
                }

                Console.WriteLine("Logged {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
            }</code><code lang="VB.NET">        'Write 2,147,483,776 bytes in: 00:02:09.7934237 (in chunks of 128 bytes)
        'Write 4,295,032,832 bytes in: 00:00:18.4990581 (in chunks of 65536 bytes)
        'Logged 2,398,000,000 bytes in: 00:00:36.7621027


        Dim newpath As String = Path.Combine("C:\Temp\LogTest\", Guid.NewGuid() + ".tmp")
        Using tmp As TempFile = TempFile.Attach(newpath)
            Dim bytes As Byte()
            Dim start As DateTime
            'bytes = new byte[128];
            'new Random().NextBytes(bytes);

            'start = DateTime.UtcNow;
            'using (var io = new FileStream(tmp.TempPath, FileMode.Append, FileAccess.Write, FileShare.Read, 8))
            '{
            '    for (int i = 0; i &lt;= 16777216; i++)
            '        io.Write(bytes, 0, 128);
            '}
            'Console.WriteLine("Write {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
            'tmp.Delete();

            Dim options As var = New TransactionLogOptions(Of Guid, Byte())(tmp.TempPath, PrimitiveSerializer.Guid, PrimitiveSerializer.Bytes) With { _
                Key .FileBuffer = UShort.MaxValue, _
                Key .FileOptions = FileOptions.None Or FileOptions.SequentialScan _
            }

            Dim ids As Guid() = New Guid(1000000) {}
            Dim i As Integer = 0
            While i &lt; ids.Length
                ids(i) = Guid.NewGuid()
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            bytes = New Byte(100) {}
            New Random().NextBytes(bytes)

            start = DateTime.UtcNow

            Using log As var = New TransactionLog(Of Guid, Byte())(options)
                For Each id As Guid In ids
                    Dim token As var = log.BeginTransaction()
                    Dim i As Integer = 0
                    While i &lt; 20
                        log.AddValue(token, id, bytes)
                        System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                    End While
                    log.CommitTransaction(token)
                Next
            End Using

            Console.WriteLine("Logged {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start)
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLogOptions`2.#ctor(System.String,CSharpTest.Net.Serialization.ISerializer{`0},CSharpTest.Net.Serialization.ISerializer{`1})">
            <summary>
            Options used to initialize a TransactionLog
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#52" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#173">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            //Write 2,147,483,776 bytes in: 00:02:09.7934237 (in chunks of 128 bytes)
            //Write 4,295,032,832 bytes in: 00:00:18.4990581 (in chunks of 65536 bytes)
            //Logged 2,398,000,000 bytes in: 00:00:36.7621027


            string newpath = Path.Combine(@"C:\Temp\LogTest\", Guid.NewGuid() + ".tmp");
            using (TempFile tmp = TempFile.Attach(newpath))
            {
                byte[] bytes;
                DateTime start;
                //bytes = new byte[128];
                //new Random().NextBytes(bytes);

                //start = DateTime.UtcNow;
                //using (var io = new FileStream(tmp.TempPath, FileMode.Append, FileAccess.Write, FileShare.Read, 8))
                //{
                //    for (int i = 0; i &lt;= 16777216; i++)
                //        io.Write(bytes, 0, 128);
                //}
                //Console.WriteLine("Write {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
                //tmp.Delete();

                var options = new TransactionLogOptions&lt;Guid, byte[]&gt;(
                    tmp.TempPath, PrimitiveSerializer.Guid, PrimitiveSerializer.Bytes) 
                    {
                        FileBuffer = ushort.MaxValue,
                        FileOptions = FileOptions.None | FileOptions.SequentialScan,
                    };

                Guid[] ids = new Guid[1000000];
                for (int i = 0; i &lt; ids.Length; i++)
                    ids[i] = Guid.NewGuid();

                bytes = new byte[100];
                new Random().NextBytes(bytes);

                start = DateTime.UtcNow;

                using (var log = new TransactionLog&lt;Guid, byte[]&gt;(options))
                {
                    foreach(Guid id in ids)
                    {
                        var token = log.BeginTransaction();
                        for (int i = 0; i &lt; 20; i++)
                            log.AddValue(ref token, id, bytes);
                        log.CommitTransaction(ref token);
                    }
                }

                Console.WriteLine("Logged {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
            }</code><code lang="VB.NET">        'Write 2,147,483,776 bytes in: 00:02:09.7934237 (in chunks of 128 bytes)
        'Write 4,295,032,832 bytes in: 00:00:18.4990581 (in chunks of 65536 bytes)
        'Logged 2,398,000,000 bytes in: 00:00:36.7621027


        Dim newpath As String = Path.Combine("C:\Temp\LogTest\", Guid.NewGuid() + ".tmp")
        Using tmp As TempFile = TempFile.Attach(newpath)
            Dim bytes As Byte()
            Dim start As DateTime
            'bytes = new byte[128];
            'new Random().NextBytes(bytes);

            'start = DateTime.UtcNow;
            'using (var io = new FileStream(tmp.TempPath, FileMode.Append, FileAccess.Write, FileShare.Read, 8))
            '{
            '    for (int i = 0; i &lt;= 16777216; i++)
            '        io.Write(bytes, 0, 128);
            '}
            'Console.WriteLine("Write {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
            'tmp.Delete();

            Dim options As var = New TransactionLogOptions(Of Guid, Byte())(tmp.TempPath, PrimitiveSerializer.Guid, PrimitiveSerializer.Bytes) With { _
                Key .FileBuffer = UShort.MaxValue, _
                Key .FileOptions = FileOptions.None Or FileOptions.SequentialScan _
            }

            Dim ids As Guid() = New Guid(1000000) {}
            Dim i As Integer = 0
            While i &lt; ids.Length
                ids(i) = Guid.NewGuid()
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            bytes = New Byte(100) {}
            New Random().NextBytes(bytes)

            start = DateTime.UtcNow

            Using log As var = New TransactionLog(Of Guid, Byte())(options)
                For Each id As Guid In ids
                    Dim token As var = log.BeginTransaction()
                    Dim i As Integer = 0
                    While i &lt; 20
                        log.AddValue(token, id, bytes)
                        System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                    End While
                    log.CommitTransaction(token)
                Next
            End Using

            Console.WriteLine("Logged {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start)
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLogOptions`2.Clone">
            <summary> Creates a shallow clone of the instance </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#77" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#39">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile temp = new TempFile())
            {
                temp.Delete();
                var opt = new TransactionLogOptions&lt;int, string&gt;(temp.TempPath,
                                                              PrimitiveSerializer.Int32,
                                                              PrimitiveSerializer.String);
                //FileName
                Assert.AreEqual(temp.TempPath, opt.FileName);
                //Key/Value serializers
                Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32));
                Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.String));
                //FileOptions
                Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions);
                Assert.AreEqual(FileOptions.WriteThrough | FileOptions.Asynchronous, opt.FileOptions |= FileOptions.Asynchronous);
                //Read Only
                Assert.AreEqual(false, opt.ReadOnly);
                Assert.AreEqual(true, opt.ReadOnly = true);
                //File Buffer
                Assert.AreEqual(8, opt.FileBuffer);
                Assert.AreEqual(0x40000, opt.FileBuffer = 0x40000);
                //Clone
                Assert.IsFalse(ReferenceEquals(opt, opt.Clone()));

                using(TransactionLog&lt;int, string&gt; log = new TransactionLog&lt;int,string&gt;(opt))
                    Assert.AreEqual(0, log.Size);
            }</code><code lang="VB.NET">        Using temp As New TempFile()
            temp.Delete()
            Dim opt As var = New TransactionLogOptions(Of Integer, String)(temp.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String])
            'FileName
            Assert.AreEqual(temp.TempPath, opt.FileName)
            'Key/Value serializers
            Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32))
            Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.[String]))
            'FileOptions
            Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions)
            Assert.AreEqual(FileOptions.WriteThrough Or FileOptions.Asynchronous, opt.FileOptions = opt.FileOptions Or FileOptions.Asynchronous)
            'Read Only
            Assert.AreEqual(False, opt.[ReadOnly])
            Assert.AreEqual(True, opt.[ReadOnly] = True)
            'File Buffer
            Assert.AreEqual(8, opt.FileBuffer)
            Assert.AreEqual(&amp;H40000, opt.FileBuffer = &amp;H40000)
            'Clone
            Assert.IsFalse(ReferenceEquals(opt, opt.Clone()))

            Using log As New TransactionLog(Of Integer, String)(opt)
                Assert.AreEqual(0, log.Size)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.TransactionLogOptions`2.KeySerializer">
            <summary> The serializer for the TKey type </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#62" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><seealso cref="T:CSharpTest.Net.Serialization.ISerializer{`0}">ISerializer&lt;TKey&gt;</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#39">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile temp = new TempFile())
            {
                temp.Delete();
                var opt = new TransactionLogOptions&lt;int, string&gt;(temp.TempPath,
                                                              PrimitiveSerializer.Int32,
                                                              PrimitiveSerializer.String);
                //FileName
                Assert.AreEqual(temp.TempPath, opt.FileName);
                //Key/Value serializers
                Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32));
                Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.String));
                //FileOptions
                Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions);
                Assert.AreEqual(FileOptions.WriteThrough | FileOptions.Asynchronous, opt.FileOptions |= FileOptions.Asynchronous);
                //Read Only
                Assert.AreEqual(false, opt.ReadOnly);
                Assert.AreEqual(true, opt.ReadOnly = true);
                //File Buffer
                Assert.AreEqual(8, opt.FileBuffer);
                Assert.AreEqual(0x40000, opt.FileBuffer = 0x40000);
                //Clone
                Assert.IsFalse(ReferenceEquals(opt, opt.Clone()));

                using(TransactionLog&lt;int, string&gt; log = new TransactionLog&lt;int,string&gt;(opt))
                    Assert.AreEqual(0, log.Size);
            }</code><code lang="VB.NET">        Using temp As New TempFile()
            temp.Delete()
            Dim opt As var = New TransactionLogOptions(Of Integer, String)(temp.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String])
            'FileName
            Assert.AreEqual(temp.TempPath, opt.FileName)
            'Key/Value serializers
            Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32))
            Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.[String]))
            'FileOptions
            Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions)
            Assert.AreEqual(FileOptions.WriteThrough Or FileOptions.Asynchronous, opt.FileOptions = opt.FileOptions Or FileOptions.Asynchronous)
            'Read Only
            Assert.AreEqual(False, opt.[ReadOnly])
            Assert.AreEqual(True, opt.[ReadOnly] = True)
            'File Buffer
            Assert.AreEqual(8, opt.FileBuffer)
            Assert.AreEqual(&amp;H40000, opt.FileBuffer = &amp;H40000)
            'Clone
            Assert.IsFalse(ReferenceEquals(opt, opt.Clone()))

            Using log As New TransactionLog(Of Integer, String)(opt)
                Assert.AreEqual(0, log.Size)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.TransactionLogOptions`2.ValueSerializer">
            <summary> The serializer for the TValue type </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#64" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><seealso cref="T:CSharpTest.Net.Serialization.ISerializer{`1}">ISerializer&lt;TValue&gt;</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#39">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile temp = new TempFile())
            {
                temp.Delete();
                var opt = new TransactionLogOptions&lt;int, string&gt;(temp.TempPath,
                                                              PrimitiveSerializer.Int32,
                                                              PrimitiveSerializer.String);
                //FileName
                Assert.AreEqual(temp.TempPath, opt.FileName);
                //Key/Value serializers
                Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32));
                Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.String));
                //FileOptions
                Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions);
                Assert.AreEqual(FileOptions.WriteThrough | FileOptions.Asynchronous, opt.FileOptions |= FileOptions.Asynchronous);
                //Read Only
                Assert.AreEqual(false, opt.ReadOnly);
                Assert.AreEqual(true, opt.ReadOnly = true);
                //File Buffer
                Assert.AreEqual(8, opt.FileBuffer);
                Assert.AreEqual(0x40000, opt.FileBuffer = 0x40000);
                //Clone
                Assert.IsFalse(ReferenceEquals(opt, opt.Clone()));

                using(TransactionLog&lt;int, string&gt; log = new TransactionLog&lt;int,string&gt;(opt))
                    Assert.AreEqual(0, log.Size);
            }</code><code lang="VB.NET">        Using temp As New TempFile()
            temp.Delete()
            Dim opt As var = New TransactionLogOptions(Of Integer, String)(temp.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String])
            'FileName
            Assert.AreEqual(temp.TempPath, opt.FileName)
            'Key/Value serializers
            Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32))
            Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.[String]))
            'FileOptions
            Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions)
            Assert.AreEqual(FileOptions.WriteThrough Or FileOptions.Asynchronous, opt.FileOptions = opt.FileOptions Or FileOptions.Asynchronous)
            'Read Only
            Assert.AreEqual(False, opt.[ReadOnly])
            Assert.AreEqual(True, opt.[ReadOnly] = True)
            'File Buffer
            Assert.AreEqual(8, opt.FileBuffer)
            Assert.AreEqual(&amp;H40000, opt.FileBuffer = &amp;H40000)
            'Clone
            Assert.IsFalse(ReferenceEquals(opt, opt.Clone()))

            Using log As New TransactionLog(Of Integer, String)(opt)
                Assert.AreEqual(0, log.Size)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.TransactionLogOptions`2.FileName">
            <summary> The file name to read/write the log </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#67" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.Close" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.Close()</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#39">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile temp = new TempFile())
            {
                temp.Delete();
                var opt = new TransactionLogOptions&lt;int, string&gt;(temp.TempPath,
                                                              PrimitiveSerializer.Int32,
                                                              PrimitiveSerializer.String);
                //FileName
                Assert.AreEqual(temp.TempPath, opt.FileName);
                //Key/Value serializers
                Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32));
                Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.String));
                //FileOptions
                Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions);
                Assert.AreEqual(FileOptions.WriteThrough | FileOptions.Asynchronous, opt.FileOptions |= FileOptions.Asynchronous);
                //Read Only
                Assert.AreEqual(false, opt.ReadOnly);
                Assert.AreEqual(true, opt.ReadOnly = true);
                //File Buffer
                Assert.AreEqual(8, opt.FileBuffer);
                Assert.AreEqual(0x40000, opt.FileBuffer = 0x40000);
                //Clone
                Assert.IsFalse(ReferenceEquals(opt, opt.Clone()));

                using(TransactionLog&lt;int, string&gt; log = new TransactionLog&lt;int,string&gt;(opt))
                    Assert.AreEqual(0, log.Size);
            }</code><code lang="VB.NET">        Using temp As New TempFile()
            temp.Delete()
            Dim opt As var = New TransactionLogOptions(Of Integer, String)(temp.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String])
            'FileName
            Assert.AreEqual(temp.TempPath, opt.FileName)
            'Key/Value serializers
            Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32))
            Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.[String]))
            'FileOptions
            Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions)
            Assert.AreEqual(FileOptions.WriteThrough Or FileOptions.Asynchronous, opt.FileOptions = opt.FileOptions Or FileOptions.Asynchronous)
            'Read Only
            Assert.AreEqual(False, opt.[ReadOnly])
            Assert.AreEqual(True, opt.[ReadOnly] = True)
            'File Buffer
            Assert.AreEqual(8, opt.FileBuffer)
            Assert.AreEqual(&amp;H40000, opt.FileBuffer = &amp;H40000)
            'Clone
            Assert.IsFalse(ReferenceEquals(opt, opt.Clone()))

            Using log As New TransactionLog(Of Integer, String)(opt)
                Assert.AreEqual(0, log.Size)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.TransactionLogOptions`2.FileOptions">
            <summary> The file open options for appending to a log, default = WriteThrough </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#69" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#173">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            //Write 2,147,483,776 bytes in: 00:02:09.7934237 (in chunks of 128 bytes)
            //Write 4,295,032,832 bytes in: 00:00:18.4990581 (in chunks of 65536 bytes)
            //Logged 2,398,000,000 bytes in: 00:00:36.7621027


            string newpath = Path.Combine(@"C:\Temp\LogTest\", Guid.NewGuid() + ".tmp");
            using (TempFile tmp = TempFile.Attach(newpath))
            {
                byte[] bytes;
                DateTime start;
                //bytes = new byte[128];
                //new Random().NextBytes(bytes);

                //start = DateTime.UtcNow;
                //using (var io = new FileStream(tmp.TempPath, FileMode.Append, FileAccess.Write, FileShare.Read, 8))
                //{
                //    for (int i = 0; i &lt;= 16777216; i++)
                //        io.Write(bytes, 0, 128);
                //}
                //Console.WriteLine("Write {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
                //tmp.Delete();

                var options = new TransactionLogOptions&lt;Guid, byte[]&gt;(
                    tmp.TempPath, PrimitiveSerializer.Guid, PrimitiveSerializer.Bytes) 
                    {
                        FileBuffer = ushort.MaxValue,
                        FileOptions = FileOptions.None | FileOptions.SequentialScan,
                    };

                Guid[] ids = new Guid[1000000];
                for (int i = 0; i &lt; ids.Length; i++)
                    ids[i] = Guid.NewGuid();

                bytes = new byte[100];
                new Random().NextBytes(bytes);

                start = DateTime.UtcNow;

                using (var log = new TransactionLog&lt;Guid, byte[]&gt;(options))
                {
                    foreach(Guid id in ids)
                    {
                        var token = log.BeginTransaction();
                        for (int i = 0; i &lt; 20; i++)
                            log.AddValue(ref token, id, bytes);
                        log.CommitTransaction(ref token);
                    }
                }

                Console.WriteLine("Logged {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
            }</code><code lang="VB.NET">        'Write 2,147,483,776 bytes in: 00:02:09.7934237 (in chunks of 128 bytes)
        'Write 4,295,032,832 bytes in: 00:00:18.4990581 (in chunks of 65536 bytes)
        'Logged 2,398,000,000 bytes in: 00:00:36.7621027


        Dim newpath As String = Path.Combine("C:\Temp\LogTest\", Guid.NewGuid() + ".tmp")
        Using tmp As TempFile = TempFile.Attach(newpath)
            Dim bytes As Byte()
            Dim start As DateTime
            'bytes = new byte[128];
            'new Random().NextBytes(bytes);

            'start = DateTime.UtcNow;
            'using (var io = new FileStream(tmp.TempPath, FileMode.Append, FileAccess.Write, FileShare.Read, 8))
            '{
            '    for (int i = 0; i &lt;= 16777216; i++)
            '        io.Write(bytes, 0, 128);
            '}
            'Console.WriteLine("Write {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
            'tmp.Delete();

            Dim options As var = New TransactionLogOptions(Of Guid, Byte())(tmp.TempPath, PrimitiveSerializer.Guid, PrimitiveSerializer.Bytes) With { _
                Key .FileBuffer = UShort.MaxValue, _
                Key .FileOptions = FileOptions.None Or FileOptions.SequentialScan _
            }

            Dim ids As Guid() = New Guid(1000000) {}
            Dim i As Integer = 0
            While i &lt; ids.Length
                ids(i) = Guid.NewGuid()
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            bytes = New Byte(100) {}
            New Random().NextBytes(bytes)

            start = DateTime.UtcNow

            Using log As var = New TransactionLog(Of Guid, Byte())(options)
                For Each id As Guid In ids
                    Dim token As var = log.BeginTransaction()
                    Dim i As Integer = 0
                    While i &lt; 20
                        log.AddValue(token, id, bytes)
                        System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                    End While
                    log.CommitTransaction(token)
                Next
            End Using

            Console.WriteLine("Logged {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.TransactionLogOptions`2.FileBuffer">
            <summary> The file buffer size, CAUTION: values above 16 bytes may leave data in memory </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#71" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#173">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            //Write 2,147,483,776 bytes in: 00:02:09.7934237 (in chunks of 128 bytes)
            //Write 4,295,032,832 bytes in: 00:00:18.4990581 (in chunks of 65536 bytes)
            //Logged 2,398,000,000 bytes in: 00:00:36.7621027


            string newpath = Path.Combine(@"C:\Temp\LogTest\", Guid.NewGuid() + ".tmp");
            using (TempFile tmp = TempFile.Attach(newpath))
            {
                byte[] bytes;
                DateTime start;
                //bytes = new byte[128];
                //new Random().NextBytes(bytes);

                //start = DateTime.UtcNow;
                //using (var io = new FileStream(tmp.TempPath, FileMode.Append, FileAccess.Write, FileShare.Read, 8))
                //{
                //    for (int i = 0; i &lt;= 16777216; i++)
                //        io.Write(bytes, 0, 128);
                //}
                //Console.WriteLine("Write {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
                //tmp.Delete();

                var options = new TransactionLogOptions&lt;Guid, byte[]&gt;(
                    tmp.TempPath, PrimitiveSerializer.Guid, PrimitiveSerializer.Bytes) 
                    {
                        FileBuffer = ushort.MaxValue,
                        FileOptions = FileOptions.None | FileOptions.SequentialScan,
                    };

                Guid[] ids = new Guid[1000000];
                for (int i = 0; i &lt; ids.Length; i++)
                    ids[i] = Guid.NewGuid();

                bytes = new byte[100];
                new Random().NextBytes(bytes);

                start = DateTime.UtcNow;

                using (var log = new TransactionLog&lt;Guid, byte[]&gt;(options))
                {
                    foreach(Guid id in ids)
                    {
                        var token = log.BeginTransaction();
                        for (int i = 0; i &lt; 20; i++)
                            log.AddValue(ref token, id, bytes);
                        log.CommitTransaction(ref token);
                    }
                }

                Console.WriteLine("Logged {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
            }</code><code lang="VB.NET">        'Write 2,147,483,776 bytes in: 00:02:09.7934237 (in chunks of 128 bytes)
        'Write 4,295,032,832 bytes in: 00:00:18.4990581 (in chunks of 65536 bytes)
        'Logged 2,398,000,000 bytes in: 00:00:36.7621027


        Dim newpath As String = Path.Combine("C:\Temp\LogTest\", Guid.NewGuid() + ".tmp")
        Using tmp As TempFile = TempFile.Attach(newpath)
            Dim bytes As Byte()
            Dim start As DateTime
            'bytes = new byte[128];
            'new Random().NextBytes(bytes);

            'start = DateTime.UtcNow;
            'using (var io = new FileStream(tmp.TempPath, FileMode.Append, FileAccess.Write, FileShare.Read, 8))
            '{
            '    for (int i = 0; i &lt;= 16777216; i++)
            '        io.Write(bytes, 0, 128);
            '}
            'Console.WriteLine("Write {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start);
            'tmp.Delete();

            Dim options As var = New TransactionLogOptions(Of Guid, Byte())(tmp.TempPath, PrimitiveSerializer.Guid, PrimitiveSerializer.Bytes) With { _
                Key .FileBuffer = UShort.MaxValue, _
                Key .FileOptions = FileOptions.None Or FileOptions.SequentialScan _
            }

            Dim ids As Guid() = New Guid(1000000) {}
            Dim i As Integer = 0
            While i &lt; ids.Length
                ids(i) = Guid.NewGuid()
                System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
            End While

            bytes = New Byte(100) {}
            New Random().NextBytes(bytes)

            start = DateTime.UtcNow

            Using log As var = New TransactionLog(Of Guid, Byte())(options)
                For Each id As Guid In ids
                    Dim token As var = log.BeginTransaction()
                    Dim i As Integer = 0
                    While i &lt; 20
                        log.AddValue(token, id, bytes)
                        System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                    End While
                    log.CommitTransaction(token)
                Next
            End Using

            Console.WriteLine("Logged {0:n0} bytes in: {1}", tmp.Length, DateTime.UtcNow - start)
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.TransactionLogOptions`2.ReadOnly">
            <summary> Gets or sets if the transaction log is treated as read-only </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#73" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#39">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile temp = new TempFile())
            {
                temp.Delete();
                var opt = new TransactionLogOptions&lt;int, string&gt;(temp.TempPath,
                                                              PrimitiveSerializer.Int32,
                                                              PrimitiveSerializer.String);
                //FileName
                Assert.AreEqual(temp.TempPath, opt.FileName);
                //Key/Value serializers
                Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32));
                Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.String));
                //FileOptions
                Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions);
                Assert.AreEqual(FileOptions.WriteThrough | FileOptions.Asynchronous, opt.FileOptions |= FileOptions.Asynchronous);
                //Read Only
                Assert.AreEqual(false, opt.ReadOnly);
                Assert.AreEqual(true, opt.ReadOnly = true);
                //File Buffer
                Assert.AreEqual(8, opt.FileBuffer);
                Assert.AreEqual(0x40000, opt.FileBuffer = 0x40000);
                //Clone
                Assert.IsFalse(ReferenceEquals(opt, opt.Clone()));

                using(TransactionLog&lt;int, string&gt; log = new TransactionLog&lt;int,string&gt;(opt))
                    Assert.AreEqual(0, log.Size);
            }</code><code lang="VB.NET">        Using temp As New TempFile()
            temp.Delete()
            Dim opt As var = New TransactionLogOptions(Of Integer, String)(temp.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String])
            'FileName
            Assert.AreEqual(temp.TempPath, opt.FileName)
            'Key/Value serializers
            Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32))
            Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.[String]))
            'FileOptions
            Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions)
            Assert.AreEqual(FileOptions.WriteThrough Or FileOptions.Asynchronous, opt.FileOptions = opt.FileOptions Or FileOptions.Asynchronous)
            'Read Only
            Assert.AreEqual(False, opt.[ReadOnly])
            Assert.AreEqual(True, opt.[ReadOnly] = True)
            'File Buffer
            Assert.AreEqual(8, opt.FileBuffer)
            Assert.AreEqual(&amp;H40000, opt.FileBuffer = &amp;H40000)
            'Clone
            Assert.IsFalse(ReferenceEquals(opt, opt.Clone()))

            Using log As New TransactionLog(Of Integer, String)(opt)
                Assert.AreEqual(0, log.Size)
            End Using
        End Using</code></example></member>
        <member name="T:CSharpTest.Net.Collections.ITransactionLog`2">
            <summary>
            Represents a transaction log of writes to a dictionary.
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.ReplayLog(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Replay the entire log file to the provided dictionary interface
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.ReplayLog(System.Collections.Generic.IDictionary{`0,`1},System.Int64@)">
            <summary>
            Replay the log file from the position provided and output the new log position
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.MergeLog(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Merges the contents of the log with an existing ordered key/value pair collection.
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.TruncateLog">
            <summary>
            Truncate the log and remove all existing entries
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso></member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.BeginTransaction">
            <summary>
            Notifies the log that a transaction is begining and create a token for this
            transaction scope.
            </summary>
        <seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso></member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.AddValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)">
            <summary> The provided key/value pair was added in the provided transaction </summary>
        <seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso></member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.UpdateValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)">
            <summary> The provided key/value pair was updated in the provided transaction </summary>
        <seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso></member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.RemoveValue(CSharpTest.Net.Collections.TransactionToken@,`0)">
            <summary> The provided key/value pair was removed in the provided transaction </summary>
        <seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso></member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.CommitTransaction(CSharpTest.Net.Collections.TransactionToken@)">
            <summary>
            Commits the provided transaction
            </summary>
        <seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso></member>
        <member name="M:CSharpTest.Net.Collections.ITransactionLog`2.RollbackTransaction(CSharpTest.Net.Collections.TransactionToken@)">
            <summary>
            Abandons the provided transaction
            </summary>
        <seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso></member>
        <member name="P:CSharpTest.Net.Collections.ITransactionLog`2.FileName">
            <summary>
            Returns the filename being currently used for transaction logging
            </summary>
        <example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestBackupAndRecovery.cs#75">BPlusTree/BPlusTree.Test/TestBackupAndRecovery.cs</see></para><code lang="C#">            using (TempFile savelog = new TempFile())
            using (TempFile temp = new TempFile())
            {
                var options = GetOptions(temp);
                options.FileBlockSize = 512;
                options.StoragePerformance = StoragePerformance.Fastest;
                options.CalcBTreeOrder(Marshal.SizeOf(typeof(Guid)), Marshal.SizeOf(typeof(TestInfo)));
                options.TransactionLog = new TransactionLog&lt;Guid, TestInfo&gt;(
                    new TransactionLogOptions&lt;Guid, TestInfo&gt;(
                        options.TransactionLogFileName,
                        options.KeySerializer,
                        options.ValueSerializer
                        )
                    );

                //Now recover...
                Dictionary&lt;Guid, TestInfo&gt; first = new Dictionary&lt;Guid, TestInfo&gt;();
                Dictionary&lt;Guid, TestInfo&gt; sample;

                using (var tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    tree.EnableCount();
                    Insert(tree, first, 1, 100, TimeSpan.FromMinutes(1));
                    tree.Commit();

                    Assert.AreEqual(100, tree.Count);

                    sample = new Dictionary&lt;Guid, TestInfo&gt;(first);
                    Insert(tree, sample, 7, 5000, TimeSpan.FromMinutes(1));

                    Assert.AreEqual(35100, tree.Count);

                    for (int i = 0; i &lt; 1; i++)
                    {
                        foreach (var rec in tree)
                        {
                            var value = rec.Value;
                            value.UpdateCount++;
                            value.ReadCount++;
                            tree[rec.Key] = value;
                        }
                    }
                    
                    File.Copy(options.TransactionLog.FileName, savelog.TempPath, true);
                    tree.Rollback();

                    TestInfo.AssertEquals(first, tree);
                }

                //file still has initial committed data
                TestInfo.AssertEquals(first, BPlusTree&lt;Guid, TestInfo&gt;.EnumerateFile(options));

                //restore the log and verify all data.
                File.Copy(savelog.TempPath, options.TransactionLog.FileName, true);
                using (var tree = new BPlusTree&lt;Guid, TestInfo&gt;(options))
                {
                    TestInfo.AssertEquals(sample, tree);
                }

                //file still has initial committed data
                TestInfo.AssertEquals(sample, BPlusTree&lt;Guid, TestInfo&gt;.EnumerateFile(options));
            }</code><code lang="VB.NET">        Using savelog As New TempFile()
            Using temp As New TempFile()
                Dim options As var = GetOptions(temp)
                options.FileBlockSize = 512
                options.StoragePerformance = StoragePerformance.Fastest
                options.CalcBTreeOrder(Marshal.SizeOf(GetType(Guid)), Marshal.SizeOf(GetType(TestInfo)))
                options.TransactionLog = New TransactionLog(Of Guid, TestInfo)(New TransactionLogOptions(Of Guid, TestInfo)(options.TransactionLogFileName, options.KeySerializer, options.ValueSerializer))

                'Now recover...
                Dim first As New Dictionary(Of Guid, TestInfo)()
                Dim sample As Dictionary(Of Guid, TestInfo)

                Using tree As var = New BPlusTree(Of Guid, TestInfo)(options)
                    tree.EnableCount()
                    Insert(tree, first, 1, 100, TimeSpan.FromMinutes(1))
                    tree.Commit()

                    Assert.AreEqual(100, tree.Count)

                    sample = New Dictionary(Of Guid, TestInfo)(first)
                    Insert(tree, sample, 7, 5000, TimeSpan.FromMinutes(1))

                    Assert.AreEqual(35100, tree.Count)

                    Dim i As Integer = 0
                    While i &lt; 1
                        For Each rec As var In tree
                            Dim value As var = rec.Value
                            System.Math.Max(System.Threading.Interlocked.Increment(value.UpdateCount),value.UpdateCount - 1)
                            System.Math.Max(System.Threading.Interlocked.Increment(value.ReadCount),value.ReadCount - 1)
                            tree(rec.Key) = value
                        Next
                        System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                    End While

                    File.Copy(options.TransactionLog.FileName, savelog.TempPath, True)
                    tree.Rollback()

                    TestInfo.AssertEquals(first, tree)
                End Using

                'file still has initial committed data
                TestInfo.AssertEquals(first, BPlusTree(Of Guid, TestInfo).EnumerateFile(options))

                'restore the log and verify all data.
                File.Copy(savelog.TempPath, options.TransactionLog.FileName, True)
                Using tree As var = New BPlusTree(Of Guid, TestInfo)(options)
                    TestInfo.AssertEquals(sample, tree)
                End Using

                'file still has initial committed data
                TestInfo.AssertEquals(sample, BPlusTree(Of Guid, TestInfo).EnumerateFile(options))
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.ITransactionLog`2.Size">
            <summary>
            Returns the current size of the log file in bytes
            </summary>
        </member>
        <member name="T:CSharpTest.Net.Collections.TransactionLog`2">
            <summary>
            The default transaction log for a BPlusTree instance to provide backup+log recovery
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#411">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            {
                using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                {
                    var token = log.BeginTransaction();
                    log.AddValue(ref token, 1, Guid.NewGuid().ToString());
                    log.CommitTransaction(ref token);
                    var test = new Dictionary&lt;int, string&gt;();
                    long offset = 0;
                    log.ReplayLog(test, ref offset);
                    Assert.AreEqual(1, test.Count);
                }
                byte[] bytes = tmp.ReadAllBytes();

                var TestVariants =
                    new Converter&lt;KeyValuePair&lt;int, byte[]&gt;, byte[]&gt;[]
                        {
                            kv =&gt; { kv.Value[kv.Key] ^= 0xff; return kv.Value; },
                            kv =&gt; { kv.Value[kv.Key] = 0xff; return kv.Value; },
                            kv =&gt; { byte[] b = kv.Value; Array.Resize(ref b, kv.Key); return b; },
                        };

                for (int corruptionIx = 0; corruptionIx &lt; bytes.Length; corruptionIx++)
                {
                    foreach (var testcase in TestVariants)
                    {
                        byte[] corrupt = testcase(new KeyValuePair&lt;int, byte[]&gt;(corruptionIx, (byte[]) bytes.Clone()));
                        tmp.WriteAllBytes(corrupt);

                        using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                        {
                            var test = new Dictionary&lt;int, string&gt;();
                            log.ReplayLog(test);
                            Assert.AreEqual(0, test.Count);
                        }
                        Assert.IsFalse(File.Exists(tmp.TempPath));
                    }
                }
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, Guid.NewGuid().ToString())
                log.CommitTransaction(token)
                Dim test As var = New Dictionary(Of Integer, String)()
                Dim offset As Long = 0
                log.ReplayLog(test, offset)
                Assert.AreEqual(1, test.Count)
            End Using
            Dim bytes As Byte() = tmp.ReadAllBytes()

            Dim TestVariants As var = New Converter(Of KeyValuePair(Of Integer, Byte()), Byte())() {Function(kv) 
            kv.Value(kv.Key) = kv.Value(kv.Key) Xor &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            kv.Value(kv.Key) = &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            Dim b As Byte() = kv.Value
            Array.Resize(b, kv.Key)
            Return b

End Function}

            Dim corruptionIx As Integer = 0
            While corruptionIx &lt; bytes.Length
                For Each testcase As var In TestVariants
                    Dim corrupt As Byte() = testcase(New KeyValuePair(Of Integer, Byte())(corruptionIx, DirectCast(bytes.Clone(), Byte())))
                    tmp.WriteAllBytes(corrupt)

                    Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                        Dim test As var = New Dictionary(Of Integer, String)()
                        log.ReplayLog(test)
                        Assert.AreEqual(0, test.Count)
                    End Using
                    Assert.IsFalse(File.Exists(tmp.TempPath))
                Next
                System.Math.Max(System.Threading.Interlocked.Increment(corruptionIx),corruptionIx - 1)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.#ctor(CSharpTest.Net.Collections.TransactionLogOptions{`0,`1})">
            <summary>
            Creates an instance of a transaction log
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#221" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#411">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            {
                using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                {
                    var token = log.BeginTransaction();
                    log.AddValue(ref token, 1, Guid.NewGuid().ToString());
                    log.CommitTransaction(ref token);
                    var test = new Dictionary&lt;int, string&gt;();
                    long offset = 0;
                    log.ReplayLog(test, ref offset);
                    Assert.AreEqual(1, test.Count);
                }
                byte[] bytes = tmp.ReadAllBytes();

                var TestVariants =
                    new Converter&lt;KeyValuePair&lt;int, byte[]&gt;, byte[]&gt;[]
                        {
                            kv =&gt; { kv.Value[kv.Key] ^= 0xff; return kv.Value; },
                            kv =&gt; { kv.Value[kv.Key] = 0xff; return kv.Value; },
                            kv =&gt; { byte[] b = kv.Value; Array.Resize(ref b, kv.Key); return b; },
                        };

                for (int corruptionIx = 0; corruptionIx &lt; bytes.Length; corruptionIx++)
                {
                    foreach (var testcase in TestVariants)
                    {
                        byte[] corrupt = testcase(new KeyValuePair&lt;int, byte[]&gt;(corruptionIx, (byte[]) bytes.Clone()));
                        tmp.WriteAllBytes(corrupt);

                        using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                        {
                            var test = new Dictionary&lt;int, string&gt;();
                            log.ReplayLog(test);
                            Assert.AreEqual(0, test.Count);
                        }
                        Assert.IsFalse(File.Exists(tmp.TempPath));
                    }
                }
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, Guid.NewGuid().ToString())
                log.CommitTransaction(token)
                Dim test As var = New Dictionary(Of Integer, String)()
                Dim offset As Long = 0
                log.ReplayLog(test, offset)
                Assert.AreEqual(1, test.Count)
            End Using
            Dim bytes As Byte() = tmp.ReadAllBytes()

            Dim TestVariants As var = New Converter(Of KeyValuePair(Of Integer, Byte()), Byte())() {Function(kv) 
            kv.Value(kv.Key) = kv.Value(kv.Key) Xor &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            kv.Value(kv.Key) = &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            Dim b As Byte() = kv.Value
            Array.Resize(b, kv.Key)
            Return b

End Function}

            Dim corruptionIx As Integer = 0
            While corruptionIx &lt; bytes.Length
                For Each testcase As var In TestVariants
                    Dim corrupt As Byte() = testcase(New KeyValuePair(Of Integer, Byte())(corruptionIx, DirectCast(bytes.Clone(), Byte())))
                    tmp.WriteAllBytes(corrupt)

                    Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                        Dim test As var = New Dictionary(Of Integer, String)()
                        log.ReplayLog(test)
                        Assert.AreEqual(0, test.Count)
                    End Using
                    Assert.IsFalse(File.Exists(tmp.TempPath))
                Next
                System.Math.Max(System.Threading.Interlocked.Increment(corruptionIx),corruptionIx - 1)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.Close">
            <summary>
            Flushes any pending writes and closes the writer.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#246" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#142">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">
            using (TempFile tmp = new TempFile())
            {
                var opts = Options(tmp);
                using (var log = new TransactionLog&lt;int, string&gt;(opts))
                {
                    var token = log.BeginTransaction();
                    log.AddValue(ref token, 1, "test");
                    log.CommitTransaction(ref token);
                    token = log.BeginTransaction();
                    log.AddValue(ref token, 2, "test");
                    log.CommitTransaction(ref token);
                    token = log.BeginTransaction();
                    log.AddValue(ref token, 3, "test");
                    log.CommitTransaction(ref token);
                    log.Close();
                }

                using (var log = new TransactionLog&lt;int, string&gt;(opts))
                {
                    var test = new Dictionary&lt;int, string&gt;();
                    log.ReplayLog(test);
                    Assert.AreEqual(3, test.Count);
                    for (int i = 1; i &lt;= 3; i++)
                        Assert.AreEqual("test", test[i]);
                }
            }</code><code lang="VB.NET">
        Using tmp As New TempFile()
            Dim opts As var = Options(tmp)
            Using log As var = New TransactionLog(Of Integer, String)(opts)
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, "test")
                log.CommitTransaction(token)
                token = log.BeginTransaction()
                log.AddValue(token, 2, "test")
                log.CommitTransaction(token)
                token = log.BeginTransaction()
                log.AddValue(token, 3, "test")
                log.CommitTransaction(token)
                log.Close()
            End Using

            Using log As var = New TransactionLog(Of Integer, String)(opts)
                Dim test As var = New Dictionary(Of Integer, String)()
                log.ReplayLog(test)
                Assert.AreEqual(3, test.Count)
                Dim i As Integer = 1
                While i &lt;= 3
                    Assert.AreEqual("test", test(i))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.ReplayLog(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            Replay the entire log file to the provided dictionary interface
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#277" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#411">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            {
                using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                {
                    var token = log.BeginTransaction();
                    log.AddValue(ref token, 1, Guid.NewGuid().ToString());
                    log.CommitTransaction(ref token);
                    var test = new Dictionary&lt;int, string&gt;();
                    long offset = 0;
                    log.ReplayLog(test, ref offset);
                    Assert.AreEqual(1, test.Count);
                }
                byte[] bytes = tmp.ReadAllBytes();

                var TestVariants =
                    new Converter&lt;KeyValuePair&lt;int, byte[]&gt;, byte[]&gt;[]
                        {
                            kv =&gt; { kv.Value[kv.Key] ^= 0xff; return kv.Value; },
                            kv =&gt; { kv.Value[kv.Key] = 0xff; return kv.Value; },
                            kv =&gt; { byte[] b = kv.Value; Array.Resize(ref b, kv.Key); return b; },
                        };

                for (int corruptionIx = 0; corruptionIx &lt; bytes.Length; corruptionIx++)
                {
                    foreach (var testcase in TestVariants)
                    {
                        byte[] corrupt = testcase(new KeyValuePair&lt;int, byte[]&gt;(corruptionIx, (byte[]) bytes.Clone()));
                        tmp.WriteAllBytes(corrupt);

                        using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                        {
                            var test = new Dictionary&lt;int, string&gt;();
                            log.ReplayLog(test);
                            Assert.AreEqual(0, test.Count);
                        }
                        Assert.IsFalse(File.Exists(tmp.TempPath));
                    }
                }
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, Guid.NewGuid().ToString())
                log.CommitTransaction(token)
                Dim test As var = New Dictionary(Of Integer, String)()
                Dim offset As Long = 0
                log.ReplayLog(test, offset)
                Assert.AreEqual(1, test.Count)
            End Using
            Dim bytes As Byte() = tmp.ReadAllBytes()

            Dim TestVariants As var = New Converter(Of KeyValuePair(Of Integer, Byte()), Byte())() {Function(kv) 
            kv.Value(kv.Key) = kv.Value(kv.Key) Xor &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            kv.Value(kv.Key) = &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            Dim b As Byte() = kv.Value
            Array.Resize(b, kv.Key)
            Return b

End Function}

            Dim corruptionIx As Integer = 0
            While corruptionIx &lt; bytes.Length
                For Each testcase As var In TestVariants
                    Dim corrupt As Byte() = testcase(New KeyValuePair(Of Integer, Byte())(corruptionIx, DirectCast(bytes.Clone(), Byte())))
                    tmp.WriteAllBytes(corrupt)

                    Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                        Dim test As var = New Dictionary(Of Integer, String)()
                        log.ReplayLog(test)
                        Assert.AreEqual(0, test.Count)
                    End Using
                    Assert.IsFalse(File.Exists(tmp.TempPath))
                Next
                System.Math.Max(System.Threading.Interlocked.Increment(corruptionIx),corruptionIx - 1)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.ReplayLog(System.Collections.Generic.IDictionary{`0,`1},System.Int64@)">
            <summary>
            Replay the log file from the position provided and output the new log position
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.ReplayLog(System.Collections.Generic.IDictionary{`0,`1})" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.ReplayLog(IDictionary&lt;TKey,TValue&gt;)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#285" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#411">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            {
                using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                {
                    var token = log.BeginTransaction();
                    log.AddValue(ref token, 1, Guid.NewGuid().ToString());
                    log.CommitTransaction(ref token);
                    var test = new Dictionary&lt;int, string&gt;();
                    long offset = 0;
                    log.ReplayLog(test, ref offset);
                    Assert.AreEqual(1, test.Count);
                }
                byte[] bytes = tmp.ReadAllBytes();

                var TestVariants =
                    new Converter&lt;KeyValuePair&lt;int, byte[]&gt;, byte[]&gt;[]
                        {
                            kv =&gt; { kv.Value[kv.Key] ^= 0xff; return kv.Value; },
                            kv =&gt; { kv.Value[kv.Key] = 0xff; return kv.Value; },
                            kv =&gt; { byte[] b = kv.Value; Array.Resize(ref b, kv.Key); return b; },
                        };

                for (int corruptionIx = 0; corruptionIx &lt; bytes.Length; corruptionIx++)
                {
                    foreach (var testcase in TestVariants)
                    {
                        byte[] corrupt = testcase(new KeyValuePair&lt;int, byte[]&gt;(corruptionIx, (byte[]) bytes.Clone()));
                        tmp.WriteAllBytes(corrupt);

                        using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                        {
                            var test = new Dictionary&lt;int, string&gt;();
                            log.ReplayLog(test);
                            Assert.AreEqual(0, test.Count);
                        }
                        Assert.IsFalse(File.Exists(tmp.TempPath));
                    }
                }
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, Guid.NewGuid().ToString())
                log.CommitTransaction(token)
                Dim test As var = New Dictionary(Of Integer, String)()
                Dim offset As Long = 0
                log.ReplayLog(test, offset)
                Assert.AreEqual(1, test.Count)
            End Using
            Dim bytes As Byte() = tmp.ReadAllBytes()

            Dim TestVariants As var = New Converter(Of KeyValuePair(Of Integer, Byte()), Byte())() {Function(kv) 
            kv.Value(kv.Key) = kv.Value(kv.Key) Xor &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            kv.Value(kv.Key) = &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            Dim b As Byte() = kv.Value
            Array.Resize(b, kv.Key)
            Return b

End Function}

            Dim corruptionIx As Integer = 0
            While corruptionIx &lt; bytes.Length
                For Each testcase As var In TestVariants
                    Dim corrupt As Byte() = testcase(New KeyValuePair(Of Integer, Byte())(corruptionIx, DirectCast(bytes.Clone(), Byte())))
                    tmp.WriteAllBytes(corrupt)

                    Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                        Dim test As var = New Dictionary(Of Integer, String)()
                        log.ReplayLog(test)
                        Assert.AreEqual(0, test.Count)
                    End Using
                    Assert.IsFalse(File.Exists(tmp.TempPath))
                Next
                System.Math.Max(System.Threading.Interlocked.Increment(corruptionIx),corruptionIx - 1)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.MergeLog(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Merges the contents of the log with an existing ordered key/value pair collection.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.EnumerateLog(System.Int64[])">
            <summary>
            Replay the log file from the position provided and output the new log position
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.ReplayLog(System.Collections.Generic.IDictionary{`0,`1},System.Int64@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.ReplayLog(IDictionary&lt;TKey,TValue&gt;,Int64)</seealso></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.TruncateLog">
            <summary>
            Truncate the log and remove all existing entries
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#450" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#343">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
            {
                var token = log.BeginTransaction();
                log.AddValue(ref token, 1, "test");
                log.CommitTransaction(ref token);

                var test = new Dictionary&lt;int, string&gt;();
                log.ReplayLog(test);

                Assert.AreEqual(1, test.Count);
                Assert.IsTrue(test.ContainsKey(1));
                Assert.AreEqual("test", test[1]);

                log.TruncateLog();
                test.Clear();
                log.ReplayLog(test);

                Assert.AreEqual(0, test.Count);
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, "test")
                log.CommitTransaction(token)

                Dim test As var = New Dictionary(Of Integer, String)()
                log.ReplayLog(test)

                Assert.AreEqual(1, test.Count)
                Assert.IsTrue(test.ContainsKey(1))
                Assert.AreEqual("test", test(1))

                log.TruncateLog()
                test.Clear()
                log.ReplayLog(test)

                Assert.AreEqual(0, test.Count)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.BeginTransaction">
            <summary>
            Notifies the log that a transaction is begining and create a token for this
            transaction scope.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#472" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#411">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            {
                using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                {
                    var token = log.BeginTransaction();
                    log.AddValue(ref token, 1, Guid.NewGuid().ToString());
                    log.CommitTransaction(ref token);
                    var test = new Dictionary&lt;int, string&gt;();
                    long offset = 0;
                    log.ReplayLog(test, ref offset);
                    Assert.AreEqual(1, test.Count);
                }
                byte[] bytes = tmp.ReadAllBytes();

                var TestVariants =
                    new Converter&lt;KeyValuePair&lt;int, byte[]&gt;, byte[]&gt;[]
                        {
                            kv =&gt; { kv.Value[kv.Key] ^= 0xff; return kv.Value; },
                            kv =&gt; { kv.Value[kv.Key] = 0xff; return kv.Value; },
                            kv =&gt; { byte[] b = kv.Value; Array.Resize(ref b, kv.Key); return b; },
                        };

                for (int corruptionIx = 0; corruptionIx &lt; bytes.Length; corruptionIx++)
                {
                    foreach (var testcase in TestVariants)
                    {
                        byte[] corrupt = testcase(new KeyValuePair&lt;int, byte[]&gt;(corruptionIx, (byte[]) bytes.Clone()));
                        tmp.WriteAllBytes(corrupt);

                        using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                        {
                            var test = new Dictionary&lt;int, string&gt;();
                            log.ReplayLog(test);
                            Assert.AreEqual(0, test.Count);
                        }
                        Assert.IsFalse(File.Exists(tmp.TempPath));
                    }
                }
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, Guid.NewGuid().ToString())
                log.CommitTransaction(token)
                Dim test As var = New Dictionary(Of Integer, String)()
                Dim offset As Long = 0
                log.ReplayLog(test, offset)
                Assert.AreEqual(1, test.Count)
            End Using
            Dim bytes As Byte() = tmp.ReadAllBytes()

            Dim TestVariants As var = New Converter(Of KeyValuePair(Of Integer, Byte()), Byte())() {Function(kv) 
            kv.Value(kv.Key) = kv.Value(kv.Key) Xor &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            kv.Value(kv.Key) = &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            Dim b As Byte() = kv.Value
            Array.Resize(b, kv.Key)
            Return b

End Function}

            Dim corruptionIx As Integer = 0
            While corruptionIx &lt; bytes.Length
                For Each testcase As var In TestVariants
                    Dim corrupt As Byte() = testcase(New KeyValuePair(Of Integer, Byte())(corruptionIx, DirectCast(bytes.Clone(), Byte())))
                    tmp.WriteAllBytes(corrupt)

                    Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                        Dim test As var = New Dictionary(Of Integer, String)()
                        log.ReplayLog(test)
                        Assert.AreEqual(0, test.Count)
                    End Using
                    Assert.IsFalse(File.Exists(tmp.TempPath))
                Next
                System.Math.Max(System.Threading.Interlocked.Increment(corruptionIx),corruptionIx - 1)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.AddValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)">
            <summary> The provided key/value pair was added in the provided transaction </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#482" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#411">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            {
                using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                {
                    var token = log.BeginTransaction();
                    log.AddValue(ref token, 1, Guid.NewGuid().ToString());
                    log.CommitTransaction(ref token);
                    var test = new Dictionary&lt;int, string&gt;();
                    long offset = 0;
                    log.ReplayLog(test, ref offset);
                    Assert.AreEqual(1, test.Count);
                }
                byte[] bytes = tmp.ReadAllBytes();

                var TestVariants =
                    new Converter&lt;KeyValuePair&lt;int, byte[]&gt;, byte[]&gt;[]
                        {
                            kv =&gt; { kv.Value[kv.Key] ^= 0xff; return kv.Value; },
                            kv =&gt; { kv.Value[kv.Key] = 0xff; return kv.Value; },
                            kv =&gt; { byte[] b = kv.Value; Array.Resize(ref b, kv.Key); return b; },
                        };

                for (int corruptionIx = 0; corruptionIx &lt; bytes.Length; corruptionIx++)
                {
                    foreach (var testcase in TestVariants)
                    {
                        byte[] corrupt = testcase(new KeyValuePair&lt;int, byte[]&gt;(corruptionIx, (byte[]) bytes.Clone()));
                        tmp.WriteAllBytes(corrupt);

                        using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                        {
                            var test = new Dictionary&lt;int, string&gt;();
                            log.ReplayLog(test);
                            Assert.AreEqual(0, test.Count);
                        }
                        Assert.IsFalse(File.Exists(tmp.TempPath));
                    }
                }
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, Guid.NewGuid().ToString())
                log.CommitTransaction(token)
                Dim test As var = New Dictionary(Of Integer, String)()
                Dim offset As Long = 0
                log.ReplayLog(test, offset)
                Assert.AreEqual(1, test.Count)
            End Using
            Dim bytes As Byte() = tmp.ReadAllBytes()

            Dim TestVariants As var = New Converter(Of KeyValuePair(Of Integer, Byte()), Byte())() {Function(kv) 
            kv.Value(kv.Key) = kv.Value(kv.Key) Xor &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            kv.Value(kv.Key) = &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            Dim b As Byte() = kv.Value
            Array.Resize(b, kv.Key)
            Return b

End Function}

            Dim corruptionIx As Integer = 0
            While corruptionIx &lt; bytes.Length
                For Each testcase As var In TestVariants
                    Dim corrupt As Byte() = testcase(New KeyValuePair(Of Integer, Byte())(corruptionIx, DirectCast(bytes.Clone(), Byte())))
                    tmp.WriteAllBytes(corrupt)

                    Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                        Dim test As var = New Dictionary(Of Integer, String)()
                        log.ReplayLog(test)
                        Assert.AreEqual(0, test.Count)
                    End Using
                    Assert.IsFalse(File.Exists(tmp.TempPath))
                Next
                System.Math.Max(System.Threading.Interlocked.Increment(corruptionIx),corruptionIx - 1)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.UpdateValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)">
            <summary> The provided key/value pair was updated in the provided transaction </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#488" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#87">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
            {
                var token = log.BeginTransaction();
                log.UpdateValue(ref token, 1, "test");
                log.CommitTransaction(ref token);

                var test = new Dictionary&lt;int, string&gt;();
                test.Add(1, null);
                log.ReplayLog(test);

                Assert.AreEqual(1, test.Count);
                Assert.IsTrue(test.ContainsKey(1));
                Assert.AreEqual("test", test[1]);
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.UpdateValue(token, 1, "test")
                log.CommitTransaction(token)

                Dim test As var = New Dictionary(Of Integer, String)()
                test.Add(1, Nothing)
                log.ReplayLog(test)

                Assert.AreEqual(1, test.Count)
                Assert.IsTrue(test.ContainsKey(1))
                Assert.AreEqual("test", test(1))
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.RemoveValue(CSharpTest.Net.Collections.TransactionToken@,`0)">
            <summary> The provided key/value pair was removed in the provided transaction </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#494" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#106">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
            {
                var token = log.BeginTransaction();
                log.RemoveValue(ref token, 1);
                log.CommitTransaction(ref token);

                var test = new Dictionary&lt;int, string&gt;();
                test.Add(1, null);
                log.ReplayLog(test);

                Assert.AreEqual(0, test.Count);
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.RemoveValue(token, 1)
                log.CommitTransaction(token)

                Dim test As var = New Dictionary(Of Integer, String)()
                test.Add(1, Nothing)
                log.ReplayLog(test)

                Assert.AreEqual(0, test.Count)
            End Using
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.CommitTransaction(CSharpTest.Net.Collections.TransactionToken@)">
            <summary>
            Commits the provided transaction
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#531" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#411">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            {
                using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                {
                    var token = log.BeginTransaction();
                    log.AddValue(ref token, 1, Guid.NewGuid().ToString());
                    log.CommitTransaction(ref token);
                    var test = new Dictionary&lt;int, string&gt;();
                    long offset = 0;
                    log.ReplayLog(test, ref offset);
                    Assert.AreEqual(1, test.Count);
                }
                byte[] bytes = tmp.ReadAllBytes();

                var TestVariants =
                    new Converter&lt;KeyValuePair&lt;int, byte[]&gt;, byte[]&gt;[]
                        {
                            kv =&gt; { kv.Value[kv.Key] ^= 0xff; return kv.Value; },
                            kv =&gt; { kv.Value[kv.Key] = 0xff; return kv.Value; },
                            kv =&gt; { byte[] b = kv.Value; Array.Resize(ref b, kv.Key); return b; },
                        };

                for (int corruptionIx = 0; corruptionIx &lt; bytes.Length; corruptionIx++)
                {
                    foreach (var testcase in TestVariants)
                    {
                        byte[] corrupt = testcase(new KeyValuePair&lt;int, byte[]&gt;(corruptionIx, (byte[]) bytes.Clone()));
                        tmp.WriteAllBytes(corrupt);

                        using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
                        {
                            var test = new Dictionary&lt;int, string&gt;();
                            log.ReplayLog(test);
                            Assert.AreEqual(0, test.Count);
                        }
                        Assert.IsFalse(File.Exists(tmp.TempPath));
                    }
                }
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, Guid.NewGuid().ToString())
                log.CommitTransaction(token)
                Dim test As var = New Dictionary(Of Integer, String)()
                Dim offset As Long = 0
                log.ReplayLog(test, offset)
                Assert.AreEqual(1, test.Count)
            End Using
            Dim bytes As Byte() = tmp.ReadAllBytes()

            Dim TestVariants As var = New Converter(Of KeyValuePair(Of Integer, Byte()), Byte())() {Function(kv) 
            kv.Value(kv.Key) = kv.Value(kv.Key) Xor &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            kv.Value(kv.Key) = &amp;Hff
            Return kv.Value

End Function, Function(kv) 
            Dim b As Byte() = kv.Value
            Array.Resize(b, kv.Key)
            Return b

End Function}

            Dim corruptionIx As Integer = 0
            While corruptionIx &lt; bytes.Length
                For Each testcase As var In TestVariants
                    Dim corrupt As Byte() = testcase(New KeyValuePair(Of Integer, Byte())(corruptionIx, DirectCast(bytes.Clone(), Byte())))
                    tmp.WriteAllBytes(corrupt)

                    Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                        Dim test As var = New Dictionary(Of Integer, String)()
                        log.ReplayLog(test)
                        Assert.AreEqual(0, test.Count)
                    End Using
                    Assert.IsFalse(File.Exists(tmp.TempPath))
                Next
                System.Math.Max(System.Threading.Interlocked.Increment(corruptionIx),corruptionIx - 1)
            End While
        End Using</code></example></member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.RollbackTransaction(CSharpTest.Net.Collections.TransactionToken@)">
            <summary>
            Abandons the provided transaction
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs#572" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><seealso cref="T:CSharpTest.Net.Collections.TransactionToken">TransactionToken</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#276">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile tmp = new TempFile())
            using (var log = new TransactionLog&lt;int, string&gt;(Options(tmp)))
            {
                var token = log.BeginTransaction();
                log.AddValue(ref token, 1, "test");
                log.RollbackTransaction(ref token);

                var test = new Dictionary&lt;int, string&gt;();
                log.ReplayLog(test);
                Assert.AreEqual(0, test.Count);
            }</code><code lang="VB.NET">        Using tmp As New TempFile()
            Using log As var = New TransactionLog(Of Integer, String)(Options(tmp))
                Dim token As var = log.BeginTransaction()
                log.AddValue(token, 1, "test")
                log.RollbackTransaction(token)

                Dim test As var = New Dictionary(Of Integer, String)()
                log.ReplayLog(test)
                Assert.AreEqual(0, test.Count)
            End Using
        End Using</code></example></member>
        <member name="P:CSharpTest.Net.Collections.TransactionLog`2.FileName">
            <summary>
            Returns the file name of the current transaction log file
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso></member>
        <member name="P:CSharpTest.Net.Collections.TransactionLog`2.Size">
            <summary>
            Returns the current size of the log file in bytes
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.Close" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.Close()</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/BPlusTree/BPlusTree.Test/TestTransactionLog.cs#39">BPlusTree/BPlusTree.Test/TestTransactionLog.cs</see></para><code lang="C#">            using (TempFile temp = new TempFile())
            {
                temp.Delete();
                var opt = new TransactionLogOptions&lt;int, string&gt;(temp.TempPath,
                                                              PrimitiveSerializer.Int32,
                                                              PrimitiveSerializer.String);
                //FileName
                Assert.AreEqual(temp.TempPath, opt.FileName);
                //Key/Value serializers
                Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32));
                Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.String));
                //FileOptions
                Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions);
                Assert.AreEqual(FileOptions.WriteThrough | FileOptions.Asynchronous, opt.FileOptions |= FileOptions.Asynchronous);
                //Read Only
                Assert.AreEqual(false, opt.ReadOnly);
                Assert.AreEqual(true, opt.ReadOnly = true);
                //File Buffer
                Assert.AreEqual(8, opt.FileBuffer);
                Assert.AreEqual(0x40000, opt.FileBuffer = 0x40000);
                //Clone
                Assert.IsFalse(ReferenceEquals(opt, opt.Clone()));

                using(TransactionLog&lt;int, string&gt; log = new TransactionLog&lt;int,string&gt;(opt))
                    Assert.AreEqual(0, log.Size);
            }</code><code lang="VB.NET">        Using temp As New TempFile()
            temp.Delete()
            Dim opt As var = New TransactionLogOptions(Of Integer, String)(temp.TempPath, PrimitiveSerializer.Int32, PrimitiveSerializer.[String])
            'FileName
            Assert.AreEqual(temp.TempPath, opt.FileName)
            'Key/Value serializers
            Assert.IsTrue(ReferenceEquals(opt.KeySerializer, PrimitiveSerializer.Int32))
            Assert.IsTrue(ReferenceEquals(opt.ValueSerializer, PrimitiveSerializer.[String]))
            'FileOptions
            Assert.AreEqual(FileOptions.WriteThrough, opt.FileOptions)
            Assert.AreEqual(FileOptions.WriteThrough Or FileOptions.Asynchronous, opt.FileOptions = opt.FileOptions Or FileOptions.Asynchronous)
            'Read Only
            Assert.AreEqual(False, opt.[ReadOnly])
            Assert.AreEqual(True, opt.[ReadOnly] = True)
            'File Buffer
            Assert.AreEqual(8, opt.FileBuffer)
            Assert.AreEqual(&amp;H40000, opt.FileBuffer = &amp;H40000)
            'Clone
            Assert.IsFalse(ReferenceEquals(opt, opt.Clone()))

            Using log As New TransactionLog(Of Integer, String)(opt)
                Assert.AreEqual(0, log.Size)
            End Using
        End Using</code></example></member>
        <member name="T:CSharpTest.Net.BaseAssertionException">
            <summary> The base class for BPlutTree runtime assertions </summary>
        </member>
        <member name="M:CSharpTest.Net.BaseAssertionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> The base class for BPlutTree runtime assertions </summary>
        </member>
        <member name="M:CSharpTest.Net.BaseAssertionException.#ctor(System.String)">
            <summary> The base class for BPlutTree runtime assertions </summary>
        </member>
        <member name="M:CSharpTest.Net.BaseAssertionException.#ctor(System.String,System.Exception)">
            <summary> The base class for BPlutTree runtime assertions </summary>
        </member>
        <member name="T:CSharpTest.Net.AssertionFailedException">
            <summary>
            Exception class: AssertionFailedException
            A runtime assertion failed while performing the operation.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.AssertionFailedException.Assert(System.Boolean,System.String,System.Object[])">
            <summary>
            if(condition == false) throws A runtime assertion failed: {0}
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Exceptions.cs#63" cat="Source Code">BPlusTree/Exceptions.cs</seealso><exception cref="T:CSharpTest.Net.AssertionFailedException" /></member>
        <member name="M:CSharpTest.Net.AssertionFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor
            </summary>
        </member>
        <member name="M:CSharpTest.Net.AssertionFailedException.Create(System.Int32,System.String)">
            <summary>
            Used to create this exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.AssertionFailedException.#ctor(System.Exception,System.Int32,System.String)">
            <summary>
            Constructs the exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.AssertionFailedException.#ctor">
            <summary>
            A runtime assertion failed while performing the operation.
            </summary>
        <seealso cref="M:CSharpTest.Net.AssertionFailedException.Assert(System.Boolean)" cat="Used By">AssertionFailedException.Assert(Boolean)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#164" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.AssertionFailedException.#ctor(System.Exception)">
            <summary>
            A runtime assertion failed while performing the operation.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#171" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.AssertionFailedException.Assert(System.Boolean)">
            <summary>
            if(condition == false) throws A runtime assertion failed while performing the operation.
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.CommitTransaction(CSharpTest.Net.Collections.TransactionToken@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.CommitTransaction(TransactionToken)</seealso><seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.RollbackTransaction(CSharpTest.Net.Collections.TransactionToken@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.RollbackTransaction(TransactionToken)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#179" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso><exception cref="T:CSharpTest.Net.AssertionFailedException" /></member>
        <member name="M:CSharpTest.Net.AssertionFailedException.#ctor(System.String)">
            <summary>
            A runtime assertion failed: {0}
            </summary>
        <seealso cref="M:CSharpTest.Net.AssertionFailedException.Assert(System.Boolean,System.String,System.Object[])" cat="Used By">AssertionFailedException.Assert(Boolean,String,Object[])</seealso><seealso cref="M:CSharpTest.Net.AssertionFailedException.Assert(System.Boolean,System.String)" cat="Used By">AssertionFailedException.Assert(Boolean,String)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#185" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.AssertionFailedException.#ctor(System.String,System.Exception)">
            <summary>
            A runtime assertion failed: {0}
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#192" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.AssertionFailedException.Assert(System.Boolean,System.String)">
            <summary>
            if(condition == false) throws A runtime assertion failed: {0}
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#200" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso><exception cref="T:CSharpTest.Net.AssertionFailedException" /></member>
        <member name="T:CSharpTest.Net.Collections.IStorageHandle">
            <summary> Identifies a class as a reference to a node instance </summary>
        <seealso cref="M:CSharpTest.Net.Collections.INodeStorage.OpenRoot(System.Boolean@)">IStorageHandle INodeStorage.OpenRoot(Boolean)</seealso><seealso cref="M:CSharpTest.Net.Collections.INodeStorage.TryGetNode``1(CSharpTest.Net.Collections.IStorageHandle,``0@,CSharpTest.Net.Serialization.ISerializer{``0})">Boolean INodeStorage.TryGetNode&lt;TNode&gt;(IStorageHandle,TNode,ISerializer&lt;TNode&gt;)</seealso><seealso cref="M:CSharpTest.Net.Collections.INodeStorage.Create">IStorageHandle INodeStorage.Create()</seealso><seealso cref="M:CSharpTest.Net.Collections.INodeStorage.Destroy(CSharpTest.Net.Collections.IStorageHandle)">INodeStorage.Destroy(IStorageHandle)</seealso><seealso cref="M:CSharpTest.Net.Collections.INodeStorage.Update``1(CSharpTest.Net.Collections.IStorageHandle,CSharpTest.Net.Serialization.ISerializer{``0},``0)">INodeStorage.Update&lt;TNode&gt;(IStorageHandle,ISerializer&lt;TNode&gt;,TNode)</seealso></member>
        <member name="T:CSharpTest.Net.Storage.BTreeFileStoreV2">
            <summary>
            Provides a file-based storage for the BPlusTree dictionary
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Storage.BTreeFileStoreV2.#ctor(CSharpTest.Net.IO.TransactedCompoundFile.Options)">
            <summary>
            Opens an existing BPlusTree file at the path specified, for a new file use CreateNew()
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Storage.BTreeFileStoreV2.Dispose">
            <summary>
            Closes the file in it's current state.
            </summary>
        </member>
        <member name="T:CSharpTest.Net.Storage.BTreeFileStore">
            <summary>
            Provides a file-based storage for the BPlusTree dictionary
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Storage.BTreeFileStore.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.IO.FileOptions,System.Boolean)">
            <summary>
            Opens an existing BPlusTree file at the path specified, for a new file use CreateNew()
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Storage.BTreeFileStore.Dispose">
            <summary>
            Closes the file in it's current state.
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Storage.BTreeFileStore.CreateNew(System.String,System.Int32,System.Int32,System.Int32,System.IO.FileOptions)">
            <summary>
            Creates an empty file store in the path specified
            </summary>
        </member>
        <member name="T:CSharpTest.Net.Storage.BTreeMemoryStore">
            <summary>
            Provides an in-memory implementation of the storage services for BPlusTree, useful when testing :)
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Storage.BTreeMemoryStore.#ctor">
            <summary> Default in-memory storage </summary>
        </member>
        <member name="T:CSharpTest.Net.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:CSharpTest.Net.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:CSharpTest.Net.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:CSharpTest.Net.Resources.ExceptionStrings">
            <summary>
            Returns the raw exception strings.
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Resources.ExceptionStrings.SafeFormat(System.String,System.Object[])">
            <summary>
            Formats a message for an exception
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Resources.ExceptionStrings.HelpLinkFormat(System.Int32,System.String)">
            <summary>
            </summary>
        </member>
        <member name="P:CSharpTest.Net.Resources.ExceptionStrings.AssertionFailedException">
            <summary>
            A runtime assertion failed while performing the operation.
            </summary>
        <seealso cref="M:CSharpTest.Net.AssertionFailedException.Assert(System.Boolean,System.String,System.Object[])" cat="Used By">AssertionFailedException.Assert(Boolean,String,Object[])</seealso></member>
        <member name="P:CSharpTest.Net.Resources.ExceptionStrings.AssertionFailedException_string_message_">
            <summary>
            A runtime assertion failed: {0}
            </summary>
        </member>
        <member name="P:CSharpTest.Net.Resources.ExceptionStrings.DeadlockException">
            <summary>
            A lock timeout has expired due to a possible deadlock.
            </summary>
        </member>
        <member name="P:CSharpTest.Net.Resources.ExceptionStrings.DuplicateKeyException">
            <summary>
            The specified key already exists in the collection.
            </summary>
        </member>
        <member name="P:CSharpTest.Net.Resources.ExceptionStrings.InvalidConfigurationValueException_string_property_">
            <summary>
            The configuration value '{0}' is invalid.
            </summary>
        </member>
        <member name="P:CSharpTest.Net.Resources.ExceptionStrings.InvalidConfigurationValueException_string_property__string_message_">
            <summary>
            The configuration value '{0}' is invalid.
            {1}
            </summary>
        </member>
        <member name="P:CSharpTest.Net.Resources.ExceptionStrings.InvalidNodeHandleException">
            <summary>
            A storage handle was invalid or has been corrupted.
            </summary>
        </member>
        <member name="T:CSharpTest.Net.DeadlockException">
            <summary>
            Exception class: DeadlockException
            A lock timeout has expired due to a possible deadlock.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.DeadlockException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor
            </summary>
        </member>
        <member name="M:CSharpTest.Net.DeadlockException.Create(System.Int32,System.String)">
            <summary>
            Used to create this exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.DeadlockException.#ctor(System.Exception,System.Int32,System.String)">
            <summary>
            Constructs the exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.DeadlockException.#ctor">
            <summary>
            A lock timeout has expired due to a possible deadlock.
            </summary>
        <seealso cref="M:CSharpTest.Net.DeadlockException.Assert(System.Boolean)" cat="Used By">DeadlockException.Assert(Boolean)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#239" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.DeadlockException.#ctor(System.Exception)">
            <summary>
            A lock timeout has expired due to a possible deadlock.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#246" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.DeadlockException.Assert(System.Boolean)">
            <summary>
            if(condition == false) throws A lock timeout has expired due to a possible deadlock.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#254" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso><exception cref="T:CSharpTest.Net.DeadlockException" /></member>
        <member name="T:CSharpTest.Net.DuplicateKeyException">
            <summary>
            Exception class: DuplicateKeyException
            The specified key already exists in the collection.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.DuplicateKeyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor
            </summary>
        </member>
        <member name="M:CSharpTest.Net.DuplicateKeyException.Create(System.Int32,System.String)">
            <summary>
            Used to create this exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.DuplicateKeyException.#ctor(System.Exception,System.Int32,System.String)">
            <summary>
            Constructs the exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.DuplicateKeyException.#ctor">
            <summary>
            The specified key already exists in the collection.
            </summary>
        <seealso cref="M:CSharpTest.Net.DuplicateKeyException.Assert(System.Boolean)" cat="Used By">DuplicateKeyException.Assert(Boolean)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#293" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.DuplicateKeyException.#ctor(System.Exception)">
            <summary>
            The specified key already exists in the collection.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#300" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.DuplicateKeyException.Assert(System.Boolean)">
            <summary>
            if(condition == false) throws The specified key already exists in the collection.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#308" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso><exception cref="T:CSharpTest.Net.DuplicateKeyException" /></member>
        <member name="T:CSharpTest.Net.InvalidConfigurationValueException">
            <summary>
            Exception class: InvalidConfigurationValueException
            The configuration value '{0}' is invalid.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.InvalidConfigurationValueException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor
            </summary>
        </member>
        <member name="M:CSharpTest.Net.InvalidConfigurationValueException.Create(System.Int32,System.String)">
            <summary>
            Used to create this exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.InvalidConfigurationValueException.#ctor(System.Exception,System.Int32,System.String)">
            <summary>
            Constructs the exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.InvalidConfigurationValueException.#ctor(System.String)">
            <summary>
            The configuration value '{0}' is invalid.
            </summary>
        <seealso cref="M:CSharpTest.Net.InvalidConfigurationValueException.Assert(System.Boolean,System.String)" cat="Used By">InvalidConfigurationValueException.Assert(Boolean,String)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#347" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.InvalidConfigurationValueException.#ctor(System.String,System.Exception)">
            <summary>
            The configuration value '{0}' is invalid.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#354" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.InvalidConfigurationValueException.Assert(System.Boolean,System.String)">
            <summary>
            if(condition == false) throws The configuration value '{0}' is invalid.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#362" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso><exception cref="T:CSharpTest.Net.InvalidConfigurationValueException" /></member>
        <member name="M:CSharpTest.Net.InvalidConfigurationValueException.#ctor(System.String,System.String)">
            <summary>
            The configuration value '{0}' is invalid.
            {1}
            </summary>
        <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.RecoverFile(CSharpTest.Net.Collections.BPlusTree{`0,`1}.Options)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.RecoverFile(BPlusTree&lt;TKey,TValue&gt;.Options)</seealso><seealso cref="M:CSharpTest.Net.InvalidConfigurationValueException.Assert(System.Boolean,System.String,System.String)" cat="Used By">InvalidConfigurationValueException.Assert(Boolean,String,String)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#369" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.InvalidConfigurationValueException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            The configuration value '{0}' is invalid.
            {1}
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#377" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.InvalidConfigurationValueException.Assert(System.Boolean,System.String,System.String)">
            <summary>
            if(condition == false) throws The configuration value '{0}' is invalid.
            {1}
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#386" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso><exception cref="T:CSharpTest.Net.InvalidConfigurationValueException" /></member>
        <member name="T:CSharpTest.Net.InvalidNodeHandleException">
            <summary>
            Exception class: InvalidNodeHandleException
            A storage handle was invalid or has been corrupted.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.InvalidNodeHandleException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor
            </summary>
        </member>
        <member name="M:CSharpTest.Net.InvalidNodeHandleException.Create(System.Int32,System.String)">
            <summary>
            Used to create this exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.InvalidNodeHandleException.#ctor(System.Exception,System.Int32,System.String)">
            <summary>
            Constructs the exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:CSharpTest.Net.InvalidNodeHandleException.#ctor">
            <summary>
            A storage handle was invalid or has been corrupted.
            </summary>
        <seealso cref="M:CSharpTest.Net.InvalidNodeHandleException.Assert(System.Boolean)" cat="Used By">InvalidNodeHandleException.Assert(Boolean)</seealso><seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#425" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.InvalidNodeHandleException.#ctor(System.Exception)">
            <summary>
            A storage handle was invalid or has been corrupted.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#432" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso></member>
        <member name="M:CSharpTest.Net.InvalidNodeHandleException.Assert(System.Boolean)">
            <summary>
            if(condition == false) throws A storage handle was invalid or has been corrupted.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/BPlusTree/Resources.Designer.cs#440" cat="Source Code">BPlusTree/Resources.Designer.cs</seealso><exception cref="T:CSharpTest.Net.InvalidNodeHandleException" /></member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2._disposed">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Dispose()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2._selfLock">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Dispose()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.UnloadCache" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.UnloadCache()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Clear" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Clear()</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.get_LockTimeout">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Dispose()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.UnloadCache" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.UnloadCache()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Clear" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Clear()</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.CommitChanges(System.Boolean)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Dispose()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Commit" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Commit()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Clear" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Clear()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2._storage">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Dispose()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.UnloadCache" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.UnloadCache()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Clear" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Clear()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheBase.Dispose">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Dispose()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2._options">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Dispose()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTreeOptions`2.LogFile">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Dispose" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Dispose()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NotDisposed">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.UnloadCache" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.UnloadCache()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Clear" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Clear()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheBase.Storage">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheBase.ResetCache">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.UnloadCache" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.UnloadCache()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2._hasCount">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Rollback" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Rollback()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnableCount" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.EnableCount()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2._count">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnableCount" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.EnableCount()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Clear" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Clear()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.LockRoot(CSharpTest.Net.Collections.BPlusTree{`0,`1}.LockType,System.String,System.Boolean)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnableCount" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.EnableCount()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Print(System.IO.TextWriter,CSharpTest.Net.Collections.BPlusTree{`0,`1}.DebugFormat)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Print(TextWriter,BPlusTree&lt;TKey,TValue&gt;.DebugFormat)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Validate" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Validate()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2.RootLock.Pin">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnableCount" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.EnableCount()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetValue(`0,`1@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetValue(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetFirst(System.Collections.Generic.KeyValuePair{`0,`1}@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetFirst(KeyValuePair&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetLast(System.Collections.Generic.KeyValuePair{`0,`1}@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetLast(KeyValuePair&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Print(System.IO.TextWriter,CSharpTest.Net.Collections.BPlusTree{`0,`1}.DebugFormat)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Print(TextWriter,BPlusTree&lt;TKey,TValue&gt;.DebugFormat)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Validate" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Validate()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.CountValues(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnableCount" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.EnableCount()</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.RootLock">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnableCount" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.EnableCount()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetValue(`0,`1@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetValue(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetFirst(System.Collections.Generic.KeyValuePair{`0,`1}@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetFirst(KeyValuePair&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetLast(System.Collections.Generic.KeyValuePair{`0,`1}@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetLast(KeyValuePair&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Print(System.IO.TextWriter,CSharpTest.Net.Collections.BPlusTree{`0,`1}.DebugFormat)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Print(TextWriter,BPlusTree&lt;TKey,TValue&gt;.DebugFormat)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Validate" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Validate()</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.LockRoot(CSharpTest.Net.Collections.BPlusTree{`0,`1}.LockType,System.String)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetValue(`0,`1@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetValue(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetFirst(System.Collections.Generic.KeyValuePair{`0,`1}@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetFirst(KeyValuePair&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetLast(System.Collections.Generic.KeyValuePair{`0,`1}@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetLast(KeyValuePair&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Search(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin,`0,`1@)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetValue(`0,`1@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetValue(TKey,TValue)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugComplete(System.String,System.Object[])">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetValue(`0,`1@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetValue(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Clear" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Clear()</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.UpdateInfo.#ctor(`1)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue)</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.UpdateInfo">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.UpdateInfo.Updated">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.UpdateIfValue.#ctor(`1,`1)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue,TValue)</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.UpdateIfValue">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue,TValue)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.UpdateIfValue.Updated">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,`1,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,TValue,TValue)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.UpdateInfo.#ctor(CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryUpdate(`0,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryUpdate(TKey,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2._keyComparer">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRange(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeInfo.#ctor(System.Boolean,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.KeyRange.#ctor(System.Collections.Generic.IComparer{`0})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.KeyRange">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.AddRange(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin,CSharpTest.Net.Collections.BPlusTree{`0,`1}.KeyRange@,CSharpTest.Net.Collections.BPlusTree{`0,`1}.AddRangeInfo,CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin,System.Int32)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.AddRangeInfo.IsComplete">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddRangeSorted(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.AddRangeSorted(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,Boolean)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.InsertValue.#ctor(`1,System.Boolean)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Add(`0,`1)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Add(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,`1)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.AddOrUpdate(TKey,TValue)</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.InsertValue">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Add(`0,`1)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Add(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,`1)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.AddOrUpdate(TKey,TValue)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.FetchValue.#ctor(`1)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.GetOrAdd(`0,`1)" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.GetOrAdd(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryAdd(`0,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryAdd(TKey,TValue)</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.FetchValue">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.GetOrAdd(`0,`1)" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.GetOrAdd(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryAdd(`0,`1)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryAdd(TKey,TValue)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.FetchValue.Value">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.GetOrAdd(`0,`1)" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.GetOrAdd(TKey,TValue)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2.IgnoreUpdate">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.GetOrAdd(`0,System.Converter{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.GetOrAdd(TKey,Converter&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryAdd(`0,System.Converter{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryAdd(TKey,Converter&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.InsertionInfo.#ctor(System.Converter{`0,`1},CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.GetOrAdd(`0,System.Converter{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.GetOrAdd(TKey,Converter&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryAdd(`0,System.Converter{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryAdd(TKey,Converter&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,System.Converter{`0,`1},CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.AddOrUpdate(TKey,Converter&lt;TKey,TValue&gt;,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.InsertionInfo">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.GetOrAdd(`0,System.Converter{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.GetOrAdd(TKey,Converter&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryAdd(`0,System.Converter{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryAdd(TKey,Converter&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,`1,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.AddOrUpdate(TKey,TValue,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,System.Converter{`0,`1},CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.AddOrUpdate(TKey,Converter&lt;TKey,TValue&gt;,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.InsertionInfo.Value">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.GetOrAdd(`0,System.Converter{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.GetOrAdd(TKey,Converter&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,`1,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.AddOrUpdate(TKey,TValue,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,System.Converter{`0,`1},CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.AddOrUpdate(TKey,Converter&lt;TKey,TValue&gt;,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.InsertionInfo.#ctor(`1,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.AddOrUpdate(`0,`1,CSharpTest.Net.Collections.KeyValueUpdate{`0,`1})" cat="Used By">TValue BPlusTree&lt;TKey,TValue&gt;.AddOrUpdate(TKey,TValue,KeyValueUpdate&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.RemoveAlways">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryRemove(`0,`1@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryRemove(TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Remove(`0)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.Remove(TKey)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.RemoveAlways.TryGetValue(`1@)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryRemove(`0,`1@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryRemove(TKey,TValue)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.RemoveIfPredicate.#ctor(CSharpTest.Net.Collections.KeyValuePredicate{`0,`1})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryRemove(`0,CSharpTest.Net.Collections.KeyValuePredicate{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryRemove(TKey,KeyValuePredicate&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTree`2.RemoveIfPredicate">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryRemove(`0,CSharpTest.Net.Collections.KeyValuePredicate{`0,`1})" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryRemove(TKey,KeyValuePredicate&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetEdge(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin,System.Boolean,System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetFirst(System.Collections.Generic.KeyValuePair{`0,`1}@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetFirst(KeyValuePair&lt;TKey,TValue&gt;)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.TryGetLast(System.Collections.Generic.KeyValuePair{`0,`1}@)" cat="Used By">Boolean BPlusTree&lt;TKey,TValue&gt;.TryGetLast(KeyValuePair&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Enumerator.#ctor(CSharpTest.Net.Collections.BPlusTree{`0,`1},`0)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateFrom(`0)" cat="Used By">IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; BPlusTree&lt;TKey,TValue&gt;.EnumerateFrom(TKey)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.&lt;&gt;c__DisplayClass1.#ctor">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateRange(`0,`0)" cat="Used By">IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; BPlusTree&lt;TKey,TValue&gt;.EnumerateRange(TKey,TKey)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2.&lt;&gt;c__DisplayClass1.end">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateRange(`0,`0)" cat="Used By">IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; BPlusTree&lt;TKey,TValue&gt;.EnumerateRange(TKey,TKey)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2.&lt;&gt;c__DisplayClass1.&lt;&gt;4__this">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateRange(`0,`0)" cat="Used By">IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; BPlusTree&lt;TKey,TValue&gt;.EnumerateRange(TKey,TKey)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.&lt;&gt;c__DisplayClass1.&lt;EnumerateRange&gt;b__0(System.Collections.Generic.KeyValuePair{`0,`1})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateRange(`0,`0)" cat="Used By">IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; BPlusTree&lt;TKey,TValue&gt;.EnumerateRange(TKey,TKey)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Enumerator.#ctor(CSharpTest.Net.Collections.BPlusTree{`0,`1},`0,System.Predicate{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateRange(`0,`0)" cat="Used By">IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; BPlusTree&lt;TKey,TValue&gt;.EnumerateRange(TKey,TKey)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Enumerator.#ctor(CSharpTest.Net.Collections.BPlusTree{`0,`1})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.GetEnumerator" cat="Used By">IEnumerator&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; BPlusTree&lt;TKey,TValue&gt;.GetEnumerator()</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheBase.DeleteAll">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Clear" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Clear()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2._debugOut">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.DebugSetOutput(System.IO.TextWriter)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.DebugSetOutput(TextWriter)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2._validated">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.DebugSetValidateOnCheckpoint(System.Boolean)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.DebugSetValidateOnCheckpoint(Boolean)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Print(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin,System.IO.TextWriter,System.Int32,CSharpTest.Net.Collections.BPlusTree{`0,`1}.DebugFormat)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Print(System.IO.TextWriter,CSharpTest.Net.Collections.BPlusTree{`0,`1}.DebugFormat)" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Print(TextWriter,BPlusTree&lt;TKey,TValue&gt;.DebugFormat)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Validate(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin,CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin,System.Int32,System.Int32)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.Validate" cat="Used By">BPlusTree&lt;TKey,TValue&gt;.Validate()</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.BPlusTreeOptions{`0,`1}">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.EnumerateFile(CSharpTest.Net.Collections.BPlusTreeOptions{`0,`1})">IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt; BPlusTree&lt;TKey,TValue&gt;.EnumerateFile(BPlusTreeOptions&lt;TKey,TValue&gt;)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.NodePin.Ptr">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Node.Count">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Node.Item(System.Int32)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Element.ChildNode">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheBase.Lock(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin,CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodeHandle)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.BulkWrite(System.Collections.Generic.ICollection{CSharpTest.Net.Collections.IStorageHandle},System.Int32@,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NodeCacheBase.BeginTransaction">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NodeTransaction.BeginUpdate(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Node.StorageHandle">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NodeHandle.#ctor(CSharpTest.Net.Collections.IStorageHandle)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Node.ReplaceChild(System.Int32,CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodeHandle,CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodeHandle)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NodeTransaction.Commit">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DeleteTree(CSharpTest.Net.Collections.BPlusTree{`0,`1}.NodePin)">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.NodePin.Dispose">
            <seealso cref="M:CSharpTest.Net.Collections.BPlusTree`2.BulkInsert(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},CSharpTest.Net.Collections.BulkInsertOptions)" cat="Used By">Int32 BPlusTree&lt;TKey,TValue&gt;.BulkInsert(IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;,BulkInsertOptions)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.ToString">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#47" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Equals(System.Object)">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#56" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.GetHashCode">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#185" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.GetType">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs#200" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.Equals(System.Object)">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.GetHashCode">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.ToString">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.ToString(System.String,System.IFormatProvider)">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.CompareTo(System.Object)">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.ToString(System.String)">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.ToString(System.IFormatProvider)">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.GetTypeCode">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.GetType">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.BPlusTree`2.DebugFormat.value__">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.KeySerializer">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.ValueSerializer">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.KeyComparer">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.StorageType">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.ReadOnly">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.StorageSystem">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.FileName">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CreateFile">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.FileBlockSize">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.LockTimeout">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.LockingFactory">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.BTreeOrder">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.MinimumChildNodes">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.MaximumChildNodes">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.MinimumValueNodes">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.MaximumValueNodes">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CachePolicy">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CacheKeepAliveMinimumHistory">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CacheKeepAliveMaximumHistory">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.CacheKeepAliveTimeout">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.ToString">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.Equals(System.Object)">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.GetHashCode">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.GetType">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="T:CSharpTest.Net.Collections.ITransactionLog{`0,`1}">
            <seealso cref="P:CSharpTest.Net.Collections.BPlusTree`2.OptionsV2.TransactionLog">ITransactionLog&lt;TKey,TValue&gt; BPlusTree&lt;TKey,TValue&gt;.OptionsV2.TransactionLog</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.KeySerializer">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.ValueSerializer">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.KeyComparer">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.StorageType">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.ReadOnly">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.StorageSystem">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.FileName">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.CreateFile">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.FileBlockSize">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.LockTimeout">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.LockingFactory">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.CallLevelLock">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.BTreeOrder">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.MinimumChildNodes">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.MaximumChildNodes">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.MinimumValueNodes">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.MaximumValueNodes">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.CachePolicy">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.CacheKeepAliveMinimumHistory">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.CacheKeepAliveMaximumHistory">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="P:CSharpTest.Net.Collections.BPlusTree`2.Options.CacheKeepAliveTimeout">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.ToString">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.Equals(System.Object)">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.GetHashCode">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.BPlusTree`2.Options.GetType">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/BPlusTree.cs" cat="Source Code">BPlusTree/Collections/BPlusTree.cs</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.TransactionLog`2._logSync">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.Close" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.Close()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.TransactionLog`2._logfile">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.Close" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.Close()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.TransactionLog`2._options">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.Close" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.Close()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.TransactionLog`2.LogEntry.OpCode">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.ReplayLog(System.Collections.Generic.IDictionary{`0,`1},System.Int64@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.ReplayLog(IDictionary&lt;TKey,TValue&gt;,Int64)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.TransactionLog`2.LogEntry.Key">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.ReplayLog(System.Collections.Generic.IDictionary{`0,`1},System.Int64@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.ReplayLog(IDictionary&lt;TKey,TValue&gt;,Int64)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.TransactionLog`2.LogEntry.Value">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.ReplayLog(System.Collections.Generic.IDictionary{`0,`1},System.Int64@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.ReplayLog(IDictionary&lt;TKey,TValue&gt;,Int64)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.TruncateLog(System.Int64)">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.TruncateLog" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.TruncateLog()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Collections.TransactionLog`2._transactionId">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.BeginTransaction" cat="Used By">TransactionToken TransactionLog&lt;TKey,TValue&gt;.BeginTransaction()</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.Write(CSharpTest.Net.Collections.TransactionToken@,CSharpTest.Net.Collections.TransactionLog{`0,`1}.OperationCode,`0,`1)">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.AddValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.AddValue(TransactionToken,TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.UpdateValue(CSharpTest.Net.Collections.TransactionToken@,`0,`1)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.UpdateValue(TransactionToken,TKey,TValue)</seealso>
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.RemoveValue(CSharpTest.Net.Collections.TransactionToken@,`0)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.RemoveValue(TransactionToken,TKey)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <seealso cref="M:CSharpTest.Net.Collections.TransactionLog`2.CommitTransaction(CSharpTest.Net.Collections.TransactionToken@)" cat="Used By">TransactionLog&lt;TKey,TValue&gt;.CommitTransaction(TransactionToken)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.ToString">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.Equals(System.Object)">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.GetHashCode">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Collections.TransactionLog`2.GetType">
            <seealso cref="http://csharptest.net/browse/src/BPlusTree/Collections/TransactionLog.cs" cat="Source Code">BPlusTree/Collections/TransactionLog.cs</seealso>
        </member>
    </members>
</doc>