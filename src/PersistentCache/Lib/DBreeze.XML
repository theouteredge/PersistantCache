<?xml version="1.0"?>
<doc>
    <assembly>
        <name>DBreeze</name>
    </assembly>
    <members>
        <member name="T:DBreeze.Tries.ITrieRootNode">
            <summary>
            Identifies any type of RootNode in different tries
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRootNode.RecordsCount">
            <summary>
            Indicates quantity of Records in the table
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.DeserializeRootNode">
            <summary>
            bytes[] to objects
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.SerializeRootNode">
            <summary>
            Root to byte[]
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.AddKey(System.Byte[]@,System.Byte[]@,System.Boolean@)">
            <summary>
            Returns link to the Full Value together with the key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.AddKeyPartially(System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@,System.Boolean@)">
            <summary>
            Returns link to the full value together with the key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.RemoveAll(System.Boolean)">
            <summary>
            Check TransactionCommit in case of RemoveAll with file Recreation.
            Note if some other threads are reading parallel data, exception will be thrown in their transaction.
            It's correct.
            </summary>
            <param name="withFileRecreation"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.ChangeKey(System.Byte[]@,System.Byte[]@)">
            <summary>
            Takes value fresh no committed value row.GetFullValue(false);
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.ChangeKey(System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Takes value fresh no committed value row.GetFullValue(false);
            </summary>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="refToInsertedValue">returns ptr in the file to the new key</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.RemoveKey(System.Byte[]@,System.Boolean@)">
            <summary>
            Will return pointer to the value of the removing kid (if it existed). Otherwise NULL.
            </summary>
            <param name="key"></param>
            <param name="WasRemoved">indicates that value existed if true</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRootNode.GetKey(System.Byte[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.Val">
            <summary>
            0-255, in case if ValueKid = false, 256 if ValueKid = true;
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.Ptr">
            <summary>
            Pointer to the next node or to the value
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.Exists">
            <summary>
            Default value is false
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.LinkToNode">
            <summary>
            Works when ValueKid = false.
            True is link to node
            False if link to value.
            Default is true.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKid.ValueKid">
            <summary>
            Identifies that it's a value for this node, not the kid from 0-255.
            If true, Ptr has link to the value.
            Default is false
            </summary>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.Serializator">
            <summary>
            Must be setup to be used together with DbCustomSerializer
            </summary>
        </member>
        <member name="F:DBreeze.Utils.CustomSerializator.Deserializator">
            <summary>
            Must be setup to be used together with DbCustomSerializer
            </summary>
        </member>
        <member name="M:DBreeze.Utils.CustomSerializator.SerializeCustom(System.Object)">
            <summary>
            Serializes object to JSON from Microsoft
            </summary>
            <param name="objectForSerialization"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.CustomSerializator.DeserializeCustom``1(System.String)">
            <summary>
            Deserializes object from Microsoft JSON string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationMap.GenerateMapNodesValuesUpToIndex(System.Int32)">
            <summary>
            Used for finding out hash from Generation Map
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetTable(System.UInt32)">
            <summary>
            We are inside of the row.
            <para>This Method will give you ability to the nested tables which can be stored inside of table by tableIndex</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetValuePart(System.UInt32,System.UInt32)">
            <summary>
            Returns partial value representation starting from specif index and specified length.
            <para>To get full value as byte[] use GetValuePart(0)</para>
            </summary>
            <param name="startIndex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetValuePart(System.UInt32)">
            <summary>
            Returns partial value representation starting from specif index till and till the end of value.
            </summary>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.GetDataBlock(System.UInt32)">
            <summary>
            Returns datablock which identifier is stored in this row from specified index.
            <para></para>
            Insert dynamic lenght datablock is possible via tran.InsertDataBlock or NestedTable.InsertDataBlock.
            <para></para>
            can return null.
            </summary>
            <param name="dataBlockId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.Row`2.PrintOut(System.String)">
            <summary>
            Experimantal Console PrintOut
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.LinkToValue">
            <summary>
            Returns physical link to key/value if it exists, otherwise null,
            this link can be used by SelectDirect (always returns 8 bytes)
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.Row`2.Value">
            <summary>
            Returns full value and converts it to the value data type.
            <para>To take full value or part of the value as byte[] use GetValuePart or GetBytes (for string types like DbAscii etc.)</para>
            <para>If your value contains serialized object inside or it's a string type (like DbAscii etc.), use Value.Get property.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.DbReaderWriterLock">
            <summary>
            Wrapper For System.Threading.ReaderWriterLockSlim
            In case if better algorithm will be found
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.QuantityReservationSlots">
            <summary>
            Reservations are calculated by Schema. They Depend upon quantity of Existing Kids.
            QuantityAvailableReservations is calculated in ReadSelf if Kid.Pointer equals to ZeroPointer - it means reservation.
            Default is 0
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.ToChangeParentNode">
            <summary>
            When New Node is created it's true
            After Reading Node it must become false,
            After WriteSelf it will be or true or false.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.KidsBeforeModification">
            <summary>
            Field which contains either null (if Generation node is empty and had no kids) or value in format of prepared for Save Kids,
            in case if ReadOutExistingNode.
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieGenerationNode.MaximumKidLineLength">
            <summary>
            Is calculated as LengthOfTheKidsBlockInFile(2 bytes) + (256 * (DefaultPointerLen + 1[byte definition]))
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.SetupKidWithValue(System.Byte,System.Boolean,System.Byte[]@,System.Byte[]@,System.Boolean,System.Boolean@)">
            <summary>
            
            </summary>
            <param name="kid"></param>
            <param name="lastElementOfTheKey"></param>
            <param name="fullKey"></param>
            <param name="value"></param>
            <param name="useExistingPointerToValue"></param>
            <param name="WasUpdated">means that value existed and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.RemoveKid(System.Byte,System.Boolean,System.Byte[]@,System.Boolean@)">
            <summary>
            Pointer to the removing key value can be null, if such key never existed
            </summary>
            <param name="kid"></param>
            <param name="lastElementOfTheKey"></param>
            <param name="key"></param>
            <param name="ptrToValue"></param>
            <param name="WasRemoved">indicates that value existed if true</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.TryOverWriteValuePartially(System.Byte[],System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@)">
            <summary>
            Returns pointer to the newly stored value
            </summary>
            <param name="ptr"></param>
            <param name="value"></param>
            <param name="fullKey"></param>
            <param name="startIndex">from which point we should overwrite value</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.TryOverWriteValue(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Returns pointer to the newly stored value
            </summary>
            <param name="ptr"></param>
            <param name="value"></param>
            <param name="fullKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieGenerationNode.GetQuantityOfReservationSlots">
            <summary>
            Calculating Quantity of Reservations slots for 0 and 1 Evolutions.
            </summary>
            <param name="current"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.JavascriptSerializator.SerializeMJSON(System.Object)">
            <summary>
            Serializes object to JSON from Microsoft
            </summary>
            <param name="objectForSerialization"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.JavascriptSerializator.DeserializeMJSON``1(System.String)">
            <summary>
            Deserializes object from Microsoft JSON string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.StorageLayer.OUT_BUFFER_Table_WriteToTheEnd(System.Byte[])">
            <summary>
            Used only by buffer for flushing data.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32)">
            <summary>
            Creates a new Bloom filter, specifying an error rate of 1/capacity, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            A secondary hash function will be provided for you if your type T is either string or int. Otherwise an exception will be thrown. If you are not using these types please use the overload that supports custom hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new Bloom filter, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            A secondary hash function will be provided for you if your type T is either string or int. Otherwise an exception will be thrown. If you are not using these types please use the overload that supports custom hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,DBreeze.Utils.BloomFilter.Filter{`0}.HashFunction)">
            <summary>
            Creates a new Bloom filter, specifying an error rate of 1/capacity, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, and T is string or int a hash function will be provided for you.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,System.Single,DBreeze.Utils.BloomFilter.Filter{`0}.HashFunction)">
            <summary>
            Creates a new Bloom filter, using the optimal size for the underlying data structure based on the desired capacity and error rate, as well as the optimal number of hash functions.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, and T is string or int a hash function will be provided for you.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.#ctor(System.Int32,System.Single,DBreeze.Utils.BloomFilter.Filter{`0}.HashFunction,System.Int32,System.Int32)">
            <summary>
            Creates a new Bloom filter.
            </summary>
            <param name="capacity">The anticipated number of items to be added to the filter. More than this number of items can be added, but the error rate will exceed what is expected.</param>
            <param name="errorRate">The accepable false-positive rate (e.g., 0.01F = 1%)</param>
            <param name="hashFunction">The function to hash the input values. Do not use GetHashCode(). If it is null, and T is string or int a hash function will be provided for you.</param>
            <param name="m">The number of elements in the BitArray.</param>
            <param name="k">The number of hash functions to use.</param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.Add(`0)">
            <summary>
            Adds a new item to the filter. It cannot be removed.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.Contains(`0)">
            <summary>
            Checks for the existance of the item in the filter for a given probability.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.computeHash(System.Int32,System.Int32,System.Int32)">
            <summary>
            Performs Dillinger and Manolios double hashing. 
            </summary>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.hashInt32(`0)">
            <summary>
            Hashes a 32-bit signed int using Thomas Wang's method v3.1 (http://www.concentric.net/~Ttwang/tech/inthash.htm).
            Runtime is suggested to be 11 cycles. 
            </summary>
            <param name="input">The integer to hash.</param>
            <returns>The hashed result.</returns>
        </member>
        <member name="M:DBreeze.Utils.BloomFilter.Filter`1.hashString(`0)">
            <summary>
            Hashes a string using Bob Jenkin's "One At A Time" method from Dr. Dobbs (http://burtleburtle.net/bob/hash/doobs.html).
            Runtime is suggested to be 9x+9, where x = input.Length. 
            </summary>
            <param name="input">The string to hash.</param>
            <returns>The hashed result.</returns>
        </member>
        <member name="P:DBreeze.Utils.BloomFilter.Filter`1.Truthiness">
            <summary>
            The ratio of false to true bits in the filter. E.g., 1 true bit in a 10 bit filter means a truthiness of 0.1.
            </summary>
        </member>
        <member name="T:DBreeze.Utils.BloomFilter.Filter`1.HashFunction">
            <summary>
            A function that can be used to hash input.
            </summary>
            <param name="input">The values to be hashed.</param>
            <returns>The resulting hash code.</returns>
        </member>
        <member name="T:DBreeze.Storage.IRollbackStorage">
            <summary>
            Used by LTrieRollBack 
            </summary>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.StartCounter(System.String)">
            <summary>
            Starts counter
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.StopCounter(System.String)">
            <summary>
            Stops counter
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.GetCounter(System.String)">
            <summary>
            Returns Counter object.
            Can return NULL if counter not found
            </summary>
            <param name="counterName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut">
            <summary>
            Prints out stat for all counters without clearing statistic 
            </summary>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut(System.String)">
            <summary>
            Prints out counter without clearing statistic for this counter
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut(System.String,System.Boolean)">
            <summary>
            Prints out specified counter.
            </summary>
            <param name="counterName"></param>
            <param name="withClearingCounter"></param>
        </member>
        <member name="M:DBreeze.Diagnostic.SpeedStatistic.PrintOut(System.Boolean)">
            <summary>
            Prints out stats for all counters
            </summary>
            <param name="withResetingStatistic">resets statistic</param>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.ManagedThreadId">
            <summary>
            Managed threadId of the transaction
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.#ctor(DBreeze.Transactions.TransactionUnit)">
            <summary>
            
            </summary>
            <param name="transactionUnit"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SynchronizeTables(System.Collections.Generic.List{System.String})">
            <summary>
            Use before any table modification command inside of the transaction.
            <para>In case if transaction is going to modify only 1 table, reservation is not necessary, there is no danger of the deadlock.</para>
            <para></para>
            <para>Table Names available patterns:</para>
            <para>$ * #</para>
            <para>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures</para>
            <para># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</para>
            <para>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123;  Items$ !U Items123/Pictures </para>
            </summary>
            <param name="tablesNamesPatterns">can be either tableName or pattern like Articles#/Items*</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SynchronizeTables(System.String[])">
            <summary>
             Use before any table modification command inside of transaction
            <para>In case if transaction is going to modify only 1 table, reservation is not necessary, there is no danger of the deadlock.</para>
            <para></para>
            <para>Table Names available patterns:</para>
            <para>$ * #</para>
            <para>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures</para>
            <para># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</para>
            <para>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123;  Items$ !U Items123/Pictures </para>
            </summary>
            <param name="tablesNamesPatterns"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.AddOpenTable(System.String)">
            <summary>
            This must be called only if we use not cached opening
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.transactionWriteTables">
            <summary>
            Small buffer for the tables where we are going to write in.
            It will boost performance in case of Bulk inserts or updates
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.GetWriteTableFromBuffer(System.String)">
            <summary>
            Automatically tries to take Write Table from buffer or from system, throws exception if smth. happens
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Transactions.Transaction.transactionReadTables">
            <summary>
            Small buffer for the tables, we are going to read from.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.GetReadTableFromBuffer(System.String,DBreeze.Tries.ITrieRootNode@)">
            <summary>
            IS USED BY NON-RANGE SELECTS OPERATORS
            Retuns LTrie (or later by necessity ITrie) and as out variable ReadRootNode which must be used for READ FUNC data acquiring.
            READ FUNCs calling this proc will receive table and as out var. root, this root will be supplied to the trie.
            If root is null, then write root will be used.
            If table is null - table doesn't exist.
            </summary>
            <param name="tableName"></param>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.GetReadTableFromBuffer(System.String,DBreeze.Tries.ITrieRootNode@,System.Boolean)">
            <summary>
            Retuns LTrie (or later by necessity ITrie) and as out variable ReadRootNode which must be used for READ FUNC data acquiring.
            READ FUNCs calling this proc will receive table and as out var. root, this root will be supplied to the trie.
            If root is null, then write root will be used.
            If table is null - table doesn't exist.
            </summary>
            <param name="tableName"></param>
            <param name="root"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Commit">
            <summary>
            Commits all changes made inside of the current transaction.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Rollback">
            <summary>
            Rollsback all changes made by current transaction before last Commit.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0)">
            <summary>
            Removes specified key, if it existed
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveKey``1(System.String,``0,System.Boolean@)">
            <summary>
            Removes specified key, if it existed
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system, before removing</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.RemoveAllKeys(System.String,System.Boolean)">
            <summary>
            Removes all records in the table
            </summary>
            <param name="tableName"></param>
            <param name="withFileRecreation">also recreates table file, if true</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ChangeKey``1(System.String,``0,``0)">
            <summary>
            Renames key old its value on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="oldKey"></param>
            <param name="newKey"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ChangeKey``1(System.String,``0,``0,System.Byte[]@)">
            <summary>
            Renames key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.ChangeKey``1(System.String,``0,``0,System.Byte[]@,System.Boolean@)">
            <summary>
            Renames key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
            <param name="WasChanged">indicates that oldKey existed and was succesfully changed</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDataBlock(System.String,System.Byte[],System.Byte[])">
            <summary>
            Insert a dynamic size data block in the table storage, returns fixed 16 bytes length identifier
            <para></para>
            which can be stored in a table value from specified index.
            <para></para>
            Retrieve such DataBlock we can using Row.GetDataBlock.
            <para>The same statement is used to update datablock, received value must update row value who holds reference to it.</para>
            <para>Must be used as row column with dynamic length</para>
            </summary>
            <param name="tableName"></param>
            <param name="initialPointer">if null creates new data block, if not null tries to overwrite existing data block</param>
            <param name="data"></param>
            <returns>returns created data block parameters of fixed 16 bytes length, which can be stored in the row value
            <para>and later reused for getting data block back</para>
            </returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDataBlock(System.String,System.Byte[])">
            <summary>
            Another way (second is via row by index where pointer is stored) to get stored data block
            </summary>
            <param name="tableName"></param>
            <param name="ptrToDataBlock">16 byte pointer identifier, received after insertDataBlock</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1,System.Byte[]@)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Insert``2(System.String,``0,``1,System.Byte[]@,System.Boolean@)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertPart``2(System.String,``0,``1,System.UInt32)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertPart``2(System.String,``0,``1,System.UInt32,System.Byte[]@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param> 
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertPart``2(System.String,``0,``1,System.UInt32,System.Byte[]@,System.Boolean@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para>
            <para>Second generic parameter represents datatype of the inserting parameter in the middle of the value</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param> 
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param> 
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertTable``1(System.String,``0,System.UInt32)">
            <summary>
            Will create internal table if it doesn't exist and return it.
            </summary>
            <param name="tableName"></param>
            <param name="tableNumber"></param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectTable``1(System.String,``0,System.UInt32)">
            <summary>
            If internal table doesn't exist will not create it but must always return 
            NestedTable, which will be internally marked as absent. 
            In this case all Add/Remove operations will have to throw exception and
            Select operations will return their default values
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDictionary``3(System.String,``0,System.Collections.Generic.Dictionary{``1,``2},System.UInt32,System.Boolean)">
            <summary>
            Inserts a dictionary into master-table row.
            <para></para>
            Actually creates a new table inside of master table row and handles it like table with TDictionaryKey key any TDictionaryValue value.
            <para></para>
            If new Dictionary is supplied then non-existing keys in supplied DB will be removed from db
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get dictionary use SelectDictionary</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertDictionary``2(System.String,System.Collections.Generic.Dictionary{``0,``1},System.Boolean)">
            <summary>
            Inserts a dictionary into master-table
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDictionary``3(System.String,``0,System.UInt32)">
            <summary>
            Selects complete table from master-table row nested table, by row nested-table index as Dictionary.
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDictionary``2(System.String)">
            <summary>
            Selects complete master-table as Dictionary
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertHashSet``2(System.String,``0,System.Collections.Generic.HashSet{``1},System.UInt32,System.Boolean)">
            <summary>
            Inserts a HashSet (unique list of Keys) into master-table row.
            <para></para>
            Actually creates a new table inside of master table row and handles it like table with THashSetKey key any byte[] == null value.
            <para></para>
            If new HashSet is supplied then non-existing keys in supplied DB will be removed from db (withValuesRemove=true)
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get HashSet use SelectHashSet</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.InsertHashSet``1(System.String,System.Collections.Generic.HashSet{``0},System.Boolean)">
            <summary>
            Inserts a HashSet (unique list of Keys) into master-table itself
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectHashSet``2(System.String,``0,System.UInt32)">
            <summary>
            Selects complete table from master-table row nested table, by row nested-table index as HashSet (unique list of Keys).
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectHashSet``1(System.String)">
            <summary>
            Selects complete master-table as a HashSet into memory
            </summary>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Count(System.String)">
            <summary>
            Returns records quantity inside of the the table
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Max``2(System.String)">
            <summary>
            Returns row with the maximal key.
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Min``2(System.String)">
            <summary>
            Returns row with the minimal key.
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Select``2(System.String,``0)">
            <summary>
            Selects specified key from the table
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.Select``2(System.String,``0,System.Boolean)">
            <summary>
            Selects specified key from the table
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, select will return key/value,</para>
            <para>like it was before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectDirect``2(System.String,System.Byte[])">
            <summary>
            Returns Row by supplying direct pointer to key/value in the file.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="refToInsertedValue"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForward``2(System.String)">
            <summary>
            Iterates table forward (ordered by key ascending).
            <para>Always check row.Exists property</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForward``2(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackward``2(System.String)">
            <summary>
            Iterates table backward (ordered by key descending).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackward``2(System.String,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartFrom``2(System.String,``0,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartFrom``2(System.String,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartFrom``2(System.String,``0,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartFrom``2(System.String,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="includeStartFromKey">if start key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified StartKey up to specified StopKey
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending). Starting from specified StartKey up to specified StopKey
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified StartKey down to specified StopKey.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardFromTo``2(System.String,``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending). Starting from specified StartKey down to specified StopKey.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startKey"></param>
            <param name="includeStartKey">if start key will be included in the final result</param>
            <param name="stopKey"></param>
            <param name="includeStopKey">if stop key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWith``2(System.String,``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWith``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWithClosestToPrefix``2(System.String,``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardStartsWithClosestToPrefix``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWithClosestToPrefix``2(System.String,``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWithClosestToPrefix``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWith``2(System.String,``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardStartsWith``2(System.String,``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting and including specified key part (big-endian from byte[] point of view)</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkip``2(System.String,System.UInt64)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from the first key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkip``2(System.String,System.UInt64,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from the first key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkip``2(System.String,System.UInt64)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from the last key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkip``2(System.String,System.UInt64,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from the last key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkipFrom``2(System.String,``0,System.UInt64)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from specified key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectForwardSkipFrom``2(System.String,``0,System.UInt64,System.Boolean)">
            <summary>
            Iterates table forward (ordered by key ascending), skipping from specified key specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkipFrom``2(System.String,``0,System.UInt64)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from specified key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.Transaction.SelectBackwardSkipFrom``2(System.String,``0,System.UInt64,System.Boolean)">
            <summary>
            Iterates table backward (ordered by key descending), skipping from specified key back specified quantity of records
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="skippingQuantity">if start key will be included in the final result</param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Transactions.Transaction.Rtbe">
            <summary>
            Technical class, who holds reference to the table and its last modification dts
            ReadTableElement
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.ITransactable.ITRCommitFinished">
            <summary>
            Is called by Transaction Journal, to make root available for all and delete rollback file
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.ITransactable.TransactionIsFinished(System.Int32)">
            <summary>
            Transaction Coordinator notifies table that transaction is finished
            and table can clear ModificationThreadId and run RollBackProcedure (if transaction was finised without Commit)
            </summary>
            <param name="transactionThreadId"></param>
        </member>
        <member name="M:DBreeze.Transactions.ITransactable.ModificationThreadId(System.Int32)">
            <summary>
            TransactionsCoordinator via this function will explain to the table that transactionThreadId thread will make modificatons.
            later when calling fetch functions, table will be able to return different RootNodes depending upon the thread
            </summary>
            <param name="transactionThreadId"></param>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.POINTER_LENGHT">
            <summary>
            User parameter for the table.
            <para>Quantity of bytes which represent pointer inside of raw file (5 bytes = 1 Terrabyte, so the trie with 5 bytes pointer len can't be longer then 1 terrabyte).</para>
            <para>If you plan to have your table more then 1TB, set this value to bigger value, before table creation</para>
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.ROOT_SIZE">
            <summary>
            For internal needs
            Quantity of bytes which reside ROOT_NODE
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.ROOT_START">
            <summary>
            For internal needs.
            Offset where root should reside in the file
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.RollerBack">
            <summary>
            For internal needs.
            Default is null, then LTrie, creates its own RollerBack.
            If not null, then DbInTable supplied it and Ltrie.Cache will skip creating the new one but will use for save and restore data supplied one.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.InternalTable">
            <summary>
            If table is for internal purposes (like Scheme or Transaction Journal)
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.SkipStorageBuffer">
            <summary>
            For now internal property, but later can become public.
            Skips usage of StorageBuffer inside of StorageLayer
            </summary>
        </member>
        <member name="F:DBreeze.Storage.TrieSettings.AlternativeTableStorageFolder">
            <summary>
            Next three concern alternative table storage pathes.
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RollbackDiskStorage.RecreateRollbackFile">
            <summary>
            Used in initial rollback, after backup restoring, probably we can re-create file (for non-virtual FS) only disk file re-creation
            </summary>
        </member>
        <member name="M:DBreeze.Storage.RollbackDiskStorage.WriteRFH(System.Int64,System.Byte[])">
            <summary>
            Writes Rollback file helper
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.RollbackDiskStorage.ReadRFH">
            <summary>
            Reads Rollback file helper
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.GetTable``1(``0,System.UInt32)">
            <summary>
            You are already in the table
            <para>This function will help to access another table by parent table key and its value index</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.CloseTable">
            <summary>
            Tries to close the table if no other threads are using it.
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertDataBlock(System.Byte[],System.Byte[])">
            <summary>
            Insert a dynamic size data block in the table storage, returns fixed 16 bytes length identifier
            <para></para>
            which can be stored in a table value from specified index.
            <para></para>
            Retrieve such DataBlock we can using Row.GetDataBlock.
            <para>The same statement is used to update datablock, received value must update row value who holds reference to it.</para>
            <para>Must be used as row column with dynamic length</para>
            </summary>
            <param name="initialPointer">if null creates new data block, if not null tries to overwrite existing data block</param>
            <param name="data"></param>
            <returns>returns created data block parameters of fixed 16 bytes length, which can be stored in the row value
            <para>and later reused for getting data block back</para>
            </returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDataBlock(System.Byte[])">
            <summary>
            Another way (second is via row by index where pointer is stored) to get stored data block
            </summary>
            <param name="initialPointer"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1,System.Byte[]@)">
            <summary>
            Inserts or updates the key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Insert``2(``0,``1,System.Byte[]@,System.Boolean@)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="refToInsertedValue"></param>
            <param name="WasUpdated"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertDictionary``3(``0,System.Collections.Generic.Dictionary{``1,``2},System.UInt32,System.Boolean)">
            <summary>
            Inserts a dictionary into nested-table row.
            <para></para>
            Designed for simple dictionary data types.
            <para></para>
            Actually creates a new table inside of nested table row and handles it like dictionary.
            <para></para>
            If new Dictionary is supplied then non-existing keys in supplied DB will be removed from db
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get dictionary use SelectDictionary</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
            <returns>Returns Nested Table where insert was made</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertDictionary``2(System.Collections.Generic.Dictionary{``0,``1},System.Boolean)">
            <summary>
            Inserts dictionary into current nested table.
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied dictionary will be removed from db, otherwise only appended and updated</param>
            <returns>current nested table</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDictionary``3(``0,System.UInt32)">
            <summary>
            Selects complete table from nested-table row nested table, by row nested-table index as Dictionary.
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDictionary``2">
            <summary>
            Selects completely current nested-table as a Dictionary.
            </summary>
            <typeparam name="TDictionaryKey"></typeparam>
            <typeparam name="TDictionaryValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertHashSet``2(``0,System.Collections.Generic.HashSet{``1},System.UInt32,System.Boolean)">
            <summary>
            Inserts a HashSet (unique list of Keys) into nested-table row.
            <para></para>
            Actually creates a new table inside of nested table row and handles it like table with THashSetKey key any byte[] == null value.
            <para></para>
            If new HashSet is supplied then non-existing keys in supplied DB will be removed from db (withValuesRemove=true)
            <para>new values will be inserted, changed values will be updated</para>
            <para>To get HashSet use SelectHashSet</para>
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="value"></param>
            <param name="tableIndex"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
            <returns>Returns Nested Table where insert was made</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertHashSet``1(System.Collections.Generic.HashSet{``0},System.Boolean)">
            <summary>
            Inserts HashSet into current nested-table
            </summary>
            <typeparam name="THashSetKey"></typeparam>
            <param name="value"></param>
            <param name="withValuesRemove">if true, then values which are not in supplied HashSet will be removed from db, otherwise only appended and updated</param>
            <returns>current nested table</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectHashSet``2(``0,System.UInt32)">
            <summary>
            Selects complete table from nested-table row nested table, by row nested-table index as HashSet (unique list of Keys).
            </summary>
            <typeparam name="TTableKey"></typeparam>
            <typeparam name="THashSetKey"></typeparam>
            <param name="tableName"></param>
            <param name="key"></param>
            <param name="tableIndex"></param>
            <returns>HashSet</returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectHashSet``1">
            <summary>
            Returns completely current nested-table as a HashSet (unique list of Keys).
            </summary>
            <typeparam name="THashSetKey"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertPart``2(``0,``1,System.UInt32)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para> 
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertPart``2(``0,``1,System.UInt32,System.Byte[]@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para> 
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.InsertPart``2(``0,``1,System.UInt32,System.Byte[]@,System.Boolean@)">
            <summary>
            Inserts or updates the key value starting from startIndex.
            <para>If there were no value before, value byte[] array till startindex wll be filled with byte[] {0}</para>
            <para>If value is smaller then startIndex, value will be expanded.</para> 
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="refToInsertedValue">returns ptr in the file to the value and key (always 8 bytes)</param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Select``2(``0)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Select``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, select will return key/value,</para>
            <para>like it was before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectDirect``2(System.Byte[])">
            <summary>
            <para>EXPERIMENTAL</para>
            Returns Row by supplying direct pointer to key/value in the file.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="refToInsertedValue"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveAllKeys">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.RemoveKey``1(``0,System.Boolean@)">
            <summary>
            Removes a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="key"></param>
            <param name="WasRemoved">indicates that key existed in the system</param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.ChangeKey``1(``0,``0)">
            <summary>
            Renames old key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="oldKey"></param>
            <param name="newKey"></param>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.ChangeKey``1(``0,``0,System.Byte[]@)">
            <summary>
            Renames old key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.ChangeKey``1(``0,``0,System.Byte[]@,System.Boolean@)">
            <summary>
            Renames old key on the new one
            </summary>
            <typeparam name="TKey"></typeparam>
            <param name="oldKey"></param>
            <param name="newKey"></param>
            <param name="ptrToNewKey">return pointer to the new value in the file (always 8 bytes)</param>
            <param name="WasChanged">indicates that oldKey existed and was succesfully changed</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Count">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Max``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.Min``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForward``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForward``2(System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackward``2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackward``2(System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartFrom``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartFrom``2(``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartFrom``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartFrom``2(``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="includeStartFromKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardFromTo``2(``0,System.Boolean,``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardFromTo``2(``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardFromTo``2(``0,System.Boolean,``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardFromTo``2(``0,System.Boolean,``0,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startKey"></param>
            <param name="includeStartKey"></param>
            <param name="stopKey"></param>
            <param name="includeStopKey"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWith``2(``0)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWith``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWithClosestToPrefix``2(``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardStartsWithClosestToPrefix``2(``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table forward (ordered by key ascending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slam"</para>
            <para>"slash"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWithClosestToPrefix``2(``0)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWithClosestToPrefix``2(``0,System.Boolean)">
            <summary>
            <para>Mostly can be used for string or byte[] keys</para>
            <para>Iterates table backward (ordered by key descending). Starting from the prefix or closest to the prefix part (big-endian from byte[] point of view)</para>
            <para>If we have in a table keys:</para>
            <para>"check"</para>
            <para>"sam"</para>
            <para>"slam"</para>
            <para>"slash"</para>
            <para>"what"</para>
            <para>our search prefix is "slap", we will get:</para>
            <para>"slash"</para>
            <para>"slam"</para>
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithClosestPrefix"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWith``2(``0)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardStartsWith``2(``0,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="startWithKeyPart"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkip``2(System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkip``2(System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkip``2(System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkip``2(System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkipFrom``2(``0,System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectForwardSkipFrom``2(``0,System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkipFrom``2(``0,System.UInt64)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.DataTypes.NestedTable.SelectBackwardSkipFrom``2(``0,System.UInt64,System.Boolean)">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="key"></param>
            <param name="skippingQuantity"></param>
            <param name="AsReadVisibilityScope">Metters only for transactions where this table is in modification list
            <para>(by SynchronizeTables or just insert, remove.. any key modification command).</para>
            <para>If this parameter set to true, enumerator will return key/value,</para>
            <para>like they were, before transaction started (and parallel reading threds can see it).</para>
            </param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.#ctor">
            <summary>
            Creates open Gate
            </summary>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.PutGateHere">
            <summary>
            Sets Gate in the code
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.PutGateHere(System.Int32)">
            <summary>
            If gate is closed then it will be closed timeout time in milliseconds
            </summary>
            <param name="milliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.DbThreadsGator.PutGateHere(System.Int32,System.Boolean)">
            <summary>
            If gate is closed then it will be closed timeout time in milliseconds
            </summary>
            <param name="milliseconds"></param>
            <param name="milliseconds">exitContext</param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Storage.TrieDiskStorage.eof">
            <summary>
            Pointer to the end of file
            </summary>
        </member>
        <member name="M:DBreeze.Storage.TrieDiskStorage.WriteToTheEnd(System.Byte[]@)">
            <summary>
            Writes To The End of File,
            returns position as byte array
            of size treeSettings.POINTER_LENGHT
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.TrieDiskStorage.Read(System.Byte[],System.Int32)">
            <summary>
            Reads byte array using offset as byte array
            </summary>
            <param name="offset"></param>
            <param name="quantity"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieKidsInNode.ValueIsEmpty">
            <summary>
            Indicates that Kids Line contains no Value-Kid
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieKidsInNode.ParseKids(System.Byte[]@)">
            <summary>
            Returns quantity of reservation slots
            </summary>
            <param name="bKids"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieKidsInNode.GetKidValue">
            <summary>
            Gets Value kid (before 0-255)
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Storage.StorageBuffer">
            <summary>
            Buffer is used to accumulate data before flushing.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.StorageBuffer.FilesLimit">
            <summary>
            Quantity of parallel writing files, using buffer (can be adjusted)
            </summary>
        </member>
        <member name="F:DBreeze.Storage.StorageBuffer.limit">
            <summary>
            Quantity of bytes before flushing
            </summary>
        </member>
        <member name="F:DBreeze.Storage.StorageBuffer.BufferEOF">
            <summary>
            Always represents EOF in buffer
            </summary>
        </member>
        <member name="M:DBreeze.Storage.StorageBuffer.Write_ToTheEnd(System.Byte[]@,System.Int32@)">
            <summary>
            if returns true, Saved to buffer
            </summary>
            <param name="data"></param>
            <param name="startedToSave">returns ptr from which new data will be saved</param>
            <returns>returns true if data was saved into buffer</returns>
        </member>
        <member name="M:DBreeze.Scheme.GetPhysicalPathToTheUserTable(System.String)">
            <summary>
            ONLY FOR INTERNAL NEEDS, lock must be handeled by outer procedure.
            Users must use GetTablePathFromTableName.
            Transactions Journal after start will try to delete RollbackFiles of the finished transactions.
            For this it needs to know exact pathes.
            For now all tables stored in one folder. Later we will have extra config file which lets to reside 
            some of tables in the other folders. 
            This function is an access globalizer to physical file locations by userTableName.
            !!!!TRAnJRNL, WHEN RESTORES ROLLBACK, MUST REFER TO Scheme trie settings in the future, FOR NOW DEFAULT
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetTablePathFromTableName(System.String)">
            <summary>
            Returns physical path to the table file, if table doesn't exists in the Scheme returns String.Empty
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetUserTableNameAsByte(System.String)">
            <summary>
            Adds static prefix to all user table names, to
            make selection of tables for different purposes easier with StartsWith function
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetTable(System.String)">
            <summary>
            Returns table for READ, WRITE FUNC
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.CheckAlternativeTableLocationsIntersections(System.String,System.String@)">
            <summary>
            Checks if in configuration was supplied alternative path for table location.
            Returns true if intersection was found.
            Alternative Path equals to String.Empty - locate in Memory
            </summary>
            <param name="userTableName"></param>
            <param name="alternativePath"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.CloseTables(System.Collections.Generic.Dictionary{System.String,System.Nullable{System.UInt64}})">
            <summary>
            Called by Transaction, when it's time to be Disposed and close tables.
            Tables will be closed only in case of other threads don't use it.
            </summary>
            <param name="closeOpenTables"></param>
        </member>
        <member name="M:DBreeze.Scheme.DeleteAllReleatedTableFiles(System.String)">
            <summary>
            Used by GetTableFor Write, if table is newly created and we have such file name
            </summary>
            <param name="fullTableFilePath"></param>
        </member>
        <member name="M:DBreeze.Scheme.IfUserTableExists(System.String)">
            <summary>
            Returns if user table exists
            </summary>
            <param name="userTableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.GetUserTableNamesStartingWith(System.String)">
            <summary>
            Returns List of user tables starting from specified mask.
            If mask is String.Empty returns all user tables
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Scheme.DeleteTable(System.String)">
            <summary>
            Deletes user table
            </summary>
            <param name="userTableName"></param>
        </member>
        <member name="M:DBreeze.Scheme.RenameTable(System.String,System.String)">
            <summary>
            Renames user table, if it existed.
            <para>Safe, will make operation only when other threads stop to work with the oldTable</para>
            </summary>
            <param name="oldUserTableName"></param>
            <param name="newUserTableName"></param>
        </member>
        <member name="M:DBreeze.Scheme.RenameTableInternal(System.String,System.String)">
            <summary>
            Renames user table, if it existed.
            <para>If there are threads which are working with this table, rename will not be finished and will return false</para>
            </summary>
            <param name="oldUserTableName"></param>
            <param name="newUserTableName"></param>
            <returns>true if successfully renamed, otherwise false</returns>
        </member>
        <member name="T:DBreeze.DataTypes.DbCustomSerializer`1">
            <summary>
            <para>Custom Serializer</para>
            <para></para>
            <para>To support JSON.NET, make a reference to their library and then somewhere before engine init add 2 lines:</para>
            <para>CustomSerializator.Serializator = JsonConvert.SerializeObject;</para>
            <para>CustomSerializator.Deserializator = JsonConvert.DeserializeObject;</para>
            <para></para>
            <para>Possible to make like this, without class instantiating:</para>
            <para>List&lt;string&gt; aa = new List&lt;string&gt;();</para>
            <para>aa.Add("test1")</para>
            <para>aa.Add("test2")</para>
            <para>-----inside of transaction---------</para>
            <para>tran.Insert&lt;uint, DbCustomSerializer&lt;List&lt;string&gt;&gt; &gt;("t1", i, aa);</para>
            <para>-----------------------------------</para>
            <para>foreach (var row in tran.SelectForward&lt;uint, DbCustomSerializer&lt;List&lt;string&gt;&gt; &gt;("t1"))</para>
            <para>Console.WriteLine("K: {0}; V: {1}", row.Key.ToString(), (row.Value == null) ? "NULL" : row.Value.Get.Count().ToString());</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DBreeze.DataTypes.DbCustomSerializer`1.SerializedObject">
            <summary>
            Returns serialized string representing the internal object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbCustomSerializer`1.Get">
            <summary>
            Gets deserialized object
            </summary>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.#ctor(System.Int32,System.Int32,DBreeze.Storage.MemoryStorage.eMemoryExpandStartegy)">
            <summary>
            
            </summary>
            <param name="initialCapacity">Initial Memory Capacity in bytes</param>
            <param name="increaseOnBytes">Rules is strategy is FIXED_LENGTH_INCREASE, quantity of bytes to increse memory</param>
            <param name="strategy">Memory expand strategy</param>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Clear(System.Boolean)">
            <summary>
            Sets EOF pointer to 0.
            <para>USE withInternalArrayResize by necessity. If it's true then array will be re-initialized to initial capacity</para>
            <para>this also will call GC and the whole process will take some time.</para>
            <para>If false, only pointer EOF will be set to 0, capacity of the array will not be changed - very fast</para>
            </summary>
            <param name="withInternalArrayResize"></param>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.GetFullData">
            <summary>
            Can return null
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Read(System.Int32,System.Int32)">
            <summary>
            If lenght = 0 returns new byte[0]
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Storage.MemoryStorage.Write(System.Byte[]@,System.Int32)">
            <summary>
            Must be called from lock
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
        </member>
        <member name="P:DBreeze.Storage.MemoryStorage.EOF">
            <summary>
            End of file
            </summary>
        </member>
        <member name="T:DBreeze.LianaTrie.NestedTablesCoordinator">
            <summary>
            Represents a bound to the LTrie nested tables coordinator.
            1. Gets ability to remember Inserted Tables to perform cascade commit.
            2. Rebind internal root-start if 2 or more horizontal tables are inserted into 1 value during one transaction (value expand case)
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.NestedTablesCoordinator._nestedTables">
            <summary>
            Key is a pointer to the full value, then in the value new Dictionary
            where key is root_start
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.NestedTablesCoordinator.ModificationThreadId">
            <summary>
            Will be taken into consideration only from MasterTrie.
            Set up to -1 after Commit and Rollback, Set To Thread id when tran.InsertTable is called
            using this flag we will be able to regulate returns (based on useCache or not for nested Tables)
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.AddNestedTable(System.Byte[]@,System.UInt64,System.Int64,DBreeze.DataTypes.NestedTableInternal)">
            <summary>
            LTrie makes in case of InsertTable call
            </summary>
            <param name="nestedTable"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.TransactionalCommitFinished">
            <summary>
            Committing nested tables
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.Commit">
            <summary>
            Committing nested tables
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.TransactionalCommit">
            <summary>
            Transactional Commit Nested
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.TransactionalRollback">
            <summary>
            Transactional Rollback nested
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.GetTable(System.Byte[]@,System.Int64)">
            <summary>
            Returns null if table is not in the coordinator, otherwise returns reference to the table
            </summary>
            <param name="fullValueStart"></param>
            <param name="rootStart"></param>
            <returns></returns>      
        </member>
        <member name="M:DBreeze.LianaTrie.NestedTablesCoordinator.Remove(System.Byte[]@)">
            <summary>
            Cascade remove all of all nested and sub-nested tables under the key
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:DBreeze.Utils.Hash.MurMurHash.MixedMurMurHash3_128(System.Byte[])">
            <summary>
            128 bit mixed MurMurhash3
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Hash.MurMurHash.MixedMurMurHash3_64(System.Byte[])">
            <summary>
            64 bit mixed MurMurhash3
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Hash.MurMurHash.MurmurHash3(System.Byte[],System.UInt32)">
            <summary>
            32 bit
            </summary>
            <param name="data"></param>
            <param name="seed"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Transactions.TransactionsJournal._transactionsTables">
            <summary>
            Key: transaction number, counting up from the engine start
            Value: Dictionary containing as a Key usertableName, as value link to the table
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsJournal.AddTableForTransaction(System.UInt64,DBreeze.Transactions.ITransactable)">
            <summary>
            Every table inside of the transaction before calling Transaction Commit, goes to this in-memory dictionary
            </summary>
            <param name="tranNumber"></param>
            <param name="table"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsJournal.RemoveTransactionFromDictionary(System.UInt64)">
            <summary>
            Used in case of failed transaction of multiple tables, to clean in-memory dictionary
            </summary>
            <param name="tranNumber"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsJournal.GetTransactionNumber">
            <summary>
            Returns new transaction number
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Utils.DbReaderWriterSpinLock">
            <summary>
            Temporar wrapper
            </summary>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.EnlargeByteArray_BigEndian(System.Byte[],System.Int32)">
            <summary>
            Enlarges byte array till given size filling with 0 from start the rest of the length.
            Ex: byte[] a = new byte[] {1,2,3}; a.EnlargeByteArray_BigEndian(6) = new byte[] {0,0,0,1,2,3};
            If array for enlargement equals null new byte[size] will be returned, if array for enlargement length more or equal size then the same array will be returned.
            </summary>
            <param name="ar"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.EnlargeByteArray_LittleEndian(System.Byte[],System.Int32)">
            <summary>
            Enlarges byte array till given size filling with 0 after values of the supplied array.
            Ex: byte[] a = new byte[] {1,2,3}; a.EnlargeByteArray_LittleEndian(6) = new byte[] {1,2,3,0,0,0};
            If array for enlargement equals null new byte[size] will be returned, if array for enlargement length more or equal size then the same array will be returned.
            </summary>
            <param name="ar"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Substring(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Substring int-dimensional byte arrays
            </summary>
            <param name="ar"></param>
            <param name="startIndex"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Substring(System.Byte[],System.Int32)">
            <summary>
            Substring int-dimensional byte arrays from and till the end
            </summary>
            <param name="ar"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CloneArray(System.Byte[])">
            <summary>
            Works only for int-dimesional arrays only
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CopyInside(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies one array (source) into another (destination extension).
            <para>Destination array is taken as this</para>
            </summary>
            <param name="destArray"></param>
            <param name="destOffset"></param>
            <param name="srcArray"></param>
            <param name="srcOffset"></param>
            <param name="quantity"></param>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CopyInside(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Copies fully one array (source) into another (destination extension). Extra parameter destination offset.
            <para>Doesn't return anything, but changes destination array by reference.</para>
            <para>Can Throw exception if destArray.Length less then (destOffset + srcArray.Length)</para>
            <para>, for this use CopyInsideArrayCanGrow</para>
            </summary>
            <param name="destArray"></param>
            <param name="destOffset"></param>
            <param name="srcArray"></param>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.CopyInsideArrayCanGrow(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Will return finally created array 
            <para>byte[] b = new byte[] { 1, 2, 3 };</para>
            <para>byte[] v = b.CopyInsideArrayCanGrow(1, new byte[] { 5, 6, 7 });</para>
            <para>will return v = byte[] { 1, 5, 6, 7 }</para>
            </summary>
            <param name="destArray"></param>
            <param name="destOffset"></param>
            <param name="srcArray"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.RemoveLeadingElement(System.Byte[],System.Byte)">
            <summary>
            Removes leading element from the array.
            Never returns null, but can return new byte[] {} (Length=0)
            </summary>
            <param name="array"></param>
            <param name="elementToRemove"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Reverse(System.Byte[])">
            <summary>
            Array.Reverse is the same fast, but reverses by reference the parameter-array, what is not acceptable
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Byte[],System.Byte[])">
            <summary>
            Fastest Method. Works only for int-dimesional arrays only. 
            When necessary to concat many arrays use ConcatMany
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Byte,System.Byte)">
            <summary>
            FOR OPTIMITATION LIKE Concat(this byte[] ar1, byte ar2)
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Concat(System.Byte,System.Byte[])">
            <summary>
            FOR OPTIMITATION LIKE Concat(this byte[] ar1, byte ar2)
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ConcatMany(System.Byte[],System.Byte[][])">
            <summary>
            Fast when necessary to concat many arrays
            Example: byte[] s = new byte[] { 1, 2, 3 }; s.ConcatMany(new byte[] { 2, 3, 4 }, new byte[] { 3, 7, 8 }, new byte[] { 9, 10, 11 });
            Also: ((byte[])null).ConcatMany(new byte[] { 2, 3, 4 }, new byte[] { 3, 7, 8 }, new byte[] { 9, 10, 11 });
            </summary>
            <param name="ar1"></param>
            <param name="ar2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.indexOfStringInByteArray(System.Byte[],System.String,System.Text.Encoding)">
            <summary>
            If not found returns -1
            </summary>
            <param name="ar"></param>
            <param name="search"></param>
            <param name="en"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Byte(System.Byte[])">
            <summary>
            From 1 byte array returns byte
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Byte_NULL(System.Byte[])">
            <summary>
            From 2 bytes array returns byte?
            If array length is not equal to 2 bytes returns null
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_DateTime(System.Byte[])">
            <summary>
            8-byte array tries to convert to DateTime
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_DateTime_zCompatibility(System.Byte[])">
            <summary>
            DON't use it (only for compatibility reasons described in docu from [20120922])
            BigEndian 8 bytes tries to convert to Ticks
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_DateTime_NULL(System.Byte[])">
            <summary>
            Returns DateTime? from 9-byte array
            If array is not equal 9 bytes returns null
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Bool_NULL(System.Byte[])">
            <summary>
            Returns bool? from 1-byte array
            if value length != 1 returns null.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Char(System.Byte[])">
            <summary>
            Converts 2 bytes byte[] into Unicode char
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Char_NULL(System.Byte[])">
            <summary>
            Converts 3 bytes byte[] into Unicode char?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_SByte(System.Byte[])">
            <summary>
            Converts 1 byte array into sbyte
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_SByte_NULL(System.Byte[])">
            <summary>
            Converts 2 bytes array into sbyte?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_BigEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in BigEndian order (highest byte first, lowest last) makes short.
            If array not equal 2 bytes throws exception. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_LittleEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in LittleEndian order (lowest byte first, highest last) makes short.
            If array not equal 2 bytes throws exception. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_BigEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in BigEndian order (highest byte first, lowest last) makes short?.
            If array not equal 3 bytes returns null. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int16_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in LittleEndian order (lowest byte first, highest last) makes short.
            If array not equal 3 bytes returns null. (-32,768 to 32,767)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_BigEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in BigEndian order (highest byte first, lowest last) makes ushort.
            If array not equal 2 bytes throws exception. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_LittleEndian(System.Byte[])">
            <summary>
            From 2 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ushort.
            If array not equal 2 bytes throws exception. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_BigEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in BigEndian order (highest byte first, lowest last) makes ushort?.
            If array not equal 3 bytes returns null. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt16_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 3 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ushort?.
            If array not equal 3 bytes returns null. (0 to 65,535)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_BigEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in BigEndian order (highest byte first, lowest last) makes int.
            If array not equal 4 bytes throws exception. (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_LittleEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in LittleEndian order (lowest byte first, highest last) makes int.
            If array not equal 4 bytes throws exception. (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_BigEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in BigEndian order (highest byte first, lowest last) makes int.
            If array is not equal 5 bytes returns null. Range is (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int32_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in LittleEndian order (lowest byte first, highest last) makes int.
            If array not equal 5 bytes returns null. (-2,147,483,648 to 2,147,483,647)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_BigEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in BigEndian order (highest byte first, lowest last) makes uint.
            If array not equal 4 bytes throws exception. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_LittleEndian(System.Byte[])">
            <summary>
            From 4 bytes array which is in LittleEndian order (lowest byte first, highest last) makes uint.
            If array not equal 4 bytes throws exception. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_BigEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in BigEndian order (highest byte first, lowest last) makes uint?.
            If array not equal 5 bytes returns null. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt32_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 5 bytes array which is in LittleEndian order (lowest byte first, highest last) makes uint?.
            If array not equal 5 bytes returns null. (0 to 4.294.967.295)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_BigEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in BigEndian order (highest byte first, lowest last) makes long.
            If array not equal 8 bytes throws exception. (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_LittleEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in LittleEndian order (lowest byte first, highest last) makes long.
            If array not equal 8 bytes throws exception. (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_BigEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in BigEndian order (highest byte first, lowest last) makes long.
            If array not equal 9 bytes return null. Range (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Int64_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in LittleEndian order (lowest byte first, highest last) makes long.
            If array not equal 9 bytes returns null. Range (-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.DynamicLength_To_UInt64_BigEndian(System.Byte[])">
            <summary>
            From dynamic byte array (up to 8 bytes) stored in BigEndian format creates ulong value, 
            note if given byte array bigger then 8 bytes - then calcualtion will start from 0
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_BigEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in BigEndian order (highest byte first, lowest last) makes ulong.
            If array not equal 8 bytes throws exception. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_LittleEndian(System.Byte[])">
            <summary>
            From 8 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ulong.
            If array not equal 8 bytes throws exception. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_BigEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in BigEndian order (highest byte first, lowest last) makes ulong?.
            If array is not equal 9 bytes returns null. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_UInt64_LittleEndian_NULL(System.Byte[])">
            <summary>
            From 9 bytes array which is in LittleEndian order (lowest byte first, highest last) makes ulong?.
            If array is not equal 9 bytes returns null. (0 to 18,446,744,073,709,551,615)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Decimal_BigEndian(System.Byte[])">
            <summary>
            Converts sortable byte[15] to decimal
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Decimal_BigEndian_NULL(System.Byte[])">
            <summary>
            Converts sortable byte[16] to decimal? if byte array lenght is not 16 returns null
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Double_BigEndian(System.Byte[])">
            <summary>
            Converts sortable byte[9] to double
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Double_BigEndian_NULL(System.Byte[])">
            <summary>
            Converts sortable byte[10] to double?
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Float_BigEndian(System.Byte[])">
            <summary>
            Converts sortable byte[4] to float
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_Float_BigEndian_NULL(System.Byte[])">
            <summary>
            Converts sortable byte[5] to float?
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_byte_array(System.Nullable{System.Byte})">
            <summary>
            Returns 2 byte array which represents byte?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array(System.DateTime)">
            <summary>
            DateTime to byte[8] big-endian.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_zCompatibility(System.DateTime)">
            <summary>
            DON't use it (only for compatibility resasons described in docu from [20120922])
            DateTime to byte[8] big-endian.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array(System.Nullable{System.DateTime})">
            <summary>
            DateTime? to byte[9] big-endian.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_1_byte_array(System.Nullable{System.Boolean})">
            <summary>
            Returns 1 byte which represents bool?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_byte_array(System.Char)">
            <summary>
            Converts char into byte[2] Unicode representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_byte_array(System.Nullable{System.Char})">
            <summary>
            Converts char? into byte[3] Unicode representation
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_byte_array(System.Nullable{System.SByte})">
            <summary>
            Converts sbyte? into 2 byte array
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_BigEndian(System.Int16)">
            <summary>
            From Int16 to 2 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_LittleEndian(System.Int16)">
            <summary>
            From Int16 to 2 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_BigEndian(System.Nullable{System.Int16})">
            <summary>
            From Int16? to 3 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_LittleEndian(System.Nullable{System.Int16})">
            <summary>
            From Int16? to 3 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_BigEndian(System.UInt16)">
            <summary>
            From UInt16 to 2 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_2_bytes_array_LittleEndian(System.UInt16)">
            <summary>
            From UInt16 to 2 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_BigEndian(System.Nullable{System.UInt16})">
            <summary>
            From UInt16? to 3 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_3_bytes_array_LittleEndian(System.Nullable{System.UInt16})">
            <summary>
            From UInt16? to 3 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_BigEndian(System.Int32)">
            <summary>
            From Int32 to 4 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_LittleEndian(System.Int32)">
            <summary>
            From Int32 to 4 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_BigEndian(System.Nullable{System.Int32})">
            <summary>
            From Int32? to 5 bytes array with BigEndian order (highest byte first, lowest last).   
            When first byte is 0 then the whole value is NULL
            When first byte is 1 then value can be converted
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_LittleEndian(System.Nullable{System.Int32})">
            <summary>
            From Int32 to 4 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_BigEndian(System.UInt32)">
            <summary>
            From UInt32 to 4 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_LittleEndian(System.UInt32)">
            <summary>
            From UInt32 to 4 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_BigEndian(System.Nullable{System.UInt32})">
            <summary>
            From UInt32? to 5 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_LittleEndian(System.Nullable{System.UInt32})">
            <summary>
            From UInt32? to 5 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_BigEndian(System.Int64)">
            <summary>
            From Int64 to 8 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_LittleEndian(System.Int64)">
            <summary>
            From Int64 to 8 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_BigEndian(System.Nullable{System.Int64})">
            <summary>
            From Int64? to 9 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_LittleEndian(System.Nullable{System.Int64})">
            <summary>
            From Int64? to 9 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_BigEndian(System.UInt64)">
            <summary>
            From UInt64 to 8 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_8_bytes_array_LittleEndian(System.UInt64)">
            <summary>
            From UInt64 to 8 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_BigEndian(System.Nullable{System.UInt64})">
            <summary>
            From UInt64? to 9 bytes array with BigEndian order (highest byte first, lowest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_LittleEndian(System.Nullable{System.UInt64})">
            <summary>
            From UInt64? to 9 bytes array with LittleEndian order (lowest byte first, highest last).        
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_15_bytes_array_BigEndian(System.Decimal)">
            <summary>
            Converts  decimal to sortable byte[15] 
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_16_bytes_array_BigEndian(System.Nullable{System.Decimal})">
            <summary>
            Converts  decimal? to sortable byte[16] 
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_9_bytes_array_BigEndian(System.Double)">
            <summary>
            Converts  double to sortable byte[9]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_10_bytes_array_BigEndian(System.Nullable{System.Double})">
            <summary>
            Converts double to sortable byte[10]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_4_bytes_array_BigEndian(System.Single)">
            <summary>
             Converts float to sortable byte[4]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_5_bytes_array_BigEndian(System.Nullable{System.Single})">
            <summary>
             Converts float? to sortable byte[5]
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.TruncateUTF8(System.String,System.Int32)">
            <summary>
            Truncates UTF-8 strign up to special maxSizeInBytes due to UTF-8 specification. 
            </summary>
            <param name="text"></param>
            <param name="maxSizeInBytes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.To_FixedSizeColumn(System.String,System.Int16,System.Boolean)">
            <summary>
            Converts your text into byte[], which can be used as column of fixedSize+2. 
            <para>(2 bytes are always added to your fixedSize value, determination of actual text size and NULL flag)</para>
            <para>String can be null</para>
            Will return byte[] with the lenght fixedSize+2 which can be stored as column.
            <para>If text.Length after convertion (using ASCII or UTF8) overexceeds fixedSize, text will be truncated</para>
            </summary>
            <param name="value">any string, can be NULL</param>
            <param name="fixedSize">reservation space(returned byte[] will be of fixedSize+2)</param>
            <param name="isASCII">if true, text will be presented as ASCII, otherwise as UTF-8</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.From_FixedSizeColumn(System.Byte[],System.Boolean)">
            <summary>
            takes byte[] created by To_FixedSizeColumn and restores string value from it.
            <para>byte[] must be of length fixedSize(which you gave in To_FixedSizeColumn) + 2</para>
            </summary>
            <param name="value"></param>
            <param name="isASCII">if true, text was presented as ASCII, otherwise as UTF-8</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytesString(System.Byte[],System.String)">
            <summary>
            Converts BytesArray to String Representation: 00-00-00-00-1F-00-00-00-00-20.
            If array is null or 0 length - returns String.Empty.
            If replaceWith is String.Empty returns such view 00-00-00-00-1F-00-00-00-00-20.
            Otherwise takes such view (-00-00-00-00-1F-00-00-00-00-20) and replaces "-" with replaceWith also calls Trim().      
            </summary>
            <param name="dBytes"></param>
            <param name="replaceWith"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.Utils.BytesProcessing._hexDigits">
            <summary>
            Used by ToBytesString
            </summary>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytesString(System.Byte[])">
            <summary>
            To pure HEX string without delimiters
            </summary>
            <param name="dBytes"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToHex(System.Byte)">
            <summary>
            Convert Byte To Hex string
            </summary>
            <param name="dByte"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBytesStringDec(System.Byte[],System.String)">
            <summary>
            Converts BytesArray to String Representation: 00-00-00-00-128-12-214-00-00-20.
            Where replaceWith = "-"
            </summary>
            <param name="dBytes"></param>
            <param name="replaceWith"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.ToBitArray(System.Byte)">
            <summary>
            BigEndian
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.Get_CRC16_AsByteArray(System.Byte[])">
            <summary>
            Returns byte representation of Crc16
            </summary>
            <param name="ar"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoOneBitUp_NoArrayGrow_BigEndian(System.Byte[])">
            <summary>
            Adds byte[] + 1 bit.
            Returns: had {255}    -> null
            Returns: had {15,255} -> {16,0} 
            Returns: had {15,248} -> {15,249} 
            Returns: bt=null || bt.Length == 0 -> null
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoOneBitUp_ArrayGrows_BigEndian(System.Byte[])">
            <summary>
            Adds + 1 bit
            The same as BytesAction_GoOneBitUp_NoArrayGrow_BigEndian but array grows
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoOneBitDown_NoArrayGrow_BigEndian(System.Byte[])">
            <summary>
            Extracts 1 bit
            Returns: {0} -> null
            Returns: {0,0,0,0} -> null
            Returns: {254} -> {253}
            Returns: {1} -> {0}
            Returns: {121,456} -> {121,455}
            Returns: {121,0} -> {120,255}
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian(System.Byte[],System.Int32)">
            <summary>
            <para>BytesAction_GoUpNextByteStart_NoArrayGrow_BigEndian</para>
            <para>Returns: had {255}    -> null</para>
            <para>Returns: had {255, 0} -> null</para>
            <para>Returns: bt=null || bt.Length less then 2  -> null</para>
            <para>Returns: had {254, 0} -> {255, 0}</para>
            <para>Returns: had {120, 115, 147} -> {120, 116, 0}</para>
            </summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:DBreeze.Utils.BytesProcessing.BytesAction_GoDownNextByteStart_NoArrayGrow_BigEndian(System.Byte[],System.Int32)" -->
        <member name="M:DBreeze.Utils.BytesProcessing._Equals(System.Byte[],System.Byte[])">
            <summary>
            <para>USE _ByteArrayEquals</para>
            If both arrays are null, returns true. Checks nulls also. Uses SequenceEqual
            </summary>
            <param name="ar"></param>
            <param name="compareArray"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing._ByteArrayEquals(System.Byte[],System.Byte[])">
            <summary>
            Managed way compares 2 bytes array. Uses for loop and extra checks like null, length before
            </summary>
            <param name="b1"></param>
            <param name="b2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing._ByteArrayEquals_EqualityBrokenIndex(System.Byte[],System.Byte[])">
            <summary>
            Returns index where equality is broken.
            -2 if equal
            -1 if not comparable (null or so)
            </summary>
            <param name="b1"></param>
            <param name="b2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArraySmallerThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArraySmallerOrEqualThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArrayBiggerThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.BytesProcessing.IfStringArrayBiggerOrEqualThen(System.Byte[],System.Byte[])">
            <summary>
            String Comparation Point of view:
            "AAA" less then "AAAA"
            "AB" more then "AAAA"
            </summary>
            <param name="array"></param>
            <param name="arrayToCompare"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.Async.AsyncOperations.DoAsync``1(System.Action{``0},``0,System.Action)">
            <summary>
            Executes async, then calls Callback function
            </summary>
            <typeparam name="TInput"></typeparam>
            <param name="f"></param>
            <param name="arg"></param>
            <param name="callback"></param>
        </member>
        <member name="F:DBreeze.Transactions.TransactionsCoordinator._transactions">
            <summary>
            Dictionary of all active transactions. Key is ManagedThreadId
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTransaction">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTransactionUnit(System.Int32)">
            <summary>
            
            </summary>
            <param name="transactionThreadId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.UnregisterTransaction(System.Int32)">
            <summary>
            
            </summary>
            <param name="transactionThreadId"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.UnregisterAllTransactions">
            <summary>
            Is called by the engine on Dispose.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.RegisterWriteTablesForTransaction(System.Int32,System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            Access synchronizer.
            All calls of the WRITE LOCATOR come over this function.
            </summary>
            <param name="transactionThreadId"></param>
            <param name="tablesNames"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTable_WRITE(System.String,System.Int32)">
            <summary>
            Can return NULL (if DbIsNotOperatable)
            </summary>
            <param name="tableName"></param>
            <param name="transactionThreadId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.GetTable_READ(System.String,System.Int32)">
            <summary>
            Can return NULL if table doesn't exist
            Can return NULL (if DbIsNotOperatable)
            
            Differs from GetTable_Write:
            1. table is not registered for Write;
            2. Table is not created, if doesn't exist.
            </summary>
            <param name="tableName"></param>
            <param name="transactionThreadId"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionsCoordinator.StopEngine">
            <summary>
            Normal Engine Stop, usually in case of Main Thread or DLL disposing
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionsCoordinator.GetSchema">
            <summary>
            Fast access to the Schema object.
            Used by Transaction class
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.Cache">
            <summary>
            Cache for overwriting nodes and values
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.TableIsModified">
            <summary>
            Identifies that after Saving0generationNode was made no changes (Add,Remove etc)
            Used via TableIsModified
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie._DtTableFixed">
            <summary>
            Is by Commit and Rollback only, we will use it to return correct ReadRootNodes out to the system
            Access via DtTableFixed interface ITrie
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie.NestedTablesCoordinator">
            <summary>
            Coordinator of nested tables
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.CheckTableIsOperable">
            <summary>
            Will return exception, if not.
            Must be called by all functions
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetTable(DBreeze.LianaTrie.LTrieRow,System.Byte[]@,System.UInt32,DBreeze.LianaTrie.LTrie,System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="row"></param>
            <param name="tableIndex"></param>
            <param name="masterTrie"></param>
            <param name="insertTable">Regulates if InsertTable or SelectTable was called (ability to create table if it doesn't exist)</param>
            <param name="useCache">Regulates READ table thread or WRITE table thread - visibilityscope</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Add(System.Byte[],System.Byte[])">
            <summary>
            Adds key. Overload without refs
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Add(System.Byte[]@,System.Byte[]@,System.Boolean@)">
            <summary>
            Adds key
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="WasUpdated">indicates that key we insert, already existed in the system and was updated</param>
            <returns>returns physical link to value</returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.AddPartially(System.Byte[],System.Byte[],System.UInt32,System.Int64@)">
            <summary>
            Overload without refs
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.AddPartially(System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@)">
            <summary>
            REMEMBER THAT 
            all keys are first formed in memory and then copied to the disk, so it's not for storing movies inside of the value.
            For storing movies (BLOBs) will be used other approach, see docu.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.AddPartially(System.Byte[]@,System.Byte[]@,System.UInt32,System.Int64@,System.Boolean@)">
            <summary>
            REMEMBER THAT 
            all keys are first formed in memory and then copied to the disk, so it's not for storing movies inside of the value.
            For storing movies (BLOBs) will be used other approach, see docu.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="startIndex"></param>
            <param name="WasUpdated"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Remove(System.Byte[]@,System.Boolean@)">
            <summary>
            Removes the key
            </summary>
            <param name="key"></param>
            <param name="WasRemoved">indicates that value existed if true</param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.SaveGenerationMap">
            <summary>
            Technical function.
            Used by Fetch SYNCHRO_READ FUNCs, which use write root node, to make last in-memory changes to flash on the disk, before commit.
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetTrieReadNode(System.Int64@)">
            <summary>
            Interface function which recreates every time new rootNode from itself by every new function call.
            and also packs root node last fixation dateTime (ROLL or COMMIT).
            It will be used for READ FUNC's via Transaction, they can decide if to create new instance of read root or use existing.
            Returns NULL is !TableIsOperable.
            </summary>
            <param name="modifiedDt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Count(System.Boolean)">
            <summary>
            if useCache = true; uses newly created root node, else uses writing root node
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.Count(DBreeze.Tries.ITrieRootNode)">
            <summary>
            Can be used inside of DBreeze - concerns all read functions
            </summary>
            <param name="SYNCHRO_READ"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetKey(System.Byte[],System.Boolean)">
            <summary>
            if useCache = true; uses newly created root node, else uses writing root node
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.GetKey(System.Byte[]@,DBreeze.Tries.ITrieRootNode)">
            <summary>
            DBreeze compatible.
            Extension, which helps to READ-THREADS smartly utilize created before read-roots
            </summary>
            <param name="key"></param>
            <param name="readRootNode">if null then WRITE-ROOT NODE</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateForwardStartsWith(System.Byte[])">
            <summary>
            Always creates new root to get committed data
            </summary>
            <param name="startKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateForwardStartsWithClosestToPrefix(System.Byte[])">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateForwardStartsWithClosestToPrefix(System.Byte[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateForwardStartsWithClosestToPrefix(System.Byte[],DBreeze.Tries.ITrieRootNode)">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <param name="readRootNode"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateBackwardStartsWithClosestToPrefix(System.Byte[])">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateBackwardStartsWithClosestToPrefix(System.Byte[],System.Boolean)">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <param name="useCache"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.IterateBackwardStartsWithClosestToPrefix(System.Byte[],DBreeze.Tries.ITrieRootNode)">
            <summary>
            
            </summary>
            <param name="startKey"></param>
            <param name="readRootNode"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.SingleCommit">
            <summary>
            Wrapper for ITransactable
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrie.SingleRollback">
            <summary>
            Wrapper for ITransactable
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrie._modificationThreadId">
            <summary>
            This variable becomes value more then -1 via TrasactionCoordinator, when it returns TableForWrite
            It becomes -1 after Transaction End call.
            No need of lock.
            </summary>
        </member>
        <member name="T:DBreeze.Storage.IRollBackFile">
            <summary>
            Used by LTrie Write Cache
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRollback.DeleteRollBackFile">
            <summary>
            Is called after all is committed
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRollback.StartInitialRollBack">
            <summary>
            Is called after LTrie init.
            For Transaction End (not committed values rollback call RollBackData())
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRollback.RollBackData">
            <summary>
            Must be called when Transaction Ends
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRollback.ParseRollBackFile(System.Byte[])">
            <summary>
            
            </summary>
            <param name="rbd"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRollback.BlackListPointer(System.Byte[])">
            <summary>
            In case if we write to the end of File, and then this pointer will be reused in future data processing
            we don't need to take care of it, so we try to "BlackList it"
            Implementers:
            LTrieGenerationNode.WriteSelf - when writing kids onto the new place
            </summary>
            <param name="offset"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRollback.ReadRollBackdata(System.Int64,System.Int32)">
            <summary>
            Reads RollBack Data, for now used by Readign Rollback for overwritten values.
            Uses lock_fs, together with RollBack
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRollback.WriteRollBackData(System.Byte,System.Byte[],System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="rollbackType"></param>
            <param name="offset"></param>
            <param name="data"></param>
            <returns>-1 or Pointer to the data inside of RollBackFile</returns>
        </member>
        <member name="T:DBreeze.DataTypes.NestedTableInternal">
            <summary>
            In developing, will represent a table inside of the other table
            </summary>
        </member>
        <member name="F:DBreeze.DataTypes.NestedTableInternal.TableExists">
            <summary>
            Identifies that table is fake, because we always want to return data even default (count - 0, select - row with .Exists= false etc...)
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.Storage">
            <summary>
            DISK OR MEMORY, DEFAULT IS DISK,
            DBreezeDataFolderName must be supplied.
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeConfiguration.AlternativeTablesLocations">
            <summary>
            Pattern based way to specify storage and location for tables.
            <para>Key of this dictionary must contain table pattern e.g. Article$/Items# or Car456 or Items*</para>
            <para>Value, if is String.Empty, means that table will be located in memory.</para>
            <para>Value, if not empty, means physical storage folder path, where table should reside.</para>
            <para>If table doesn't intersect any pattern then default DB configuration will be overriden for the storage.</para>
            <para>If table intersects more the one pattern then first found will be applied.</para>
            <para>Help for patterns:</para>
            <para>$ * #</para>
            <para>"U" symbol in the following examples means intersection</para>
            <para>* - 1 or more of any symbol kind (every symbol after * will be cutted): Items* U Items123/Pictures</para>
            <para># - symbols (except slash) followed by slash and minimum another symbol: Items#/Picture U Items123/Picture</para>
            <para>$ - 1 or more symbols except slash (every symbol after $ will be cutted): Items$ U Items123;  Items$ !U Items123/Pictures </para>
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeConfiguration.Backup">
            <summary>
            Incremental backup plan. If is not instantiated, incremental backup will be switch off
            </summary>
        </member>
        <member name="P:DBreeze.DBreezeConfiguration.DBreezeDataFolderName">
            <summary>
            Folder where will reside DBreeze database files
            </summary>
        </member>
        <member name="T:DBreeze.Transactions.TransactionUnit">
            <summary>
            This object includes class Transaction (visible for the user) and holds internally technical transaction information.
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._transaction">
            <summary>
            Represents object which will be used by user, there we have all query methods, depending upon query we now if the table has to be locked or not.
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._sync_transactionWriteTables">
            <summary>
            Lock for all tables definitions inside current transaction
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._transactionWriteTables">
            <summary>
            It holds all tables marked for possible mutations
            </summary>
        </member>
        <member name="F:DBreeze.Transactions.TransactionUnit._transactionWriteTablesAwaitingReservation">
            <summary>
            List of tables which are waiting for reservation for writing, we need it to predict deadlock situations.
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.AddTransactionWriteTablesAwaitingReservation(System.Collections.Generic.List{System.String})">
            <summary>
            Used by TransactionCoordinator.RegisterWriteTablesForTransaction
            </summary>
            <param name="tablesNames"></param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.AddTransactionWriteTable(System.String,DBreeze.Transactions.ITransactable)">
            <summary>
            Adds a table which will take place in transaction operations.
            Reserved has value null, Real (which are acquired by Transaction for Write) has ITransactable filled.
            ITransactable = null, gives to differ from toched and reserved.
            </summary>
            <param name="tableName"></param>
            <param name="table">if null - will be added to Reservation table</param>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.GetTransactionWriteTables">
            <summary>
            Doesn't need pattern check
            Returns all tables which took place in write operation for the current transaction
            Without reserved as Text tables only which have real ITransactable inside
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.If_TableIsReservedForWrite(System.String)">
            <summary>
            Used inside of Transaction, we can choose fot READ or READ_SYNCHRO for READ FUNCs
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.GetTransactionWriteTablesNames">
            <summary>
            Returns only table names for reservation
            </summary>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.Commit">
            <summary>
            
            </summary>
        </member>
        <member name="M:DBreeze.Transactions.TransactionUnit.RollBack">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.TransactionsCoordinator">
            <summary>
            Easy access to transactin coordinator for the Transaction which is visible for the user
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.Transaction">
            <summary>
            Transaction visible for the user
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.TransactionThreadId">
            <summary>
            
            </summary>
        </member>
        <member name="P:DBreeze.Transactions.TransactionUnit.TransactionWriteTablesCount">
            <summary>
            returns count of reserved tables, used by transaction just to find out if reservation (or first table modification) was done or not.
            reservation can be done only once.
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.DBreezeEngine">
            <summary>
            Main DBreeze Database class.
            </summary>
        </member>
        <member name="F:DBreeze.DBreezeEngine.Version">
            <summary>
            DBreeze version number
            </summary>        
        </member>
        <member name="F:DBreeze.DBreezeEngine.Configuration">
            <summary>
            Dbreeze Configuration.
            For now BackupPlan is included.
            Later can be added special settings for each entity defined by string pattern.
            </summary>
        </member>
        <member name="M:DBreeze.DBreezeEngine.#ctor(DBreeze.DBreezeConfiguration)">
            <summary>
            Dbreeze instantiator
            </summary>
            <param name="dbreezeConfiguration"></param>
        </member>
        <member name="M:DBreeze.DBreezeEngine.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="DBreezeDataFolderName"></param>
        </member>
        <member name="M:DBreeze.DBreezeEngine.GetTransaction">
            <summary>
            Returns transaction object.
            </summary>
            <returns></returns>
        </member>
        <member name="P:DBreeze.DBreezeEngine.Scheme">
            <summary>
            Returns DBreeze schema object
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieSetupKidResult.ValueLink">
            <summary>
            Link to the full value line (together with the key)
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbUnicode.Get">
            <summary>
            Returns string from the object
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRow.ValueStartPointer">
            <summary>
            Represents pointer to the value in physical file, remember for READ must come via sync-cache
            -1 if not defined
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRow.ValueFullLength">
            <summary>
            If ValueStartPointer == -1, has no meaning
            </summary>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieRow.Key">
            <summary>
            Default is null
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRow.GetPartialValue(System.UInt32,System.UInt32,System.Boolean)">
            <summary>
            Returns either value partially or null
            </summary>
            <param name="startIndex"></param>
            <param name="length"></param>
            <param name="useCache">if true, then only committed data will be shown</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieRow.GetFullValue(System.Boolean)">
            <summary>
            Returns either value as byte array or null if value doesn't exist
            </summary>
            <param name="useCache">if true, then only committed data will be shown</param>
            <returns></returns>
        </member>
        <member name="P:DBreeze.LianaTrie.LTrieRow.LinkToValue">
            <summary>
            Experimental, instead of Value, we supply link to the value
            </summary>
        </member>
        <member name="P:DBreeze.LianaTrie.LTrieRow.Exists">
            <summary>
            Default is false
            </summary>
        </member>
        <member name="M:DBreeze.Storage.Backup.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="backupFolderName">Folder where will be restored incremental backup</param>
        </member>
        <member name="M:DBreeze.Storage.Backup.SynchronizeBackup">
            <summary>
            Main task is to find out if last .RHP state is correclty reflected inside of the incremental backup.
            Having DBreezeFolderName we know exactly the location of Transaction Journal and Scheme.
            For now all other tables are also reside in DBreezeFolderName, so no problems.
            Later, when we add in configuration ability to reside different files accross different physical drives,
            we will have to call such synchronization for other tables (except Scheme and Journal) and supply real file pathes.
            </summary>
        </member>
        <member name="M:DBreeze.Storage.Backup.WriteRHP(System.UInt64,System.Int64,System.Byte[]@)">
            <summary>
            Atomic synchronizer between RollbackHelper and Incremental backups
            </summary>
            <param name="fileNumber"></param>
            <param name="lastRollBackLength"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.Backup.WriteBackupElement(System.UInt64,System.Byte,System.Int64@,System.Byte[]@)">
            <summary>
            Represents incremental backup of protocol 1
            case 2 is handeled by WriteRHP 
            </summary>
            <param name="fileNumber"></param>
            <param name="type">0 - table file, 1 - rollback file, 2 - rollbackhelper, 3 - recreate table file, 4 - recreate rollback file, 5 - removing complete table </param>
            <param name="pos"></param>
            <param name="data"></param>
        </member>
        <member name="M:DBreeze.Storage.Backup.WriteBackupElement(System.UInt64,System.Byte,System.Int64@,System.Byte[][]@)">
            <summary>
            Represents incremental backup of protocol 1
            </summary>
            <param name="fileNumber"></param>
            <param name="type">0 - table file, 1 - rollback file, 2 - rollbackhelper, 3 - recreate table file, 4 - recreate rollback file, 5 - removing complete table</param>
            <param name="pos"></param>
            <param name="data"></param>
        </member>
        <member name="P:DBreeze.Storage.Backup.IncrementalBackupFileIntervalMin">
            <summary>
            Identifies how often will be created new file for backup (Minimum 5 minutes).
            Default value is one day
            </summary>
        </member>
        <member name="P:DBreeze.Storage.Backup.BackupFolderName">
            <summary>
            Folder where backup files will be created
            </summary>
        </member>
        <member name="M:DBreeze.Storage.Backup.BackupFileNamesParser.ParseFilename(System.String)">
            <summary>
            Helper for table file names transitions for backup
            </summary>
            <param name="fileName"></param>
            <returns></returns>
        </member>
        <member name="T:DBreeze.Storage.Backup.BackupRestorer">
            <summary>
            Access to Database restoration from incremental backups.
            </summary>
        </member>
        <member name="F:DBreeze.Storage.Backup.BackupRestorer.ds">
            <summary>
            Holder of filenames and file handlers
            </summary>
        </member>
        <member name="M:DBreeze.Storage.Backup.BackupRestorer.StartRestoration">
            <summary>
            Starts backup restore routine
            </summary>
        </member>
        <member name="E:DBreeze.Storage.Backup.BackupRestorer.OnRestore">
            <summary>
            Subscribe on it to receive notification about restore process
            </summary>
        </member>
        <member name="P:DBreeze.Storage.Backup.BackupRestorer.DataBaseFolder">
            <summary>
            Place where resides or should reside database
            </summary>
        </member>
        <member name="P:DBreeze.Storage.Backup.BackupRestorer.BackupFolder">
            <summary>
            Place where reside incremnetal dbreeze backup files
            </summary>
        </member>
        <member name="T:DBreeze.Storage.Backup.BackupRestorer.BackupRestorationProcess">
            <summary>
            Object characterizes the backup restoration process
            </summary>
        </member>
        <member name="P:DBreeze.Storage.Backup.BackupRestorer.BackupRestorationProcess.ReadinessInProcent">
            <summary>
            How many procesnt of restoration is done
            </summary>
        </member>
        <member name="P:DBreeze.Storage.Backup.BackupRestorer.BackupRestorationProcess.Finished">
            <summary>
            true when restore is completed
            </summary>
        </member>
        <member name="T:DBreeze.Exceptions.TableNotOperableException">
            <summary>
            This is a specific Exception which will bring to DB is not opearable state, we need to analyze this type of exception separately,
            that's why extra class.
            </summary>
        </member>
        <member name="T:DBreeze.Exceptions.DBreezeException">
            <summary>
            Unified class for Debreeze exceptions
            </summary>
        </member>
        <member name="M:DBreeze.Exceptions.DBreezeException.GenerateException(DBreeze.Exceptions.DBreezeException.eDBreezeExceptions,System.String,System.Exception)">
            <summary>
            Internal
            </summary>
            <param name="exceptionType"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="P:DBreeze.DataTypes.DbUTF8.Get">
            <summary>
            Returns string from the object
            </summary>
        </member>
        <member name="T:DBreeze.DataTypes.DbXML`1">
            <summary>
            <para>Microsoft XML</para>
            <para></para>
            <para>Possible to make like this, without class instantiating:</para>
            <para>List&lt;string&gt; aa = new List&lt;string&gt;();</para>
            <para>aa.Add("test1")</para>
            <para>aa.Add("test2")</para>
            <para>-----inside of transaction---------</para>
            <para>tran.Insert&lt;uint, DbXML&lt;List&lt;string&gt;&gt;&gt;("t1", i, aa);</para>
            <para>-----------------------------------</para>
            <para>foreach (var row in tran.SelectForward&lt;uint, DbXML&lt;List&lt;string&gt;&gt;&gt;("t1"))</para>
            <para>Console.WriteLine("K: {0}; V: {1}", row.Key.ToString(), (row.Value == null) ? "NULL" : row.Value.Get.Count().ToString());</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DBreeze.DataTypes.DbXML`1.SerializedObject">
            <summary>
            Returns serialized string representing the internal object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbXML`1.Get">
            <summary>
            Gets deserialized object
            </summary>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.UserTableNameIsOk(System.String)">
            <summary>
            Checks validity of the user table name
            </summary>
            <param name="tableName"></param>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.UserTablePatternIsOk(System.String)">
            <summary>
            Throws exception if smth. happened.
            Returns either original table name or cutted if * is found
            </summary>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.PatternsIntersect(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.TableNamesIntersect(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Checks intersection between two lists of patterns
            </summary>
            <param name="list1"></param>
            <param name="list2"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.TableNamesContains(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Checks intersection between List of patterns and one pattern
            </summary>
            <param name="list1"></param>
            <param name="tableName"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.SchemeInternal.DbUserTables.TestIntersectionPatterns(System.Boolean,System.String,System.String)">
            <summary>
            TEST Intersections pattern
            </summary>
            <param name="assumption">your assumption, if intersects or not</param>
            <param name="p1">pattern 1</param>
            <param name="p2">pattern 2</param>
        </member>
        <member name="M:DBreeze.DataTypes.DataTypesConvertor.ConvertBack``1(System.Byte[])">
            <summary>
            CONVERTING FROM byte[] to the generic type
            </summary>
            <typeparam name="TData"></typeparam>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.XmlSerializator.SerializeXml(System.Object)">
            <summary>
            Serializes object to XML string
            </summary>
            <param name="objectForSerialization"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.Utils.XmlSerializator.DeserializeXml``1(System.String)">
            <summary>
            Deserializes object from XML string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieWriteCache.RollbackIsVirtualized">
            <summary>
            Default value for main tries is false, for nested tables becomes true
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.RecreateDB">
            <summary>
            Used by Root Node RemoveAll with key re-creation
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.TransactionalCommitFinished">
            <summary>
            We need here to clear old root and delete RollBackFile
            Exception will bring to not-operatable db
            </summary>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.TransactionalCommit(System.Byte[]@,System.Byte[]@)">
            <summary>
            Commit inside of transaction
            </summary>
            <param name="rootData"></param>
            <param name="oldRootData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.Commit(System.Byte[]@,System.Byte[]@)">
            <summary>
            Commit single table only
            </summary>
            <param name="rootPointer"></param>
            <param name="rootData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GetNodeKids(System.Byte[])">
            <summary>
            Returns NULL if not found
            </summary>
            <param name="generationMapLine"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.AddMapKids(System.Byte[],System.Byte[])">
            <summary>
            If line exists - makes nothing, otherwise writes in
            </summary>
            <param name="generationMapLine"></param>
            <param name="kidsBeforeModification"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GenerationNodeWritingEnd(System.Byte[],System.Byte[]@)">
            <summary>
            Writing Generation Node to the end of File.
            We use current generation node pointer to black list it.
            if we reuse this new pointer inside of one transaction for overwriting, we don't need to back it up for rollback any more.
            </summary>
            <param name="pointer"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.GenerationNodeWritingOver(System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            OverWriting Generation Node, we supply params where, oldData and newData.
            Old Data will be put into RollBack
            </summary>
            <param name="pointer"></param>
            <param name="oldData"></param>
            <param name="newData"></param>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadDynamicDataBlock(System.Byte[]@,System.Boolean)">
            <summary>
            
            </summary>
            <param name="initPtr"></param>
            <param name="useCache"></param>
            <returns>return NULL if not found or stored value is NULL, otherwise returns byte[]</returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.WriteDynamicDataBlock(System.Byte[]@,System.Byte[]@)">
            <summary>
            
            </summary>
            <param name="initPtr"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadKeyFromDB(System.Byte[])">
            <summary>
            Internal function for reading key only from DB storage
            Is called from ReadKey
            </summary>
            <param name="pointer"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadKey(System.Boolean,System.Byte[])">
            <summary>
            UseCache only must be declared by READ-FUNC
            </summary>
            <param name="useCache"></param>
            <param name="pointer"></param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadValue(System.Byte[],System.Boolean,System.Int64@,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="pointer"></param>
            <param name="useCache"></param>
            <param name="valueStartPtr">returns pointer where value starts from. -1 if can't be determined</param>
            <param name="valueLength">returns full value length; 0 - default</param>
            <returns></returns>
        </member>
        <member name="M:DBreeze.LianaTrie.LTrieWriteCache.ReadValuePartially(System.Byte[],System.UInt32,System.UInt32,System.Boolean,System.Int64@,System.UInt32@)">
            <summary>
            
            </summary>
            <param name="pointer"></param>
            <param name="startIndex"></param>
            <param name="length"></param>
            <param name="useCache"></param>
            <param name="valueStartPtr">returns pointer where value starts from. -1 if can't be determined</param>
            <param name="valueLength">returns full value length; 0 - default</param>
            <returns></returns>
        </member>
        <member name="F:DBreeze.LianaTrie.LTrieWriteCache.DataIdentifier.ResidesInRollbackFile">
            <summary>
            Identifies that piece of data is in Rollback file. Otherwise in real file
            </summary>
        </member>
        <member name="F:DBreeze.SchemeInternal.OpenTable.qOpen">
            <summary>
            Quantity of open exemplars
            </summary>
        </member>
        <member name="M:DBreeze.SchemeInternal.OpenTable.Add">
            <summary>
            Inceases quantity of usage by one
            </summary>
        </member>
        <member name="M:DBreeze.SchemeInternal.OpenTable.Remove(System.UInt64)">
            <summary>
            Decreases quantity of usage by one and returns true if table can be automatically closed
            </summary>
            <returns></returns>
        </member>
        <member name="T:DBreeze.DataTypes.DbAscii">
            <summary>
            String.Empty is will return NULL
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbAscii.Get">
            <summary>
            Returns string from the object
            </summary>
        </member>
        <member name="T:DBreeze.DataTypes.DbMJSON`1">
            <summary>
            <para>Microsoft JSON</para>
            <para></para>
            <para>Possible to make like this, without class instantiating:</para>
            <para>List&lt;string&gt; aa = new List&lt;string&gt;();</para>
            <para>aa.Add("test1")</para>
            <para>aa.Add("test2")</para>
            <para>-----inside of transaction---------</para>
            <para>tran.Insert&lt;uint, DbMJSON&lt;List&lt;string&gt;&gt;&gt;("t1", i, aa);</para>
            <para>-----------------------------------</para>
            <para>foreach (var row in tran.SelectForward&lt;uint, DbMJSON&lt;List&lt;string&gt;&gt;&gt;("t1"))</para>
            <para>Console.WriteLine("K: {0}; V: {1}", row.Key.ToString(), (row.Value == null) ? "NULL" : row.Value.Get.Count().ToString());</para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:DBreeze.DataTypes.DbMJSON`1.SerializedObject">
            <summary>
            Returns serialized string representing the internal object
            </summary>
        </member>
        <member name="P:DBreeze.DataTypes.DbMJSON`1.Get">
            <summary>
            Gets deserialized object
            </summary>
        </member>
    </members>
</doc>
